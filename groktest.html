<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebXR Mole Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif; 
      background-color: #222;
      color: white;
    }
    #ui-container {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 100;
      pointer-events: none;
      width: 100%;
    }
    button {
      pointer-events: auto;
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 0;
      transition: background-color 0.2s;
    }
    button:hover { background: #3e8e41; }
    button:active { background: #2e6830; }
    #instructions, #detecting-floor {
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      max-width: 400px;
      margin: 20px auto;
    }
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
    }
    .progress-bar {
      width: 300px;
      height: 20px;
      background-color: #333;
      border-radius: 10px;
      margin-top: 20px;
    }
    .progress {
      height: 100%;
      background-color: #4CAF50;
      border-radius: 10px;
      width: 0%;
      transition: width 0.3s;
    }
    .non-vr-instructions {
      background: rgba(0,0,0,0.7);
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
      font-size: 14px;
      max-width: 600px;
      text-align: center;
    }
    #ammo-counter {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 10px 15px;
      border-radius: 20px;
      font-size: 18px;
      font-weight: bold;
      display: none;
    }
  </style>
</head>
<body>
  <div id="loading-screen">
    <h2>Loading WebXR Mole Shooter</h2>
    <div class="progress-bar">
      <div class="progress" id="progress-bar"></div>
    </div>
    <p id="loading-status">Preparing game...</p>
    <div class="non-vr-instructions">
      <p><strong>Note:</strong> This game requires a WebXR compatible device and browser.</p>
      <p>Point your gun at the floor and pull the trigger to set the floor level.</p>
      <p>Shoot the moles to score points!</p>
    </div>
  </div>

  <div id="ui-container">
    <div id="detecting-floor" style="display: none;">
      <h2>Set Floor Level</h2>
      <p>Point your gun at the floor and pull the trigger.</p>
    </div>
    <div id="instructions">
      <h1>WebXR Mole Shooter</h1>
      <p>Enter AR to start the game</p>
      <button id="enter-ar">Enter AR</button>
    </div>
  </div>

  <div id="ammo-counter">
    Ammo: <span id="ammo">∞</span>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.156.1'; // Updated to a recent version

    // Game Variables
    let camera, scene, renderer;
    let controller;
    let raycaster = new THREE.Raycaster();
    let tempMatrix = new THREE.Matrix4();
    let moles = [];
    let projectiles = [];
    let score = 0;
    let timeRemaining = 60;
    let gameActive = false;
    let floorY = null;
    let floorSet = false;
    let currentGameMode = 'classic';
    let lastFireTime = 0;
    let models = {};
    let scoreboard;

    // Game Modes
    const GAME_MODES = {
      classic: { name: "Classic", duration: 60, spawnInterval: 2000, moleLifetime: 3000 },
      timeAttack: { name: "Time Attack", duration: 30, spawnInterval: 1500, moleLifetime: 2500, timeBonus: 2 },
      endless: { name: "Endless", duration: Infinity, spawnInterval: 2000, moleLifetime: 3000, missesAllowed: 5 },
      frenzy: { name: "Frenzy", duration: 30, spawnInterval: 800, moleLifetime: 2000 }
    };

    // Game Configuration
    const GAME_CONFIG = {
      playArea: { width: 3, depth: 3 },
      moleTypes: [
        { id: 'regular', points: 10, color: 0x8B4513, scale: 0.2, speed: 1 },
        { id: 'fast', points: 20, color: 0x00AA00, scale: 0.18, speed: 1.5 },
        { id: 'golden', points: 50, color: 0xFFD700, scale: 0.22, speed: 0.8 }
      ],
      projectile: { speed: 15, lifetime: 2000, cooldown: 300, size: 0.05, color: 0x00FFFF }
    };

    // Audio Context
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function createSound(type) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      if (type === 'hit') {
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(660, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.1);
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
      } else if (type === 'fire') {
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.05);
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.1);
      } else if (type === 'gameOver') {
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.5);
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.8);
      }
    }

    // Initialize Game
    function init() {
      console.log('Initializing game...');
      document.getElementById('loading-status').textContent = 'Setting up game environment...';
      updateProgressBar(10);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0.5, 1, 0.25);
      scene.add(directionalLight);

      updateProgressBar(20);
      document.getElementById('loading-status').textContent = 'Preparing renderer...';

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      updateProgressBar(40);
      document.getElementById('loading-status').textContent = 'Creating models...';

      createPlaceholderModels();
      createScoreboard();

      updateProgressBar(70);
      document.getElementById('loading-status').textContent = 'Setting up AR environment...';

      document.getElementById('enter-ar').addEventListener('click', () => {
        if (navigator.xr) {
          navigator.xr.requestSession('immersive-ar', {
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.getElementById('ui-container') }
          }).then(onSessionStarted).catch(err => {
            console.error('Failed to start AR session:', err);
            alert('Failed to start AR session. Please check device compatibility.');
          });
        } else {
          alert('WebXR not supported on this browser');
        }
      });

      updateProgressBar(100);
      document.getElementById('loading-status').textContent = 'Ready!';
      setTimeout(() => document.getElementById('loading-screen').style.display = 'none', 1000);

      renderer.setAnimationLoop(render);
    }

    function updateProgressBar(percent) {
      document.getElementById('progress-bar').style.width = `${percent}%`;
    }

    // Create Placeholder Models
    function createPlaceholderModels() {
      GAME_CONFIG.moleTypes.forEach(type => {
        const geometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 32);
        const material = new THREE.MeshPhongMaterial({ color: type.color });
        const mesh = new THREE.Mesh(geometry, material);
        const container = new THREE.Group();
        container.add(mesh);
        models[type.id] = { object: container };
      });

      const gunGroup = new THREE.Group();
      const barrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.01, 0.01, 0.2, 16),
        new THREE.MeshPhongMaterial({ color: 0x444444 })
      );
      barrel.rotation.x = Math.PI / 2;
      barrel.position.z = -0.1;
      gunGroup.add(barrel);
      models.gun = { object: gunGroup };

      const projectileGeometry = new THREE.SphereGeometry(GAME_CONFIG.projectile.size, 16, 16);
      const projectileMaterial = new THREE.MeshPhongMaterial({ color: GAME_CONFIG.projectile.color, emissive: 0x00FFFF, emissiveIntensity: 0.5 });
      models.projectile = { object: new THREE.Mesh(projectileGeometry, projectileMaterial) };
    }

    // Create In-Game Scoreboard
    function createScoreboard() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 256;
      const context = canvas.getContext('2d');
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const geometry = new THREE.PlaneGeometry(1, 0.5);
      scoreboard = new THREE.Mesh(geometry, material);
      scoreboard.position.set(0, 1.5, -1);
      scene.add(scoreboard);

      function updateScoreboard() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'rgba(0,0,0,0.7)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'white';
        context.font = '40px Arial';
        context.textAlign = 'center';
        context.fillText(`Score: ${score}`, 256, 60);
        context.fillText(`Time: ${timeRemaining === Infinity ? '∞' : Math.round(timeRemaining)}s`, 256, 120);
        context.fillText(`Mode: ${GAME_MODES[currentGameMode].name}`, 256, 180);
        context.fillText('Shoot to change mode', 256, 240);
        texture.needsUpdate = true;
      }

      scoreboard.update = updateScoreboard;
      scoreboard.update();
    }

    // Session Handlers
    function onSessionStarted(session) {
      document.getElementById('instructions').style.display = 'none';
      document.getElementById('detecting-floor').style.display = 'block';

      session.addEventListener('end', onSessionEnded);
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);

      controller = renderer.xr.getController(0);
      controller.addEventListener('selectstart', onSelectStart);
      scene.add(controller);

      const gun = models.gun.object.clone();
      controller.add(gun);

      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
    }

    function onSessionEnded() {
      document.getElementById('instructions').style.display = 'block';
      document.getElementById('detecting-floor').style.display = 'none';
      document.getElementById('ammo-counter').style.display = 'none';
      endGame();
    }

    // Input Handlers
    function onSelectStart(event) {
      if (!floorSet) {
        tempMatrix.identity().extractRotation(controller.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        const direction = raycaster.ray.direction.clone();
        const origin = raycaster.ray.origin.clone();
        floorY = origin.y - direction.y * 2; // Assume 2 meters above floor
        floorSet = true;
        document.getElementById('detecting-floor').style.display = 'none';
        document.getElementById('ammo-counter').style.display = 'block';
        startGame();
      } else if (gameActive) {
        fireProjectile(event.target);
      } else {
        currentGameMode = Object.keys(GAME_MODES)[(Object.keys(GAME_MODES).indexOf(currentGameMode) + 1) % 4];
        scoreboard.update();
        startGame();
      }
    }

    // Fire Projectile
    function fireProjectile(fromController) {
      const now = Date.now();
      if (now - lastFireTime < GAME_CONFIG.projectile.cooldown) return;
      lastFireTime = now;

      const projectile = models.projectile.object.clone();
      projectile.position.setFromMatrixPosition(fromController.matrixWorld);
      tempMatrix.identity().extractRotation(fromController.matrixWorld);
      const velocity = new THREE.Vector3(0, 0, -1).applyMatrix4(tempMatrix).multiplyScalar(GAME_CONFIG.projectile.speed);
      scene.add(projectile);
      projectiles.push({ object: projectile, velocity: velocity, createdAt: now });
      createSound('fire');
    }

    // Update Projectiles
    function updateProjectiles(delta) {
      const now = Date.now();
      const toRemove = [];

      projectiles.forEach((projectile, index) => {
        if (now - projectile.createdAt > GAME_CONFIG.projectile.lifetime) {
          scene.remove(projectile.object);
          toRemove.push(index);
        } else {
          projectile.object.position.add(projectile.velocity.clone().multiplyScalar(delta));
          moles.forEach((mole, moleIndex) => {
            if (mole.state === 'up' && projectile.object.position.distanceTo(mole.object.position) < 0.25) {
              score += mole.type.points;
              createExplosion(mole.object.position);
              createSound('hit');
              mole.goDown();
              scene.remove(projectile.object);
              toRemove.push(index);
              scoreboard.update();
            }
          });
        }
      });

      toRemove.sort((a, b) => b - a).forEach(index => projectiles.splice(index, 1));
    }

    // Create Explosion Effect
    function createExplosion(position) {
      const particleCount = 30;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = position.x;
        positions[i * 3 + 1] = position.y;
        positions[i * 3 + 2] = position.z;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xFF0000, size: 0.1, transparent: true });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      const velocities = Array(particleCount).fill().map(() => ({
        x: (Math.random() - 0.5) * 0.2,
        y: Math.random() * 0.2,
        z: (Math.random() - 0.5) * 0.2
      }));

      const startTime = Date.now();
      const duration = 500;

      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const positions = particles.geometry.attributes.position.array;

        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] += velocities[i].x;
          positions[i * 3 + 1] += velocities[i].y - 0.005;
          positions[i * 3 + 2] += velocities[i].z;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.material.opacity = 1 - progress;

        if (progress < 1) requestAnimationFrame(animate);
        else scene.remove(particles);
      }

      animate();
    }

    // Game Mechanics
    function startGame() {
      gameActive = true;
      score = 0;
      timeRemaining = GAME_MODES[currentGameMode].duration;
      scoreboard.update();

      spawnMole();
      setInterval(() => gameActive && spawnMole(), GAME_MODES[currentGameMode].spawnInterval);

      if (timeRemaining !== Infinity) {
        setInterval(() => {
          if (gameActive) {
            timeRemaining--;
            scoreboard.update();
            if (timeRemaining <= 0) endGame();
          }
        }, 1000);
      }
    }

    function endGame() {
      gameActive = false;
      createSound('gameOver');
      moles.forEach(mole => scene.remove(mole.object));
      moles = [];
      projectiles.forEach(projectile => scene.remove(projectile.object));
      projectiles = [];
    }

    function spawnMole() {
      const type = GAME_CONFIG.moleTypes[Math.floor(Math.random() * GAME_CONFIG.moleTypes.length)];
      const moleModel = models[type.id].object.clone();
      const x = (Math.random() - 0.5) * GAME_CONFIG.playArea.width;
      const z = (Math.random() - 0.5) * GAME_CONFIG.playArea.depth;
      moleModel.position.set(x, floorY - 0.4, z);
      scene.add(moleModel);

      const mole = {
        object: moleModel,
        state: 'down',
        type: type,
        riseUp: function() {
          this.state = 'rising';
          const startY = floorY - 0.4;
          const targetY = floorY;
          const startTime = Date.now();
          const duration = 500 / this.type.speed;

          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            moleModel.position.y = startY + (targetY - startY) * progress;
            if (progress < 1 && this.state === 'rising') requestAnimationFrame(animate);
            else {
              this.state = 'up';
              setTimeout(() => this.goDown(), GAME_MODES[currentGameMode].moleLifetime);
            }
          };
          animate();
        },
        goDown: function() {
          if (this.state !== 'up' || !gameActive) return;
          this.state = 'lowering';
          const startY = floorY;
          const targetY = floorY - 0.4;
          const startTime = Date.now();
          const duration = 500 / this.type.speed;

          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            moleModel.position.y = startY + (targetY - startY) * progress;
            if (progress < 1 && this.state === 'lowering') requestAnimationFrame(animate);
            else {
              moles.splice(moles.indexOf(this), 1);
              scene.remove(moleModel);
            }
          };
          animate();
        }
      };

      moles.push(mole);
      mole.riseUp();
    }

    // Render Loop
    function render(timestamp, frame) {
      const delta = 0.016; // Assuming ~60fps
      if (gameActive) updateProjectiles(delta);
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>