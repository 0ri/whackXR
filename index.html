<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Whack-a-Mole</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #startAR {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            text-shadow: 0 0 5px black;
            pointer-events: none;
        }

        .hidden {
            display: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        // Import Three.js from CDN
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // === DEBUG LOGGER FOR AR ===
        let debugLog = null;
        let debugMessages = [];
        function createDebugLog() {
            debugLog = document.createElement('div');
            debugLog.id = 'debugLog';
            debugLog.style.cssText = `
                position: fixed; top: 10px; left: 10px; width: 400px; max-height: 300px;
                background: rgba(0,0,0,0.8); color: #0f0; font-family: monospace; font-size: 11px;
                padding: 10px; overflow-y: auto; z-index: 9999; border-radius: 5px;
                pointer-events: none;
            `;
            document.body.appendChild(debugLog);
        }
        function debugPrint(msg) {
            const time = new Date().toLocaleTimeString();
            debugMessages.push(`[${time}] ${msg}`);
            if (debugMessages.length > 30) debugMessages.shift();
            if (debugLog) debugLog.innerHTML = debugMessages.join('<br>');
            console.log(msg);
        }
        // Capture all errors
        window.onerror = (msg, url, line, col, error) => {
            debugPrint(`ERROR: ${msg} at line ${line}`);
            return false;
        };
        window.addEventListener('unhandledrejection', e => {
            debugPrint(`PROMISE ERROR: ${e.reason}`);
        });
        // Create debug log immediately
        createDebugLog();
        debugPrint('Debug logger initialized');

        // Game state variables
        let scene, camera, renderer;
        let gameContainer;
        let scoreDisplay, timerDisplay;
        let controller, controllerGrip;
        let raycaster, tempMatrix;
        let floorGroup, moleGroup, scoreSign, particlesGroup;
        let levelCompleteUI;

        // === VISUAL ENHANCEMENT VARIABLES ===
        let composer = null;
        let bloomPass = null;
        let sunLight = null;
        let skyMesh = null;
        let grassBlades = [];
        let rocks = [];
        let flowers = [];
        let clouds = [];
        let fireflies = [];
        let groundDetails = null;
        
        // Phase 1: Lighting & Atmosphere
        let timeOfDay = 0.5; // 0=midnight, 0.5=noon, 1=midnight
        let fogDensity = 0.02;
        let godRays = [];
        
        // Phase 2: Ground & Terrain
        let groundMesh = null;
        let impactDecals = [];
        
        // Phase 3: Creature enhancements
        let creatureGlowMaterials = new Map();
        
        // Phase 4: Particle systems
        let hitParticlePool = [];
        let comboFireTrail = [];
        let celebrationParticles = [];
        
        // Phase 5: UI effects
        let screenFlash = null;
        let screenShake = { intensity: 0, decay: 0.9 };
        let damageVignette = null;
        
        // Phase 6: Post-processing
        let chromaticAberration = 0;
        
        // Phase 7: Audio-visual sync
        let beatPulse = 0;
        let lastBeatTime = 0;

        // Creature types with their properties
        const creatureTypes = [
            {
                type: 'mole',
                color: 0xA06630, // Lighter brown color for better contrast with dirt
                pointValue: 1,
                minLevel: 1,
                probability: 1.0
            },
            {
                type: 'redGopher',
                color: 0xCC0000,
                pointValue: 2,
                minLevel: 2,
                probability: 0.6
            },
            {
                type: 'blueRabbit',
                color: 0x0066CC,
                pointValue: 3,
                minLevel: 3,
                probability: 0.4
            },
            {
                type: 'goldenMole',
                color: 0xFFD700,
                pointValue: 5,
                minLevel: 4,
                probability: 0.2
            }
        ];

        // Possible hole positions
        const holePositions = [
            { x: -0.8, z: -0.8 },
            { x: 0, z: -0.5 },
            { x: 0.8, z: -0.8 },
            { x: -1, z: 0 },
            { x: 0, z: 0 },
            { x: 1, z: 0 },
            { x: -0.8, z: 0.8 },
            { x: 0, z: 0.5 },
            { x: 0.8, z: 0.8 }
        ];

        // Game settings
        let score = 0;
        let level = 1;
        let levelScore = 0; // Score for current level only
        let moleSpeed = 2000; // Base time in ms for a mole to stay up
        let molesPerLevel = 3;
        let activeMoles = [];
        let activeHoles = [];
        let gameActive = false;
        let gamePaused = false;

        // Level system
        const levelGoals = [10, 20, 30, 50]; // Points needed to complete each level

        // Timer variables
        let gameTimer = 0;
        let levelStartTime = 0;
        let lastTimestamp = 0;

        // Audio elements
        let hitSound;

        // === PHASE 1: COMBO SYSTEM ===
        let combo = 0;
        let maxCombo = 0;
        let comboTimer = null;
        const COMBO_TIMEOUT = 2000; // ms to maintain combo
        let comboDisplay = null;

        // === PHASE 2: BIOME SYSTEM ===
        const biomes = [
            { name: 'Forest', groundColor: 0x228B22, skyColor: 0x87CEEB, ambientColor: 0xffffff, particleColor: 0x90EE90 },
            { name: 'Desert', groundColor: 0xD2B48C, skyColor: 0xFFE4B5, ambientColor: 0xFFF8DC, particleColor: 0xF4A460 },
            { name: 'Arctic', groundColor: 0xB8D4E8, skyColor: 0x87CEEB, ambientColor: 0xCCDDEE, particleColor: 0xADD8E6 },
            { name: 'Volcanic', groundColor: 0x2F1810, skyColor: 0x8B0000, ambientColor: 0xFF4500, particleColor: 0xFF6347 },
            { name: 'Swamp', groundColor: 0x556B2F, skyColor: 0x6B8E23, ambientColor: 0x9ACD32, particleColor: 0x8FBC8F }
        ];
        let currentBiome = 0;
        let biomeGroup = null;
        let environmentParticles = [];

        // === PHASE 2: POWER-UP SYSTEM ===
        const powerUpTypes = [
            { type: 'slowTime', color: 0x00FFFF, duration: 5000, icon: 'â±ï¸' },
            { type: 'doublePoints', color: 0xFFD700, duration: 8000, icon: 'Ã—2' },
            { type: 'multiHit', color: 0xFF00FF, duration: 6000, icon: 'ðŸ’¥' }
        ];
        let activePowerUps = [];
        let powerUpObjects = [];
        let powerUpSpawnTimer = null;

        // === PHASE 2: BOSS SYSTEM ===
        let currentBoss = null;
        let bossHealthBar = null;
        const BOSS_SPAWN_SCORE = 20; // Spawn boss every X points
        let lastBossScore = 0;

        // === PHASE 3: CHAOS EVENTS ===
        const chaosEvents = [
            { name: 'Speed Frenzy', effect: 'speed', multiplier: 0.5, duration: 8000, icon: 'âš¡' },
            { name: 'Giant Moles', effect: 'size', multiplier: 2, duration: 10000, icon: 'ðŸ”' },
            { name: 'Tiny Terrors', effect: 'size', multiplier: 0.5, duration: 8000, icon: 'ðŸ”¬' },
            { name: 'Gravity Flip', effect: 'gravity', multiplier: -1, duration: 6000, icon: 'ðŸ”„' },
            { name: 'Rainbow Mode', effect: 'rainbow', multiplier: 1, duration: 12000, icon: 'ðŸŒˆ' }
        ];
        let activeChaosEvent = null;
        let chaosEventTimer = null;
        const CHAOS_SPAWN_INTERVAL = 45000; // Every 45 seconds

        // === WEAPON SYSTEM ===
        const weapons = [
            { id: 'hammer', name: 'Hammer', damage: 1, speed: 1, effect: 'smash', color: 0x8B4513, unlocked: true },
            { id: 'mallet', name: 'Golden Mallet', damage: 2, speed: 0.8, effect: 'gold', color: 0xFFD700, cost: 100 },
            { id: 'lightning', name: 'Lightning Rod', damage: 1, speed: 1.5, effect: 'chain', color: 0x00FFFF, cost: 200 },
            { id: 'freeze', name: 'Freeze Ray', damage: 1, speed: 1, effect: 'freeze', color: 0x87CEEB, cost: 300 },
            { id: 'gravity', name: 'Gravity Gun', damage: 3, speed: 0.5, effect: 'pull', color: 0x9400D3, cost: 500 }
        ];
        let currentWeapon = weapons[0];
        let weaponMesh = null;
        let isSwinging = false;
        let playerCoins = 0;

        // === EXPANDED CREATURES (20 types) with exit animations ===
        const creatureTypesExpanded = [
            { type: 'mole', color: 0xA06630, pointValue: 1, minLevel: 1, probability: 1.0, behavior: 'normal', health: 1, exitAnim: 'down' },
            { type: 'redGopher', color: 0xCC0000, pointValue: 2, minLevel: 1, probability: 0.7, behavior: 'normal', health: 1, exitAnim: 'down' },
            { type: 'blueRabbit', color: 0x0066CC, pointValue: 3, minLevel: 2, probability: 0.5, behavior: 'fast', health: 1, exitAnim: 'hop' },
            { type: 'goldenMole', color: 0xFFD700, pointValue: 5, minLevel: 2, probability: 0.2, behavior: 'normal', health: 1, exitAnim: 'sparkle' },
            { type: 'ninjaMole', color: 0x1a1a2e, pointValue: 4, minLevel: 3, probability: 0.3, behavior: 'teleport', health: 1, exitAnim: 'poof' },
            { type: 'armoredGopher', color: 0x708090, pointValue: 6, minLevel: 3, probability: 0.25, behavior: 'armored', health: 2, exitAnim: 'down' },
            { type: 'speedyRabbit', color: 0x00FF00, pointValue: 4, minLevel: 3, probability: 0.3, behavior: 'veryfast', health: 1, exitAnim: 'dash' },
            { type: 'ghostMole', color: 0xE8E8E8, pointValue: 5, minLevel: 4, probability: 0.2, behavior: 'phase', health: 1, exitAnim: 'fade' },
            { type: 'bombMole', color: 0xFF4500, pointValue: 3, minLevel: 4, probability: 0.25, behavior: 'bomb', health: 1, exitAnim: 'down' },
            { type: 'healerMole', color: 0x98FB98, pointValue: 4, minLevel: 4, probability: 0.15, behavior: 'healer', health: 1, exitAnim: 'float' },
            { type: 'mimicMole', color: 0xFFD700, pointValue: -3, minLevel: 3, probability: 0.1, behavior: 'mimic', health: 1, exitAnim: 'down' },
            { type: 'kingMole', color: 0x800080, pointValue: 10, minLevel: 5, probability: 0.1, behavior: 'summon', health: 3, exitAnim: 'royal' },
            { type: 'alienMole', color: 0x39FF14, pointValue: 7, minLevel: 5, probability: 0.15, behavior: 'antigrav', health: 1, exitAnim: 'beam' },
            { type: 'candyMole', color: 0xFF69B4, pointValue: 2, minLevel: 1, probability: 0.4, behavior: 'sweet', health: 1, exitAnim: 'bounce' },
            { type: 'shadowMole', color: 0x2F2F2F, pointValue: 8, minLevel: 5, probability: 0.1, behavior: 'dodge', health: 1, exitAnim: 'melt' },
            { type: 'birdMole', color: 0x87CEEB, pointValue: 4, minLevel: 2, probability: 0.3, behavior: 'fly', health: 1, exitAnim: 'flyaway' },
            { type: 'wizardMole', color: 0x9400D3, pointValue: 6, minLevel: 4, probability: 0.15, behavior: 'magic', health: 1, exitAnim: 'teleport' },
            { type: 'robotMole', color: 0xC0C0C0, pointValue: 5, minLevel: 3, probability: 0.2, behavior: 'mechanical', health: 2, exitAnim: 'malfunction' },
            { type: 'clownMole', color: 0xFF0000, pointValue: 3, minLevel: 2, probability: 0.25, behavior: 'silly', health: 1, exitAnim: 'cartwheel' },
            { type: 'iceMole', color: 0x00FFFF, pointValue: 4, minLevel: 3, probability: 0.2, behavior: 'freeze', health: 1, exitAnim: 'shatter' }
        ];

        // === BACKGROUND DECORATIONS ===
        let backgroundDecorations = [];
        let butterflies = [];
        let birds = [];
        let trees = [];

        // === EXPANDED BIOMES (10 total) ===
        const biomesExpanded = [
            { name: 'Forest', groundColor: 0x228B22, skyTop: 0x87CEEB, skyBottom: 0xE0F7FA, ambient: 0xffffff, particle: 0x90EE90, music: 'forest' },
            { name: 'Desert', groundColor: 0xD2B48C, skyTop: 0xFF8C00, skyBottom: 0xFFE4B5, ambient: 0xFFF8DC, particle: 0xF4A460, music: 'desert' },
            { name: 'Arctic', groundColor: 0xB8D4E8, skyTop: 0x87CEEB, skyBottom: 0xD0E8F0, ambient: 0xCCDDEE, particle: 0xADD8E6, music: 'arctic' },
            { name: 'Volcanic', groundColor: 0x2F1810, skyTop: 0x8B0000, skyBottom: 0xFF4500, ambient: 0xFF4500, particle: 0xFF6347, music: 'volcanic' },
            { name: 'Swamp', groundColor: 0x556B2F, skyTop: 0x6B8E23, skyBottom: 0x9ACD32, ambient: 0x9ACD32, particle: 0x8FBC8F, music: 'swamp' },
            { name: 'Underwater', groundColor: 0x006994, skyTop: 0x000080, skyBottom: 0x00CED1, ambient: 0x40E0D0, particle: 0x00FFFF, music: 'underwater' },
            { name: 'Space', groundColor: 0x1a1a2e, skyTop: 0x000011, skyBottom: 0x16213e, ambient: 0x4a4a6a, particle: 0xFFFFFF, music: 'space' },
            { name: 'Candy Land', groundColor: 0xFFB6C1, skyTop: 0xFF69B4, skyBottom: 0xFFFACD, ambient: 0xFFE4E1, particle: 0xFF1493, music: 'candy' },
            { name: 'Haunted', groundColor: 0x2F2F2F, skyTop: 0x1a1a2e, skyBottom: 0x4a4a4a, ambient: 0x6a5acd, particle: 0x9370DB, music: 'haunted' },
            { name: 'Jungle', groundColor: 0x228B22, skyTop: 0x006400, skyBottom: 0x90EE90, ambient: 0x32CD32, particle: 0x00FF00, music: 'jungle' }
        ];

        // === DYNAMIC MUSIC SYSTEM ===
        let audioContext = null;
        let musicLayers = { bass: null, melody: null, drums: null, intensity: null };
        let currentMusicIntensity = 0;
        let musicEnabled = true;

        // === SLOW MOTION SYSTEM ===
        let slowMotion = { active: false, factor: 1, duration: 0 };
        let gameSpeed = 1;

        // === CHALLENGE MODES ===
        const challengeModes = [
            { id: 'endless', name: 'Endless', desc: 'Play until you miss too many' },
            { id: 'timed', name: 'Time Attack', desc: '60 seconds, max score' },
            { id: 'survival', name: 'Survival', desc: 'One life, how far can you go?' },
            { id: 'speedrun', name: 'Speed Run', desc: 'Reach 100 points fastest' },
            { id: 'precision', name: 'Precision', desc: 'Golden moles only, 10 swings' },
            { id: 'bossrush', name: 'Boss Rush', desc: 'Boss after boss!' }
        ];
        let currentChallenge = 'endless';
        let survivalLives = 3;
        let precisionSwings = 10;
        let speedrunStartTime = 0;

        // === UNLOCKS & PROGRESSION ===
        let unlockedWeapons = ['hammer'];
        let unlockedBiomes = [0, 1, 2, 3, 4];
        let creaturesSeen = [];
        let totalCoinsEarned = 0;

        // === PHASE 3: PERSISTENT PROGRESSION ===
        let highScore = 0;
        let totalHits = 0;
        let totalMisses = 0;
        let gamesPlayed = 0;
        let achievements = [];
        const ACHIEVEMENTS = [
            { id: 'first_hit', name: 'First Blood', desc: 'Hit your first creature', condition: () => totalHits >= 1 },
            { id: 'combo_5', name: 'Combo Master', desc: 'Get a 5x combo', condition: () => maxCombo >= 5 },
            { id: 'combo_10', name: 'Combo Legend', desc: 'Get a 10x combo', condition: () => maxCombo >= 10 },
            { id: 'combo_20', name: 'Combo God', desc: 'Get a 20x combo', condition: () => maxCombo >= 20 },
            { id: 'score_100', name: 'Century', desc: 'Score 100 points', condition: () => score >= 100 },
            { id: 'score_500', name: 'High Roller', desc: 'Score 500 points', condition: () => score >= 500 },
            { id: 'boss_slayer', name: 'Boss Slayer', desc: 'Defeat a boss', condition: () => localStorage.getItem('bossesDefeated') >= 1 },
            { id: 'boss_master', name: 'Boss Master', desc: 'Defeat 10 bosses', condition: () => localStorage.getItem('bossesDefeated') >= 10 },
            { id: 'high_score_50', name: 'Rising Star', desc: 'Get a high score of 50+', condition: () => highScore >= 50 },
            { id: 'collector_5', name: 'Collector', desc: 'See 5 creature types', condition: () => creaturesSeen.length >= 5 },
            { id: 'collector_10', name: 'Zoologist', desc: 'See 10 creature types', condition: () => creaturesSeen.length >= 10 },
            { id: 'collector_15', name: 'Master Zoologist', desc: 'See all 15 creatures', condition: () => creaturesSeen.length >= 15 },
            { id: 'rich', name: 'Getting Rich', desc: 'Earn 500 coins total', condition: () => playerCoins >= 500 },
            { id: 'weapon_collector', name: 'Arsenal', desc: 'Unlock 3 weapons', condition: () => unlockedWeapons.length >= 3 },
            { id: 'games_10', name: 'Dedicated', desc: 'Play 10 games', condition: () => gamesPlayed >= 10 },
            { id: 'accuracy_90', name: 'Sharpshooter', desc: 'Achieve 90% accuracy', condition: () => getAccuracy() >= 90 }
        ];

        // === PHASE 3: SETTINGS ===
        let settings = {
            musicVolume: 0.5,
            sfxVolume: 0.7,
            particleQuality: 'high', // low, medium, high
            selectedBiome: 'random' // random or biome index
        };
        let settingsMenu = null;

        // === PHASE 4: OBJECT POOLING ===
        const molePool = [];
        const particlePool = [];
        const POOL_SIZE = 20;

        // === PHASE 4: GAME MODES ===
        let gameMode = 'endless'; // endless, timed, practice
        let timedModeSeconds = 60;
        let practiceMode = false;

        // Initialize the game
        function init() {
            gameContainer = document.getElementById('container');
            scoreDisplay = document.getElementById('info');

            // Create timer display
            timerDisplay = document.createElement('div');
            timerDisplay.id = 'timer';
            timerDisplay.style.position = 'absolute';
            timerDisplay.style.top = '40px';
            timerDisplay.style.width = '100%';
            timerDisplay.style.textAlign = 'center';
            timerDisplay.style.color = 'white';
            timerDisplay.style.fontFamily = 'Arial, sans-serif';
            timerDisplay.style.fontSize = '18px';
            timerDisplay.style.textShadow = '0 0 5px black';
            timerDisplay.style.pointerEvents = 'none';
            document.body.appendChild(timerDisplay);

            // Create combo display
            comboDisplay = document.createElement('div');
            comboDisplay.id = 'combo';
            comboDisplay.style.position = 'absolute';
            comboDisplay.style.top = '70px';
            comboDisplay.style.width = '100%';
            comboDisplay.style.textAlign = 'center';
            comboDisplay.style.color = '#FFD700';
            comboDisplay.style.fontFamily = 'Arial, sans-serif';
            comboDisplay.style.fontSize = '24px';
            comboDisplay.style.fontWeight = 'bold';
            comboDisplay.style.textShadow = '0 0 10px #FF6600';
            comboDisplay.style.pointerEvents = 'none';
            comboDisplay.style.opacity = '0';
            comboDisplay.style.transition = 'opacity 0.3s, transform 0.2s';
            document.body.appendChild(comboDisplay);

            // Create scene
            scene = new THREE.Scene();

            // Create camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            gameContainer.appendChild(renderer.domElement);

            // Check XR support
            checkXRSupport();

            // Create raycaster for controller interactions
            raycaster = new THREE.Raycaster();
            tempMatrix = new THREE.Matrix4();

            // Create object groups
            floorGroup = new THREE.Group();
            moleGroup = new THREE.Group();
            particlesGroup = new THREE.Group();
            scene.add(floorGroup);
            scene.add(moleGroup);
            scene.add(particlesGroup);

            // Create hit sound
            createHitSound();

            // Create settings button
            createSettingsButton();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        // === VISUAL ENHANCEMENTS - ALL 7 PHASES ===
        function initVisualEnhancements() {
            initPhase1Lighting();
            initPhase2Ground();
            initPhase4Particles();
            initPhase5UI();
            initPhase6PostProcessing();
        }

        // === PHASE 1: LIGHTING & ATMOSPHERE ===
        function initPhase1Lighting() {
            // Dynamic sun light
            sunLight = new THREE.DirectionalLight(0xffffee, 1.5);
            sunLight.position.set(5, 10, 5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            scene.add(sunLight);

            // Hemisphere light for natural ambient
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3d5c3d, 0.6);
            scene.add(hemiLight);

            // Dynamic sky with gradient shader
            const skyGeo = new THREE.SphereGeometry(18, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },
                    midColor: { value: new THREE.Color(0x87CEEB) },
                    bottomColor: { value: new THREE.Color(0xffeedd) },
                    sunPosition: { value: new THREE.Vector3(0.5, 0.5, 0.5) },
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 midColor;
                    uniform vec3 bottomColor;
                    uniform vec3 sunPosition;
                    uniform float time;
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    void main() {
                        float h = normalize(vWorldPosition).y;
                        vec3 color;
                        if (h > 0.0) {
                            color = mix(midColor, topColor, h);
                        } else {
                            color = mix(midColor, bottomColor, -h);
                        }
                        // Sun glow
                        vec3 sunDir = normalize(sunPosition);
                        float sunDot = max(dot(normalize(vWorldPosition), sunDir), 0.0);
                        color += vec3(1.0, 0.9, 0.7) * pow(sunDot, 32.0) * 0.5;
                        // Stars at night (when sun is low)
                        float night = 1.0 - smoothstep(-0.1, 0.3, sunPosition.y);
                        float stars = step(0.998, fract(sin(dot(vUv * 500.0, vec2(12.9898, 78.233))) * 43758.5453));
                        color += vec3(stars) * night * h;
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            skyMesh = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skyMesh);

            // Volumetric fog
            scene.fog = new THREE.FogExp2(0xccddff, 0.015);

            // God rays (light shafts)
            for (let i = 0; i < 5; i++) {
                const rayGeo = new THREE.CylinderGeometry(0.02, 0.15, 8, 8, 1, true);
                const rayMat = new THREE.MeshBasicMaterial({
                    color: 0xffffcc,
                    transparent: true,
                    opacity: 0.03,
                    side: THREE.DoubleSide
                });
                const ray = new THREE.Mesh(rayGeo, rayMat);
                ray.position.set((Math.random() - 0.5) * 6, 4, (Math.random() - 0.5) * 6);
                ray.rotation.x = Math.PI * 0.1;
                ray.rotation.z = (Math.random() - 0.5) * 0.3;
                ray.userData = { phase: Math.random() * Math.PI * 2 };
                scene.add(ray);
                godRays.push(ray);
            }

            // Clouds
            for (let i = 0; i < 8; i++) {
                const cloudGroup = new THREE.Group();
                const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
                for (let j = 0; j < 5; j++) {
                    const puff = new THREE.Mesh(new THREE.SphereGeometry(0.3 + Math.random() * 0.4, 8, 8), cloudMat);
                    puff.position.set((Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.8);
                    puff.scale.y = 0.6;
                    cloudGroup.add(puff);
                }
                cloudGroup.position.set((Math.random() - 0.5) * 12, 6 + Math.random() * 2, (Math.random() - 0.5) * 12);
                cloudGroup.userData = { speed: 0.01 + Math.random() * 0.02, baseX: cloudGroup.position.x };
                scene.add(cloudGroup);
                clouds.push(cloudGroup);
            }
        }

        // === PHASE 2: GROUND & TERRAIN ===
        function initPhase2Ground() {
            // Procedural grass
            const grassCount = settings.particleQuality === 'high' ? 300 : settings.particleQuality === 'medium' ? 150 : 50;
            const grassGeo = new THREE.ConeGeometry(0.015, 0.12, 4);
            const grassMat = new THREE.MeshLambertMaterial({ color: 0x3d8c40 });
            
            for (let i = 0; i < grassCount; i++) {
                const grass = new THREE.Mesh(grassGeo, grassMat.clone());
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.8 + Math.random() * 2;
                grass.position.set(Math.cos(angle) * radius, 0.06, Math.sin(angle) * radius);
                grass.rotation.x = (Math.random() - 0.5) * 0.3;
                grass.rotation.z = (Math.random() - 0.5) * 0.3;
                grass.userData = { phase: Math.random() * Math.PI * 2, baseRotX: grass.rotation.x };
                grass.material.color.setHSL(0.3 + Math.random() * 0.05, 0.6, 0.3 + Math.random() * 0.2);
                scene.add(grass);
                grassBlades.push(grass);
            }

            // Scattered rocks
            for (let i = 0; i < 12; i++) {
                const rockGeo = new THREE.DodecahedronGeometry(0.05 + Math.random() * 0.08, 0);
                const rockMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
                rockMat.color.setHSL(0, 0, 0.3 + Math.random() * 0.3);
                const rock = new THREE.Mesh(rockGeo, rockMat);
                const angle = Math.random() * Math.PI * 2;
                const radius = 1 + Math.random() * 1.8;
                rock.position.set(Math.cos(angle) * radius, 0.03, Math.sin(angle) * radius);
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.y = 0.5 + Math.random() * 0.5;
                scene.add(rock);
                rocks.push(rock);
            }

            // Flowers
            const flowerColors = [0xff6b6b, 0xffd93d, 0x6bcb77, 0x4d96ff, 0xff6bff];
            for (let i = 0; i < 20; i++) {
                const flowerGroup = new THREE.Group();
                const stemGeo = new THREE.CylinderGeometry(0.005, 0.008, 0.1, 6);
                const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeo, stemMat);
                stem.position.y = 0.05;
                flowerGroup.add(stem);
                
                const petalColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                const petalMat = new THREE.MeshLambertMaterial({ color: petalColor });
                for (let p = 0; p < 5; p++) {
                    const petal = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), petalMat);
                    const pAngle = (p / 5) * Math.PI * 2;
                    petal.position.set(Math.cos(pAngle) * 0.025, 0.1, Math.sin(pAngle) * 0.025);
                    petal.scale.set(1, 0.5, 1);
                    flowerGroup.add(petal);
                }
                const center = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 6), new THREE.MeshLambertMaterial({ color: 0xffff00 }));
                center.position.y = 0.1;
                flowerGroup.add(center);
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.2 + Math.random() * 1.5;
                flowerGroup.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                flowerGroup.userData = { phase: Math.random() * Math.PI * 2 };
                scene.add(flowerGroup);
                flowers.push(flowerGroup);
            }

            // Fireflies
            for (let i = 0; i < 20; i++) {
                const firefly = new THREE.Mesh(
                    new THREE.SphereGeometry(0.015, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff66, transparent: true })
                );
                firefly.position.set((Math.random() - 0.5) * 5, 0.3 + Math.random() * 1.5, (Math.random() - 0.5) * 5);
                firefly.userData = { 
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.3 + Math.random() * 0.7,
                    basePos: firefly.position.clone()
                };
                scene.add(firefly);
                fireflies.push(firefly);
            }
        }

        // === PHASE 4: PARTICLE SYSTEMS ===
        function initPhase4Particles() {
            // Pre-create hit particle pool
            for (let i = 0; i < 50; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true })
                );
                particle.visible = false;
                particle.userData = { active: false, velocity: new THREE.Vector3(), life: 0 };
                scene.add(particle);
                hitParticlePool.push(particle);
            }
        }

        // === PHASE 5: UI EFFECTS ===
        function initPhase5UI() {
            // Screen flash overlay
            screenFlash = document.createElement('div');
            screenFlash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity 0.1s;z-index:1000;';
            document.body.appendChild(screenFlash);

            // Damage vignette
            damageVignette = document.createElement('div');
            damageVignette.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;z-index:999;background:radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.3) 100%);';
            document.body.appendChild(damageVignette);
        }

        // === PHASE 6: POST-PROCESSING ===
        function initPhase6PostProcessing() {
            if (renderer.xr.isPresenting) return;
            
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.6, 0.4, 0.85
            );
            composer.addPass(bloomPass);
        }

        // === UPDATE FUNCTIONS ===
        function updateVisualEnhancements() {
            const time = Date.now() * 0.001;
            const delta = 0.016;
            
            updatePhase1Atmosphere(time);
            updatePhase2Ground(time);
            updatePhase4Particles(delta);
            updatePhase5UI(delta);
            updatePhase6Effects(time);
            updatePhase7AudioSync(time);
        }

        function updatePhase1Atmosphere(time) {
            // Animate sky
            if (skyMesh && skyMesh.material.uniforms) {
                skyMesh.material.uniforms.time.value = time;
                const sunY = 0.3 + Math.sin(time * 0.05) * 0.2;
                skyMesh.material.uniforms.sunPosition.value.set(Math.cos(time * 0.02), sunY, Math.sin(time * 0.02));
                
                // Update sun light position
                if (sunLight) {
                    sunLight.position.set(Math.cos(time * 0.02) * 10, sunY * 15 + 5, Math.sin(time * 0.02) * 10);
                    sunLight.intensity = 1 + sunY;
                }
                
                // Update fog based on biome
                const biome = biomesExpanded[currentBiome];
                if (scene.fog && biome) {
                    scene.fog.color.lerp(new THREE.Color(biome.skyTop || 0x87CEEB), 0.02);
                }
            }

            // Animate god rays
            godRays.forEach(ray => {
                ray.material.opacity = 0.02 + Math.sin(time + ray.userData.phase) * 0.015;
            });

            // Animate clouds
            clouds.forEach(cloud => {
                cloud.position.x = cloud.userData.baseX + Math.sin(time * cloud.userData.speed) * 2;
            });
        }

        function updatePhase2Ground(time) {
            // Sway grass in wind
            grassBlades.forEach(grass => {
                grass.rotation.x = grass.userData.baseRotX + Math.sin(time * 2 + grass.userData.phase) * 0.15;
            });

            // Bob flowers
            flowers.forEach(flower => {
                flower.rotation.z = Math.sin(time * 1.5 + flower.userData.phase) * 0.1;
            });

            // Animate fireflies
            fireflies.forEach(f => {
                const t = time * f.userData.speed;
                f.position.x = f.userData.basePos.x + Math.sin(t + f.userData.phase) * 0.3;
                f.position.y = f.userData.basePos.y + Math.sin(t * 1.3 + f.userData.phase) * 0.2;
                f.position.z = f.userData.basePos.z + Math.cos(t * 0.7 + f.userData.phase) * 0.3;
                f.material.opacity = 0.3 + Math.sin(t * 3 + f.userData.phase) * 0.7;
            });
        }

        function updatePhase4Particles(delta) {
            // Update hit particles
            hitParticlePool.forEach(p => {
                if (p.userData.active) {
                    p.position.add(p.userData.velocity);
                    p.userData.velocity.y -= 0.003; // gravity
                    p.userData.life -= delta;
                    p.material.opacity = Math.max(0, p.userData.life);
                    p.scale.multiplyScalar(0.98);
                    if (p.userData.life <= 0) {
                        p.userData.active = false;
                        p.visible = false;
                    }
                }
            });

            // Update combo fire trail
            comboFireTrail.forEach((flame, i) => {
                flame.userData.life -= delta;
                flame.material.opacity = flame.userData.life;
                flame.position.y += 0.02;
                flame.scale.multiplyScalar(0.95);
                if (flame.userData.life <= 0) {
                    scene.remove(flame);
                    comboFireTrail.splice(i, 1);
                }
            });

            // Update celebration particles
            celebrationParticles.forEach((p, i) => {
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.002;
                p.rotation.x += 0.1;
                p.rotation.y += 0.1;
                p.userData.life -= delta;
                p.material.opacity = p.userData.life;
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    celebrationParticles.splice(i, 1);
                }
            });
        }

        function updatePhase5UI(delta) {
            // Decay screen shake
            if (screenShake.intensity > 0.001) {
                camera.position.x += (Math.random() - 0.5) * screenShake.intensity;
                camera.position.y += (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= screenShake.decay;
            }
        }

        function updatePhase6Effects(time) {
            // Chromatic aberration during chaos events
            if (activeChaosEvent && bloomPass) {
                bloomPass.strength = 0.8 + Math.sin(time * 5) * 0.2;
            } else if (bloomPass) {
                bloomPass.strength = 0.6;
            }
        }

        function updatePhase7AudioSync(time) {
            // Beat pulse effect
            if (beatPulse > 0) {
                beatPulse *= 0.9;
                if (sunLight) sunLight.intensity = 1.5 + beatPulse * 0.5;
            }
        }

        // === VISUAL EFFECT TRIGGERS ===
        function triggerHitEffect(position, color, intensity = 1) {
            // Spawn hit particles
            const particleCount = Math.floor(8 * intensity);
            for (let i = 0; i < particleCount; i++) {
                const p = hitParticlePool.find(p => !p.userData.active);
                if (p) {
                    p.userData.active = true;
                    p.visible = true;
                    p.position.copy(position);
                    p.userData.velocity.set(
                        (Math.random() - 0.5) * 0.08,
                        Math.random() * 0.1 + 0.05,
                        (Math.random() - 0.5) * 0.08
                    );
                    p.userData.life = 0.8 + Math.random() * 0.4;
                    p.material.color.setHex(color);
                    p.scale.set(1, 1, 1);
                }
            }

            // Screen flash
            if (screenFlash) {
                screenFlash.style.backgroundColor = '#' + color.toString(16).padStart(6, '0');
                screenFlash.style.opacity = 0.2 * intensity;
                setTimeout(() => screenFlash.style.opacity = 0, 100);
            }

            // Screen shake for big hits
            if (intensity > 1.5) {
                screenShake.intensity = 0.02 * intensity;
            }

            // Beat pulse
            beatPulse = intensity * 0.5;
        }

        function triggerComboFire(position) {
            if (combo < 3) return;
            const flame = new THREE.Mesh(
                new THREE.ConeGeometry(0.03, 0.1, 6),
                new THREE.MeshBasicMaterial({ color: combo >= 10 ? 0xff00ff : combo >= 5 ? 0xff6600 : 0xffdd00, transparent: true })
            );
            flame.position.copy(position);
            flame.userData = { life: 0.5 };
            scene.add(flame);
            comboFireTrail.push(flame);
        }

        function triggerCelebration(position) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            for (let i = 0; i < 30; i++) {
                const confetti = new THREE.Mesh(
                    new THREE.BoxGeometry(0.03, 0.03, 0.005),
                    new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], transparent: true })
                );
                confetti.position.copy(position);
                confetti.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.1, Math.random() * 0.15 + 0.1, (Math.random() - 0.5) * 0.1),
                    life: 2 + Math.random()
                };
                scene.add(confetti);
                celebrationParticles.push(confetti);
            }
        }

        function triggerDamageVignette() {
            if (damageVignette) {
                damageVignette.style.opacity = 0.5;
                setTimeout(() => damageVignette.style.opacity = 0, 300);
            }
        }

        function updateBiomeVisuals() {
            const biome = biomesExpanded[currentBiome];
            if (!biome) return;
            
            // Update sky colors
            if (skyMesh && skyMesh.material.uniforms) {
                const skyColor = new THREE.Color(biome.skyTop || biome.skyColor || 0x87CEEB);
                skyMesh.material.uniforms.midColor.value.lerp(skyColor, 0.1);
            }

            // Update grass colors per biome
            const grassColors = {
                0: 0x3d8c40, // Forest - green
                1: 0xc2b280, // Desert - tan
                2: 0xb8c8d8, // Arctic - light blue-gray
                3: 0x4a3728, // Volcanic - dark brown
                4: 0x5d7a3d, // Swamp - murky green
                5: 0x006994, // Underwater - blue
                6: 0x1a1a2e, // Space - dark
                7: 0xFFB6C1, // Candy - pink
                8: 0x2F2F2F, // Haunted - dark
                9: 0x228B22  // Jungle - green
            };
            grassBlades.forEach(g => {
                g.material.color.lerp(new THREE.Color(grassColors[currentBiome] || 0x3d8c40), 0.05);
            });

            // Update fog
            if (scene.fog && biome) {
                scene.fog.color.set(biome.skyTop || 0x87CEEB);
                scene.fog.density = (currentBiome === 4 || currentBiome === 8) ? 0.04 : 0.015; // Thicker fog in swamp/haunted
            }
        }

        // === WEAPON SYSTEM ===
        function createWeapon() {
            weaponMesh = new THREE.Group();
            
            // Handle
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.025, 0.4, 8),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            handle.position.y = -0.2;
            weaponMesh.add(handle);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.1, 0.1),
                new THREE.MeshLambertMaterial({ color: currentWeapon.color })
            );
            head.position.y = 0.05;
            weaponMesh.add(head);
            
            weaponMesh.position.set(2, 0.5, 0);
            weaponMesh.visible = false;
            scene.add(weaponMesh);
        }

        function swingWeapon(targetPos) {
            if (isSwinging || !weaponMesh) return;
            isSwinging = true;
            
            const startRot = weaponMesh.rotation.z;
            const startTime = Date.now();
            const duration = 150 / currentWeapon.speed;
            
            function animateSwing() {
                const progress = Math.min((Date.now() - startTime) / duration, 1);
                const swing = Math.sin(progress * Math.PI) * 1.5;
                weaponMesh.rotation.z = startRot - swing;
                
                if (progress < 1) {
                    requestAnimationFrame(animateSwing);
                } else {
                    weaponMesh.rotation.z = startRot;
                    isSwinging = false;
                }
            }
            animateSwing();
            
            // Weapon effect
            if (currentWeapon.effect === 'chain' && combo >= 2) {
                chainLightning(targetPos);
            }
        }

        function chainLightning(pos) {
            // Find nearby creatures and damage them
            activeMoles.forEach(mole => {
                if (mole.userData.active) {
                    const dist = mole.position.distanceTo(pos);
                    if (dist < 0.8 && dist > 0.1) {
                        setTimeout(() => {
                            createLightningBolt(pos, mole.position);
                            hitMole(mole);
                        }, 100);
                    }
                }
            });
        }

        function createLightningBolt(from, to) {
            const points = [from.clone()];
            const segments = 5;
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                const p = from.clone().lerp(to, t);
                p.x += (Math.random() - 0.5) * 0.1;
                p.y += (Math.random() - 0.5) * 0.1;
                points.push(p);
            }
            points.push(to.clone());
            
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: 0x00FFFF, linewidth: 3 });
            const bolt = new THREE.Line(geo, mat);
            scene.add(bolt);
            
            setTimeout(() => {
                scene.remove(bolt);
                geo.dispose();
                mat.dispose();
            }, 150);
        }

        function onMouseMove(event) {
            if (!weaponMesh) return;
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = -(event.clientY / window.innerHeight) * 2 + 1;
            weaponMesh.position.x = x * 2;
            weaponMesh.position.y = y + 1;
            // Keep weapon hidden - visual was distracting
        }

        // === DYNAMIC MUSIC SYSTEM ===
        function initMusicSystem() {
            if (!audioContext) return;
            // Music will be generated procedurally based on game state
        }

        function updateMusic() {
            if (!musicEnabled || !audioContext) return;
            
            // Intensity based on combo and game state
            const targetIntensity = Math.min(combo / 10, 1);
            currentMusicIntensity += (targetIntensity - currentMusicIntensity) * 0.1;
            
            // Play beat on combo milestones
            if (combo > 0 && combo % 5 === 0 && Date.now() - lastBeatTime > 500) {
                playBeat();
                lastBeatTime = Date.now();
            }
        }

        function playBeat() {
            if (!audioContext || audioContext.state !== 'running') return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(150 + combo * 20, audioContext.currentTime);
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.2 * settings.sfxVolume, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
            
            beatPulse = 1;
        }

        // === SLOW MOTION SYSTEM ===
        function triggerSlowMotion(duration = 500, factor = 0.3) {
            slowMotion.active = true;
            slowMotion.factor = factor;
            slowMotion.duration = duration;
            
            // Visual effect
            if (bloomPass) bloomPass.strength = 1.2;
            
            setTimeout(() => {
                slowMotion.active = false;
                slowMotion.factor = 1;
                if (bloomPass) bloomPass.strength = 0.6;
            }, duration);
        }

        // === CREATURE BEHAVIORS ===
        function updateCreatureBehaviors() {
            const time = Date.now();
            
            activeMoles.forEach(mole => {
                if (!mole.userData.active) return;
                const behavior = mole.userData.creatureType?.behavior;
                
                switch (behavior) {
                    case 'teleport':
                        // Ninja mole teleports occasionally
                        if (Math.random() < 0.005) {
                            createSmokeEffect(mole.position);
                            const newPos = holePositions[Math.floor(Math.random() * holePositions.length)];
                            mole.position.x = newPos.x;
                            mole.position.z = newPos.z;
                            createSmokeEffect(mole.position);
                        }
                        break;
                    case 'phase':
                        // Ghost mole phases in/out
                        mole.traverse(child => {
                            if (child.material) {
                                child.material.opacity = 0.3 + Math.sin(time * 0.005) * 0.7;
                                child.material.transparent = true;
                            }
                        });
                        break;
                    case 'dodge':
                        // Shadow mole dodges when cursor is near
                        if (mole.userData.dodgeCooldown && time < mole.userData.dodgeCooldown) break;
                        break;
                    case 'bomb':
                        // Bomb mole countdown
                        if (!mole.userData.bombTimer) {
                            mole.userData.bombTimer = time + 3000;
                        }
                        const remaining = mole.userData.bombTimer - time;
                        if (remaining < 1000) {
                            mole.traverse(child => {
                                if (child.material && !child.userData?.isGlow) {
                                    child.material.emissive = new THREE.Color(0xFF0000);
                                    child.material.emissiveIntensity = Math.sin(time * 0.02) * 0.5 + 0.5;
                                }
                            });
                        }
                        if (remaining <= 0) {
                            explodeBomb(mole);
                        }
                        break;
                    case 'healer':
                        // Healer pulses green
                        if (Math.random() < 0.01) healNearbyCreatures(mole.position);
                        break;
                    case 'fly':
                        // Bird mole hovers and bobs
                        mole.position.y = 0.1 + Math.sin(time * 0.003) * 0.1;
                        mole.rotation.z = Math.sin(time * 0.005) * 0.1;
                        break;
                    case 'magic':
                        // Wizard sparkles
                        if (Math.random() < 0.02) createSparkle(mole.position.clone().add(new THREE.Vector3(0, 0.15, 0)));
                        mole.rotation.y += 0.02;
                        break;
                    case 'mechanical':
                        // Robot twitches
                        if (Math.random() < 0.01) {
                            mole.position.x += (Math.random() - 0.5) * 0.02;
                            createSparkEffect(mole.position);
                        }
                        break;
                    case 'silly':
                        // Clown wobbles
                        mole.rotation.z = Math.sin(time * 0.01) * 0.3;
                        mole.rotation.x = Math.sin(time * 0.008) * 0.2;
                        break;
                    case 'freeze':
                        // Ice mole shivers
                        mole.position.x += (Math.random() - 0.5) * 0.005;
                        break;
                    case 'sweet':
                        // Candy mole bounces in place
                        mole.position.y = Math.abs(Math.sin(time * 0.005)) * 0.05;
                        break;
                    case 'antigrav':
                        // Alien floats eerily
                        mole.position.y = 0.05 + Math.sin(time * 0.002) * 0.08;
                        mole.rotation.y += 0.01;
                        break;
                }
            });
        }

        function createSmokeEffect(pos) {
            for (let i = 0; i < 8; i++) {
                const smoke = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.6 })
                );
                smoke.position.copy(pos);
                smoke.position.y += 0.1;
                scene.add(smoke);
                
                const vel = new THREE.Vector3((Math.random() - 0.5) * 0.05, 0.03, (Math.random() - 0.5) * 0.05);
                const animate = () => {
                    smoke.position.add(vel);
                    smoke.material.opacity -= 0.02;
                    smoke.scale.multiplyScalar(1.05);
                    if (smoke.material.opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(smoke);
                    }
                };
                animate();
            }
        }

        function createSpeedLines(pos) {
            for (let i = 0; i < 3; i++) {
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.01, 0.01),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.7 })
                );
                line.position.copy(pos);
                line.position.x -= 0.2;
                line.position.y += (i - 1) * 0.05;
                scene.add(line);
                setTimeout(() => scene.remove(line), 100);
            }
        }

        function createSparkle(pos) {
            const sparkle = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.03),
                new THREE.MeshBasicMaterial({ color: 0xFFD700 })
            );
            sparkle.position.copy(pos);
            sparkle.position.y += Math.random() * 0.2;
            scene.add(sparkle);
            const animate = () => {
                sparkle.rotation.y += 0.2;
                sparkle.position.y += 0.02;
                sparkle.scale.multiplyScalar(0.95);
                if (sparkle.scale.x > 0.1) requestAnimationFrame(animate);
                else scene.remove(sparkle);
            };
            animate();
        }

        function createBeamEffect(pos) {
            const beam = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.2, 2, 8, 1, true),
                new THREE.MeshBasicMaterial({ color: 0x39FF14, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
            );
            beam.position.copy(pos);
            beam.position.y += 1;
            scene.add(beam);
            setTimeout(() => scene.remove(beam), 300);
        }

        function createMagicSparkles(pos) {
            const colors = [0x9400D3, 0xFF00FF, 0x4B0082];
            for (let i = 0; i < 10; i++) {
                const sparkle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02),
                    new THREE.MeshBasicMaterial({ color: colors[i % 3] })
                );
                sparkle.position.copy(pos);
                const angle = (i / 10) * Math.PI * 2;
                const vel = new THREE.Vector3(Math.cos(angle) * 0.05, 0.1, Math.sin(angle) * 0.05);
                scene.add(sparkle);
                const animate = () => {
                    sparkle.position.add(vel);
                    vel.y -= 0.005;
                    sparkle.scale.multiplyScalar(0.95);
                    if (sparkle.scale.x > 0.1) requestAnimationFrame(animate);
                    else scene.remove(sparkle);
                };
                animate();
            }
        }

        function createSparkEffect(pos) {
            const spark = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, 0.02, 0.02),
                new THREE.MeshBasicMaterial({ color: 0xFFFF00 })
            );
            spark.position.copy(pos);
            spark.position.y += 0.1;
            scene.add(spark);
            setTimeout(() => scene.remove(spark), 50);
        }

        function createIceShards(pos) {
            for (let i = 0; i < 8; i++) {
                const shard = new THREE.Mesh(
                    new THREE.ConeGeometry(0.02, 0.08, 4),
                    new THREE.MeshBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.8 })
                );
                shard.position.copy(pos);
                const angle = (i / 8) * Math.PI * 2;
                const vel = new THREE.Vector3(Math.cos(angle) * 0.08, 0.1, Math.sin(angle) * 0.08);
                shard.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(shard);
                const animate = () => {
                    shard.position.add(vel);
                    vel.y -= 0.008;
                    shard.rotation.x += 0.1;
                    if (shard.position.y > 0) requestAnimationFrame(animate);
                    else scene.remove(shard);
                };
                animate();
            }
        }

        // === BACKGROUND DECORATIONS ===
        function createBackgroundDecorations() {
            // Trees around the play area
            for (let i = 0; i < 6; i++) {
                const tree = createTree();
                const angle = (i / 6) * Math.PI * 2;
                tree.position.set(Math.cos(angle) * 3.5, 0, Math.sin(angle) * 3.5);
                tree.scale.setScalar(0.8 + Math.random() * 0.4);
                scene.add(tree);
                trees.push(tree);
            }

            // Butterflies - keep them in the background/edges only
            for (let i = 0; i < 4; i++) {
                const butterfly = createButterfly();
                const angle = (i / 4) * Math.PI * 2;
                butterfly.position.set(
                    Math.cos(angle) * 3 + (Math.random() - 0.5),
                    1.5 + Math.random() * 1.5,
                    Math.sin(angle) * 3 + (Math.random() - 0.5)
                );
                butterfly.userData = { 
                    phase: Math.random() * Math.PI * 2, 
                    basePos: butterfly.position.clone(),
                    speedX: (Math.random() - 0.5) * 0.3,
                    speedY: (Math.random() - 0.5) * 0.2,
                    speedZ: (Math.random() - 0.5) * 0.3
                };
                scene.add(butterfly);
                butterflies.push(butterfly);
            }

            // Flying birds in far background
            for (let i = 0; i < 4; i++) {
                const bird = createBird();
                bird.position.set(-8 + Math.random() * 2, 4 + Math.random() * 3, -8 - Math.random() * 4);
                bird.userData = { speed: 0.015 + Math.random() * 0.01, phase: Math.random() * Math.PI * 2 };
                scene.add(bird);
                birds.push(bird);
            }

            // 2D Background elements - mountains, hills, sun, clouds
            create2DBackground();
        }

        function create2DBackground() {
            // Distant mountains (2D planes)
            const mountainColors = [0x4a6741, 0x5a7751, 0x3a5731];
            for (let i = 0; i < 5; i++) {
                const mountainGeo = new THREE.PlaneGeometry(4, 2);
                const mountainMat = new THREE.MeshBasicMaterial({ color: mountainColors[i % 3], side: THREE.DoubleSide });
                const mountain = new THREE.Mesh(mountainGeo, mountainMat);
                mountain.position.set(-6 + i * 3, 1, -10);
                mountain.scale.y = 0.8 + Math.random() * 0.6;
                scene.add(mountain);
                backgroundDecorations.push(mountain);
            }

            // Rolling hills (closer, greener)
            for (let i = 0; i < 8; i++) {
                const hillGeo = new THREE.CircleGeometry(1.5, 16, 0, Math.PI);
                const hillMat = new THREE.MeshBasicMaterial({ color: 0x4a8f4a, side: THREE.DoubleSide });
                const hill = new THREE.Mesh(hillGeo, hillMat);
                hill.position.set(-8 + i * 2.5, 0, -6 - Math.random());
                hill.rotation.x = -Math.PI / 2 + 0.3;
                hill.scale.set(1 + Math.random() * 0.5, 0.5 + Math.random() * 0.3, 1);
                scene.add(hill);
                backgroundDecorations.push(hill);
            }

            // Sun
            const sunGeo = new THREE.CircleGeometry(0.8, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFDD44 });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(5, 6, -12);
            scene.add(sun);
            backgroundDecorations.push(sun);

            // Sun rays
            for (let i = 0; i < 8; i++) {
                const rayGeo = new THREE.PlaneGeometry(0.1, 1.5);
                const rayMat = new THREE.MeshBasicMaterial({ color: 0xFFEE88, transparent: true, opacity: 0.5 });
                const ray = new THREE.Mesh(rayGeo, rayMat);
                ray.position.set(5, 6, -12.1);
                ray.rotation.z = (i / 8) * Math.PI * 2;
                ray.position.x += Math.cos(ray.rotation.z) * 1.2;
                ray.position.y += Math.sin(ray.rotation.z) * 1.2;
                scene.add(ray);
                backgroundDecorations.push(ray);
            }

            // Background bushes around play area
            for (let i = 0; i < 12; i++) {
                const bushGeo = new THREE.CircleGeometry(0.3 + Math.random() * 0.2, 8);
                const bushMat = new THREE.MeshBasicMaterial({ color: [0x2d5a2d, 0x3d6a3d, 0x4d7a4d][i % 3] });
                const bush = new THREE.Mesh(bushGeo, bushMat);
                const angle = (i / 12) * Math.PI * 2;
                bush.position.set(Math.cos(angle) * 2.8, 0.15, Math.sin(angle) * 2.8);
                bush.rotation.x = -Math.PI / 3;
                scene.add(bush);
                backgroundDecorations.push(bush);
            }

            // Fence posts around the area
            for (let i = 0; i < 16; i++) {
                const postGeo = new THREE.BoxGeometry(0.05, 0.4, 0.05);
                const postMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const post = new THREE.Mesh(postGeo, postMat);
                const angle = (i / 16) * Math.PI * 2;
                post.position.set(Math.cos(angle) * 2.5, 0.2, Math.sin(angle) * 2.5);
                scene.add(post);
                backgroundDecorations.push(post);
            }

            // Distant windmill
            const windmillBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.25, 1.5, 8),
                new THREE.MeshBasicMaterial({ color: 0xDDCCBB })
            );
            windmillBase.position.set(-5, 0.75, -7);
            scene.add(windmillBase);
            backgroundDecorations.push(windmillBase);

            // Windmill blades
            const bladesGroup = new THREE.Group();
            for (let i = 0; i < 4; i++) {
                const blade = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.15, 0.8),
                    new THREE.MeshBasicMaterial({ color: 0xEEEEEE, side: THREE.DoubleSide })
                );
                blade.rotation.z = (i / 4) * Math.PI * 2;
                blade.position.y = 0.4;
                blade.position.x = Math.cos(blade.rotation.z) * 0.4;
                blade.position.y = Math.sin(blade.rotation.z) * 0.4;
                bladesGroup.add(blade);
            }
            bladesGroup.position.set(-5, 1.5, -6.9);
            bladesGroup.userData.isWindmill = true;
            scene.add(bladesGroup);
            backgroundDecorations.push(bladesGroup);

            // Distant barn
            const barnBase = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.8, 0.6),
                new THREE.MeshBasicMaterial({ color: 0x8B0000 })
            );
            barnBase.position.set(6, 0.4, -8);
            scene.add(barnBase);
            backgroundDecorations.push(barnBase);

            const barnRoof = new THREE.Mesh(
                new THREE.ConeGeometry(0.6, 0.4, 4),
                new THREE.MeshBasicMaterial({ color: 0x4a3728 })
            );
            barnRoof.position.set(6, 1, -8);
            barnRoof.rotation.y = Math.PI / 4;
            scene.add(barnRoof);
            backgroundDecorations.push(barnRoof);
        }

        function createTree() {
            const tree = new THREE.Group();
            // Trunk
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.12, 0.6, 8),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            trunk.position.y = 0.3;
            tree.add(trunk);
            // Foliage layers
            const foliageColors = [0x228B22, 0x2E8B57, 0x32CD32];
            for (let i = 0; i < 3; i++) {
                const foliage = new THREE.Mesh(
                    new THREE.ConeGeometry(0.4 - i * 0.1, 0.5, 8),
                    new THREE.MeshLambertMaterial({ color: foliageColors[i] })
                );
                foliage.position.y = 0.7 + i * 0.3;
                tree.add(foliage);
            }
            return tree;
        }

        function createButterfly() {
            const butterfly = new THREE.Group();
            const wingMat = new THREE.MeshBasicMaterial({ 
                color: [0xFF69B4, 0xFFD700, 0x87CEEB, 0xFF6347][Math.floor(Math.random() * 4)],
                side: THREE.DoubleSide 
            });
            const wingGeo = new THREE.CircleGeometry(0.04, 8);
            const leftWing = new THREE.Mesh(wingGeo, wingMat.clone());
            leftWing.position.x = -0.03;
            leftWing.rotation.y = 0.5;
            butterfly.add(leftWing);
            const rightWing = new THREE.Mesh(wingGeo, wingMat.clone());
            rightWing.position.x = 0.03;
            rightWing.rotation.y = -0.5;
            butterfly.add(rightWing);
            // Body - use cylinder instead of capsule
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.05, 6),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            body.rotation.x = Math.PI / 2;
            butterfly.add(body);
            butterfly.userData.leftWing = leftWing;
            butterfly.userData.rightWing = rightWing;
            return butterfly;
        }

        function createBird() {
            const bird = new THREE.Group();
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), bodyMat);
            body.scale.set(1.5, 0.8, 0.8);
            bird.add(body);
            const wingGeo = new THREE.PlaneGeometry(0.2, 0.08);
            const wingMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.position.set(-0.15, 0, 0);
            bird.add(leftWing);
            const rightWing = new THREE.Mesh(wingGeo, wingMat.clone());
            rightWing.position.set(0.15, 0, 0);
            bird.add(rightWing);
            bird.userData.leftWing = leftWing;
            bird.userData.rightWing = rightWing;
            return bird;
        }

        function updateBackgroundDecorations() {
            const time = Date.now() * 0.001;
            
            // Animate butterflies with more random, natural movement
            butterflies.forEach((b, i) => {
                const t = time * 0.5 + b.userData.phase;
                // Circular wandering path with variation
                b.position.x = b.userData.basePos.x + Math.sin(t * b.userData.speedX * 3) * 0.8;
                b.position.y = b.userData.basePos.y + Math.sin(t * 1.7) * 0.4 + Math.sin(t * 0.3) * 0.2;
                b.position.z = b.userData.basePos.z + Math.cos(t * b.userData.speedZ * 2) * 0.6;
                // Wing flap
                if (b.userData.leftWing) {
                    b.userData.leftWing.rotation.y = 0.5 + Math.sin(time * 12 + i) * 0.7;
                    b.userData.rightWing.rotation.y = -0.5 - Math.sin(time * 12 + i) * 0.7;
                }
                // Face direction of movement
                b.rotation.y = Math.sin(t * b.userData.speedX * 3) * 0.5;
            });

            // Animate birds
            birds.forEach(b => {
                b.position.x += b.userData.speed;
                if (b.position.x > 10) b.position.x = -10;
                b.position.y += Math.sin(time * 2 + b.userData.phase) * 0.003;
                if (b.userData.leftWing) {
                    const flap = Math.sin(time * 8) * 0.4;
                    b.userData.leftWing.rotation.z = flap;
                    b.userData.rightWing.rotation.z = -flap;
                }
            });

            // Gentle tree sway
            trees.forEach((t, i) => {
                t.rotation.z = Math.sin(time * 0.5 + i) * 0.02;
            });

            // Animate windmill blades
            backgroundDecorations.forEach(d => {
                if (d.userData?.isWindmill) {
                    d.rotation.z = time * 0.5;
                }
            });
        }

        function explodeBomb(mole) {
            const pos = mole.position.clone();
            
            // Big explosion
            triggerHitEffect(pos, 0xFF4500, 3);
            screenShake.intensity = 0.1;
            
            // Penalty
            if (!practiceMode) {
                score = Math.max(0, score - 10);
                updateScoreSign(scoreSign, score);
                showFloatingScore(-10, pos, null);
                triggerDamageVignette();
            }
            
            // Remove mole
            moleGroup.remove(mole);
            activeMoles = activeMoles.filter(m => m !== mole);
            
            // Play explosion sound
            playExplosionSound();
        }

        function healNearbyCreatures(pos) {
            activeMoles.forEach(mole => {
                if (mole.position.distanceTo(pos) < 1 && mole.userData.health < mole.userData.maxHealth) {
                    mole.userData.health = Math.min(mole.userData.health + 1, mole.userData.maxHealth);
                    // Green heal effect
                    const heal = new THREE.Mesh(
                        new THREE.RingGeometry(0.1, 0.15, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, side: THREE.DoubleSide })
                    );
                    heal.position.copy(mole.position);
                    heal.position.y += 0.2;
                    heal.rotation.x = -Math.PI / 2;
                    scene.add(heal);
                    
                    const animate = () => {
                        heal.scale.multiplyScalar(1.1);
                        heal.material.opacity -= 0.05;
                        if (heal.material.opacity > 0) {
                            requestAnimationFrame(animate);
                        } else {
                            scene.remove(heal);
                        }
                    };
                    animate();
                }
            });
        }

        function playExplosionSound() {
            if (!audioContext || audioContext.state !== 'running') return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.5);
            gain.gain.setValueAtTime(0.3 * settings.sfxVolume, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
        }

        // === CHALLENGE MODE LOGIC ===
        function startChallenge(mode) {
            currentChallenge = mode;
            
            switch (mode) {
                case 'survival':
                    survivalLives = 3;
                    updateLivesDisplay();
                    break;
                case 'speedrun':
                    speedrunStartTime = Date.now();
                    break;
                case 'precision':
                    precisionSwings = 10;
                    // Only spawn golden moles
                    break;
                case 'bossrush':
                    // Spawn boss immediately
                    setTimeout(() => spawnBoss(), 2000);
                    break;
            }
        }

        function updateLivesDisplay() {
            if (currentChallenge !== 'survival') return;
            const lives = Math.max(0, survivalLives);
            const hearts = 'â¤ï¸'.repeat(lives) + 'ðŸ–¤'.repeat(Math.max(0, 3 - lives));
            if (timerDisplay) timerDisplay.textContent = `Lives: ${hearts}`;
        }

        function onMiss() {
            if (currentChallenge !== 'survival' || survivalLives <= 0) return;
            survivalLives--;
            updateLivesDisplay();
            triggerDamageVignette();
            screenShake.intensity = 0.05;
            
            if (survivalLives <= 0) {
                gameOver('No lives remaining!');
            }
        }

        function gameOver(reason) {
            gameActive = false;
            gamePaused = true;
            
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position:fixed;top:0;left:0;width:100%;height:100%;
                background:rgba(0,0,0,0.8);display:flex;flex-direction:column;
                justify-content:center;align-items:center;z-index:500;color:white;font-family:Arial;
            `;
            overlay.innerHTML = `
                <h1 style="font-size:48px;margin:0">GAME OVER</h1>
                <p style="font-size:24px">${reason}</p>
                <p style="font-size:36px">Score: ${score}</p>
                <p>High Score: ${highScore}</p>
                <button id="restartBtn" style="padding:15px 30px;font-size:20px;margin-top:20px;cursor:pointer;background:#4CAF50;border:none;color:white;border-radius:10px">Play Again</button>
            `;
            document.body.appendChild(overlay);
            
            document.getElementById('restartBtn').onclick = () => {
                document.body.removeChild(overlay);
                createGameModeMenu();
            };
            
            if (score > highScore) {
                highScore = score;
                saveProgress();
            }
        }

        // Check if WebXR AR is supported
        function checkXRSupport() {
            // Show game mode menu directly in browser
            showGameModeMenuHTML();
        }
        
        // Show game mode menu in HTML (before 3D scene is created)
        function showGameModeMenuHTML() {
            const menu = document.createElement('div');
            menu.id = 'startMenu';
            menu.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.95); color: white; padding: 30px;
                border-radius: 15px; font-family: Arial; text-align: center; z-index: 200;
                max-width: 500px;
            `;
            menu.innerHTML = `
                <h1 style="color:#FFD700;margin-top:0">ðŸŽ® WHACK-A-MOLE</h1>
                <p style="color:#888;margin-bottom:20px">Select a game mode to start</p>
                
                <div style="display:flex;flex-wrap:wrap;justify-content:center;gap:10px">
                    <button class="modeBtn" data-mode="endless" style="width:140px;padding:15px;font-size:14px;cursor:pointer;background:#4CAF50;border:none;color:white;border-radius:8px">
                        â™¾ï¸ Endless<br><small>Classic mode</small>
                    </button>
                    <button class="modeBtn" data-mode="timed" style="width:140px;padding:15px;font-size:14px;cursor:pointer;background:#2196F3;border:none;color:white;border-radius:8px">
                        â±ï¸ Time Attack<br><small>60 seconds</small>
                    </button>
                    <button class="modeBtn" data-mode="survival" style="width:140px;padding:15px;font-size:14px;cursor:pointer;background:#f44336;border:none;color:white;border-radius:8px">
                        â¤ï¸ Survival<br><small>3 lives only</small>
                    </button>
                    <button class="modeBtn" data-mode="speedrun" style="width:140px;padding:15px;font-size:14px;cursor:pointer;background:#FF9800;border:none;color:white;border-radius:8px">
                        ðŸƒ Speed Run<br><small>100 pts fastest</small>
                    </button>
                    <button class="modeBtn" data-mode="precision" style="width:140px;padding:15px;font-size:14px;cursor:pointer;background:#9C27B0;border:none;color:white;border-radius:8px">
                        ðŸŽ¯ Precision<br><small>Golden only</small>
                    </button>
                    <button class="modeBtn" data-mode="bossrush" style="width:140px;padding:15px;font-size:14px;cursor:pointer;background:#E91E63;border:none;color:white;border-radius:8px">
                        ðŸ‘‘ Boss Rush<br><small>Boss after boss</small>
                    </button>
                </div>
                
                <p style="margin-top:20px;font-size:12px;color:#666">
                    Works on Desktop & VR Headsets
                </p>
            `;
            document.body.appendChild(menu);
            
            // Add click handlers
            menu.querySelectorAll('.modeBtn').forEach(btn => {
                btn.onclick = () => {
                    const selectedMode = btn.dataset.mode;
                    menu.remove();
                    launchGame(selectedMode);
                };
            });
        }
        
        // Launch the game with selected mode
        function launchGame(selectedMode) {
            // Initialize audio
            initAudioContext();
            initMusicSystem();

            // Hide any UI elements
            document.getElementById('startAR').classList.add('hidden');

            // Initialize visual enhancements
            initVisualEnhancements();

            // Create background decorations
            createBackgroundDecorations();

            // Create weapon
            createWeapon();

            // Position camera for viewing
            camera.position.set(0, 1.6, 3);
            camera.lookAt(0, 0, 0);

            // Create floor and score sign
            createFloor();
            createScoreSign();

            // Add mouse click interaction for desktop
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousemove', onMouseMove);
            
            // Setup VR controller if available
            setupVRController();

            // Start animation loop
            renderer.setAnimationLoop(render);

            // Set game mode and start
            gameMode = selectedMode;
            currentChallenge = selectedMode;
            startChallenge(selectedMode);
            startGame();
        }
        
        // Setup VR controller for when entering VR mode
        function setupVRController() {
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);
            
            // Add laser pointer
            const laserGeo = new THREE.CylinderGeometry(0.004, 0.004, 5, 8);
            const laserMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const laser = new THREE.Mesh(laserGeo, laserMat);
            laser.rotation.x = Math.PI / 2;
            laser.position.z = -2.5;
            controller.add(laser);
            
            const laserDot = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            laserDot.position.z = -5;
            controller.add(laserDot);

            controllerGrip = renderer.xr.getControllerGrip(0);
            scene.add(controllerGrip);
        }

        // No longer needed - removed AR session handling
        function onSessionEnd() {
            gameActive = false;
        }

        // Create floor with dirt texture
        function createFloor() {
            // Create a simple brown floor to represent dirt
            const floorGeometry = new THREE.PlaneGeometry(5, 5);
            const floorMaterial = new THREE.MeshBasicMaterial({
                color: 0x6B3D14, // Darker brown for dirt
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floorGroup.add(floor);

            // No pre-created holes - they will be created dynamically
        }

        // Create score display sign
        function createScoreSign() {
            const signGroup = new THREE.Group();

            // Create sign post
            const postGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.05);
            const postMaterial = new THREE.MeshBasicMaterial({ color: 0x6D4C41 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.25;
            signGroup.add(post);

            // Create sign board
            const boardGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.03);
            const boardMaterial = new THREE.MeshBasicMaterial({ color: 0xA1887F });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.y = 0.6;
            signGroup.add(board);

            // Add score text (using geometry for AR compatibility)
            updateScoreSign(signGroup, 0);

            // Position sign in corner of play area
            signGroup.position.set(1.2, 0, -1.2);
            signGroup.rotation.y = -Math.PI / 4;

            scoreSign = signGroup;
            scene.add(scoreSign);
        }

        // Update score on the sign
        function updateScoreSign(signGroup, score) {
            // Remove old score display if it exists
            signGroup.children.forEach(child => {
                if (child.userData && child.userData.isScoreText) {
                    signGroup.remove(child);
                }
            });

            // Update score text in UI
            scoreDisplay.textContent = `Score: ${score} | Level: ${level}`;
        }

        // Create a creature at a specific position
        function createMole(position, holeRef) {
            // Use expanded creature types
            let availableCreatures = creatureTypesExpanded.filter(c => c.minLevel <= level);
            
            // Precision mode - only golden moles
            if (currentChallenge === 'precision') {
                availableCreatures = creatureTypesExpanded.filter(c => c.type === 'goldenMole');
            }

            // Calculate total probability
            const totalProbability = availableCreatures.reduce((sum, c) => sum + c.probability, 0);

            // Randomly select creature type based on probability
            let randomValue = Math.random() * totalProbability;
            let selectedCreature = availableCreatures[0]; // Default to first type

            for (const creature of availableCreatures) {
                if (randomValue <= creature.probability) {
                    selectedCreature = creature;
                    break;
                }
                randomValue -= creature.probability;
            }

            // Create creature with enhanced detailed models
            const creatureGroup = new THREE.Group();

            // Enhanced materials with better lighting and textures
            const creatureMaterial = new THREE.MeshLambertMaterial({
                color: selectedCreature.color,
                flatShading: true // For stylized look
            });
            
            // Ghost creatures are transparent
            if (selectedCreature.behavior === 'phase') {
                creatureMaterial.transparent = true;
                creatureMaterial.opacity = 0.6;
            }

            // Enhanced material variations
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const pinkMaterial = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
            const darkMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const furMaterial = new THREE.MeshLambertMaterial({
                color: selectedCreature.color,
                transparent: true,
                opacity: 0.8
            });

            // Enhanced body with more realistic proportions using available geometries
            let bodyGeometry, neckGeometry, chestGeometry;
            if (selectedCreature.type === 'goldenMole' || selectedCreature.type === 'kingMole') {
                // Golden/King mole - more regal proportions with layered body
                bodyGeometry = new THREE.SphereGeometry(0.12, 12, 8);
                chestGeometry = new THREE.SphereGeometry(0.1, 12, 8);
                neckGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.06, 12);
            } else {
                // Standard body with organic curves
                bodyGeometry = new THREE.SphereGeometry(0.1, 10, 8);
                chestGeometry = new THREE.SphereGeometry(0.08, 10, 8);
                neckGeometry = new THREE.CylinderGeometry(0.07, 0.09, 0.05, 10);
            }

            // Main body (lower torso)
            const body = new THREE.Mesh(bodyGeometry, creatureMaterial);
            body.position.y = 0.06;
            body.scale.set(1, 0.8, 1.2); // Make more oval-shaped
            creatureGroup.add(body);

            // Chest (upper torso)
            const chest = new THREE.Mesh(chestGeometry, creatureMaterial);
            chest.position.y = 0.12;
            chest.scale.set(1, 0.9, 1.1);
            creatureGroup.add(chest);

            // Add neck for more realistic anatomy
            const neck = new THREE.Mesh(neckGeometry, creatureMaterial);
            neck.position.y = 0.16;
            creatureGroup.add(neck);

            // Enhanced head with better proportions
            const headGeometry = new THREE.SphereGeometry(0.09, 16, 12);
            const head = new THREE.Mesh(headGeometry, creatureMaterial);
            head.position.y = 0.21;
            head.scale.set(1, 0.9, 1.1); // Slightly flatten and elongate
            creatureGroup.add(head);

            // Add fur texture details with smaller spheres
            for (let i = 0; i < 8; i++) {
                const furPatch = new THREE.Mesh(
                    new THREE.SphereGeometry(0.015, 6, 4),
                    furMaterial
                );
                const angle = (i / 8) * Math.PI * 2;
                furPatch.position.set(
                    Math.cos(angle) * 0.08,
                    0.06 + Math.random() * 0.08,
                    Math.sin(angle) * 0.08
                );
                creatureGroup.add(furPatch);
            }

            // Add paws/feet for more realism
            const pawGeometry = new THREE.SphereGeometry(0.025, 8, 6);
            // Darken the creature color for paws by reducing RGB values
            const pawColor = new THREE.Color(selectedCreature.color).multiplyScalar(0.7);
            const pawMaterial = new THREE.MeshLambertMaterial({
                color: pawColor
            });

            // Front paws
            const leftFrontPaw = new THREE.Mesh(pawGeometry, pawMaterial);
            leftFrontPaw.position.set(0.06, 0.02, 0.08);
            leftFrontPaw.scale.set(1, 0.6, 1.2);
            creatureGroup.add(leftFrontPaw);

            const rightFrontPaw = new THREE.Mesh(pawGeometry, pawMaterial);
            rightFrontPaw.position.set(-0.06, 0.02, 0.08);
            rightFrontPaw.scale.set(1, 0.6, 1.2);
            creatureGroup.add(rightFrontPaw);

            // Back paws
            const leftBackPaw = new THREE.Mesh(pawGeometry, pawMaterial);
            leftBackPaw.position.set(0.05, 0.02, -0.05);
            leftBackPaw.scale.set(1, 0.6, 1);
            creatureGroup.add(leftBackPaw);

            const rightBackPaw = new THREE.Mesh(pawGeometry, pawMaterial);
            rightBackPaw.position.set(-0.05, 0.02, -0.05);
            rightBackPaw.scale.set(1, 0.6, 1);
            creatureGroup.add(rightBackPaw);

            // Add subtle tail
            const tailGeometry = new THREE.ConeGeometry(0.02, 0.08, 6);
            const tail = new THREE.Mesh(tailGeometry, creatureMaterial);
            tail.position.set(0, 0.08, -0.12);
            tail.rotation.x = Math.PI / 3; // Angle it upward
            tail.userData = { isTail: true, baseRotX: tail.rotation.x };
            creatureGroup.add(tail);

            // Common feature: Eyes - slightly oval for more character
            const leftEyeGeometry = new THREE.SphereGeometry(0.018, 6, 6);
            leftEyeGeometry.scale(1, 1.2, 1); // Make slightly oval
            const leftEye = new THREE.Mesh(leftEyeGeometry, eyeMaterial);
            leftEye.position.set(0.045, 0.2, 0.08);
            creatureGroup.add(leftEye);

            const rightEyeGeometry = new THREE.SphereGeometry(0.018, 6, 6);
            rightEyeGeometry.scale(1, 1.2, 1); // Make slightly oval
            const rightEye = new THREE.Mesh(rightEyeGeometry, eyeMaterial);
            rightEye.position.set(-0.045, 0.2, 0.08);
            creatureGroup.add(rightEye);

            // Eye reflections for more life-like appearance
            const leftReflection = new THREE.Mesh(
                new THREE.SphereGeometry(0.005, 4, 4),
                whiteMaterial
            );
            leftReflection.position.set(0.04, 0.205, 0.095);
            creatureGroup.add(leftReflection);

            const rightReflection = new THREE.Mesh(
                new THREE.SphereGeometry(0.005, 4, 4),
                whiteMaterial
            );
            rightReflection.position.set(-0.04, 0.205, 0.095);
            creatureGroup.add(rightReflection);

            // Nose - different shapes per creature type
            let noseGeometry;
            let noseColor = 0xFF69B4; // Default pink nose

            // Customize features based on creature type with more detailed polygonal style
            if (selectedCreature.type === 'mole') {
                // Brown mole features
                // Add detailed snout
                const snoutGeometry = new THREE.CylinderGeometry(0.05, 0.07, 0.06, 6);
                const snout = new THREE.Mesh(snoutGeometry, creatureMaterial);
                snout.position.set(0, 0.16, 0.08);
                snout.rotation.x = Math.PI / 2.5;
                creatureGroup.add(snout);

                // Add small ears
                const earGeometry = new THREE.ConeGeometry(0.03, 0.04, 5);
                earGeometry.rotateX(Math.PI / 6);

                const leftEar = new THREE.Mesh(earGeometry, creatureMaterial);
                leftEar.position.set(0.07, 0.23, -0.02);
                leftEar.rotation.z = -Math.PI / 12;
                leftEar.userData = { isEar: true, baseRotZ: leftEar.rotation.z };
                creatureGroup.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, creatureMaterial);
                rightEar.position.set(-0.07, 0.23, -0.02);
                rightEar.rotation.z = Math.PI / 12;
                rightEar.userData = { isEar: true, baseRotZ: rightEar.rotation.z };
                creatureGroup.add(rightEar);

                // Add cheeks
                const cheekGeometry = new THREE.SphereGeometry(0.04, 5, 5);
                cheekGeometry.scale(1, 0.7, 0.7);

                const leftCheek = new THREE.Mesh(cheekGeometry, creatureMaterial);
                leftCheek.position.set(0.08, 0.14, 0.04);
                creatureGroup.add(leftCheek);

                const rightCheek = new THREE.Mesh(cheekGeometry, creatureMaterial);
                rightCheek.position.set(-0.08, 0.14, 0.04);
                creatureGroup.add(rightCheek);

                // Pink nose
                noseColor = 0xFF69B4;
                noseGeometry = new THREE.OctahedronGeometry(0.02, 1);
            }
            else if (selectedCreature.type === 'redGopher') {
                // Red gopher features
                // Add pointed ears
                const earGeometry = new THREE.ConeGeometry(0.04, 0.1, 5);

                const leftEar = new THREE.Mesh(earGeometry, creatureMaterial);
                leftEar.position.set(0.08, 0.26, 0);
                leftEar.rotation.z = -Math.PI / 6;
                leftEar.userData = { isEar: true, baseRotZ: leftEar.rotation.z };
                creatureGroup.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, creatureMaterial);
                rightEar.position.set(-0.08, 0.26, 0);
                rightEar.rotation.z = Math.PI / 6;
                rightEar.userData = { isEar: true, baseRotZ: rightEar.rotation.z };
                creatureGroup.add(rightEar);

                // Add a gopher-style snout
                const snoutGeometry = new THREE.CylinderGeometry(0.045, 0.06, 0.08, 6);
                const snout = new THREE.Mesh(snoutGeometry, creatureMaterial);
                snout.position.set(0, 0.16, 0.09);
                snout.rotation.x = Math.PI / 2.5;
                creatureGroup.add(snout);

                // Add teeth
                const toothGeometry = new THREE.BoxGeometry(0.015, 0.025, 0.01);
                const toothMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

                const leftTooth = new THREE.Mesh(toothGeometry, toothMaterial);
                leftTooth.position.set(0.015, 0.13, 0.14);
                creatureGroup.add(leftTooth);

                const rightTooth = new THREE.Mesh(toothGeometry, toothMaterial);
                rightTooth.position.set(-0.015, 0.13, 0.14);
                creatureGroup.add(rightTooth);

                noseColor = 0x000000; // Black nose for gopher
                noseGeometry = new THREE.OctahedronGeometry(0.022, 1);
            }
            else if (selectedCreature.type === 'blueRabbit') {
                // Blue rabbit features
                // Add long ears with better shape
                const earGeometry = new THREE.CylinderGeometry(0.02, 0.03, 0.18, 5);
                earGeometry.translate(0, 0.09, 0); // Shift origin to bottom

                const leftEar = new THREE.Mesh(earGeometry, creatureMaterial);
                leftEar.position.set(0.05, 0.22, -0.03);
                leftEar.rotation.z = -Math.PI / 12;
                leftEar.rotation.x = -Math.PI / 12;
                leftEar.userData = { isEar: true, baseRotZ: leftEar.rotation.z };
                creatureGroup.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, creatureMaterial);
                rightEar.position.set(-0.05, 0.22, -0.03);
                rightEar.rotation.z = Math.PI / 12;
                rightEar.rotation.x = -Math.PI / 12;
                rightEar.userData = { isEar: true, baseRotZ: rightEar.rotation.z };
                creatureGroup.add(rightEar);

                // Add ear inner part - pink insides
                const earInnerGeometry = new THREE.CylinderGeometry(0.01, 0.02, 0.14, 5);
                earInnerGeometry.translate(0, 0.07, 0);
                const earInnerMaterial = new THREE.MeshBasicMaterial({ color: 0xFF9999 });

                const leftEarInner = new THREE.Mesh(earInnerGeometry, earInnerMaterial);
                leftEarInner.position.set(0.05, 0.22, -0.025);
                leftEarInner.rotation.z = -Math.PI / 12;
                leftEarInner.rotation.x = -Math.PI / 12;
                creatureGroup.add(leftEarInner);

                const rightEarInner = new THREE.Mesh(earInnerGeometry, earInnerMaterial);
                rightEarInner.position.set(-0.05, 0.22, -0.025);
                rightEarInner.rotation.z = Math.PI / 12;
                rightEarInner.rotation.x = -Math.PI / 12;
                creatureGroup.add(rightEarInner);

                // Add whiskers
                const whiskerGeometry = new THREE.CylinderGeometry(0.003, 0.003, 0.08, 3);
                const whiskerMaterial = new THREE.MeshBasicMaterial({ color: 0xDDDDDD });

                for (let i = 0; i < 3; i++) {
                    const leftWhisker = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
                    leftWhisker.position.set(0.06, 0.17 - i * 0.01, 0.1);
                    leftWhisker.rotation.z = -Math.PI / 2.5;
                    leftWhisker.rotation.y = -Math.PI / 12;
                    creatureGroup.add(leftWhisker);

                    const rightWhisker = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
                    rightWhisker.position.set(-0.06, 0.17 - i * 0.01, 0.1);
                    rightWhisker.rotation.z = Math.PI / 2.5;
                    rightWhisker.rotation.y = Math.PI / 12;
                    creatureGroup.add(rightWhisker);
                }

                noseColor = 0xFFFFFF; // White nose for rabbit
                noseGeometry = new THREE.TetrahedronGeometry(0.02, 1);
            }
            else if (selectedCreature.type === 'goldenMole') {
                // Golden mole features - royal and majestic
                // Add a more detailed crown
                const crownBaseGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.03, 6);
                const crownBase = new THREE.Mesh(crownBaseGeometry, new THREE.MeshBasicMaterial({ color: 0xFFD700 }));
                crownBase.position.set(0, 0.26, 0);
                creatureGroup.add(crownBase);

                // Crown points
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const crownPoint = new THREE.Mesh(
                        new THREE.ConeGeometry(0.02, 0.05, 4),
                        new THREE.MeshBasicMaterial({ color: 0xFFD700 })
                    );
                    crownPoint.position.set(
                        Math.sin(angle) * 0.05,
                        0.3,
                        Math.cos(angle) * 0.05
                    );
                    creatureGroup.add(crownPoint);
                }

                // Add jewel to crown
                const jewelGeometry = new THREE.OctahedronGeometry(0.025, 1);
                const jewelMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 }); // Red jewel
                const jewel = new THREE.Mesh(jewelGeometry, jewelMaterial);
                jewel.position.set(0, 0.3, 0.05);
                creatureGroup.add(jewel);

                // Add sparkle effects around the mole
                const sparklePositions = [
                    { x: 0.07, y: 0.18, z: 0.05 },
                    { x: -0.07, y: 0.22, z: 0.05 },
                    { x: 0.05, y: 0.15, z: 0.09 },
                    { x: -0.03, y: 0.19, z: -0.05 }
                ];

                sparklePositions.forEach((pos, i) => {
                    // Use star-like geometry for sparkles
                    const sparkle = new THREE.Mesh(
                        new THREE.OctahedronGeometry(0.015, 0),
                        new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
                    );
                    sparkle.position.set(pos.x, pos.y, pos.z);
                    sparkle.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    creatureGroup.add(sparkle);
                });

                // Add royal collar
                const collarGeometry = new THREE.TorusGeometry(0.08, 0.015, 8, 12, Math.PI);
                const collarMaterial = new THREE.MeshBasicMaterial({ color: 0x9932CC });
                const collar = new THREE.Mesh(collarGeometry, collarMaterial);
                collar.rotation.x = Math.PI / 2;
                collar.position.set(0, 0.11, 0.01);
                creatureGroup.add(collar);

                noseColor = 0x000000; // Black nose for golden mole
                noseGeometry = new THREE.OctahedronGeometry(0.02, 1);
            }

            // Create nose with appropriate geometry and material
            if (!noseGeometry) {
                noseGeometry = new THREE.OctahedronGeometry(0.02, 1); // Default more angular nose
            }
            const noseMaterial = new THREE.MeshBasicMaterial({ color: noseColor });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 0.17, 0.11); // Moved slightly forward for better visibility
            creatureGroup.add(nose);

            // Add mouth - slightly different for each creature
            const mouthGeometry = new THREE.BoxGeometry(0.03, 0.01, 0.01);
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 0.14, 0.11);
            creatureGroup.add(mouth);

            // Set position
            creatureGroup.position.set(position.x, -0.2, position.z); // Start below ground

            // Calculate animation speed variation by creature type
            // Each creature has its own base speed characteristics and random variation
            let baseSpeedMultiplier;
            let randomVariation;

            switch (selectedCreature.type) {
                case 'mole': // Brown moles - moderately paced with moderate variation
                    baseSpeedMultiplier = 1.0;
                    randomVariation = 0.3; // Â±30% variation
                    break;
                case 'redGopher': // Red gophers - faster with less predictability
                    baseSpeedMultiplier = 0.8; // 20% faster than moles
                    randomVariation = 0.4; // Â±40% variation
                    break;
                case 'blueRabbit': // Blue rabbits - quite fast with high variation
                    baseSpeedMultiplier = 0.7; // 30% faster than moles
                    randomVariation = 0.5; // Â±50% variation (very unpredictable)
                    break;
                case 'goldenMole': // Golden moles - fastest with extreme variation
                    baseSpeedMultiplier = 0.6; // 40% faster than moles
                    randomVariation = 0.6; // Â±60% variation (extremely unpredictable)
                    break;
                default:
                    baseSpeedMultiplier = 1.0;
                    randomVariation = 0.3;
            }

            // Apply random variation within the creature-specific range
            const speedMultiplier = baseSpeedMultiplier * (1 - randomVariation + Math.random() * (randomVariation * 2));

            // Calculate the final duration for this creature instance
            const actualDuration = Math.floor(moleSpeed * speedMultiplier);

            // Add glow aura for rare creatures
            if (selectedCreature.type === 'goldenMole') {
                const glowGeo = new THREE.SphereGeometry(0.18, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.y = 0.12;
                glow.userData.isGlow = true;
                creatureGroup.add(glow);
            } else if (selectedCreature.type === 'blueRabbit') {
                const glowGeo = new THREE.SphereGeometry(0.15, 12, 12);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0x0066CC,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.y = 0.12;
                glow.userData.isGlow = true;
                creatureGroup.add(glow);
            }

            creatureGroup.userData = {
                isMole: true,
                active: true,
                startTime: Date.now(),
                duration: actualDuration,
                holeRef: holeRef,
                position: position,
                creatureType: selectedCreature,
                pointValue: selectedCreature.pointValue,
                health: selectedCreature.health || 1,
                maxHealth: selectedCreature.health || 1,
                behavior: selectedCreature.behavior || 'normal'
            };

            return creatureGroup;
        }

        // Create a hole at a specific position
        function createHole(position) {
            const holeGeometry = new THREE.CircleGeometry(0.15, 32);
            const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x3E2723 });

            const hole = new THREE.Mesh(holeGeometry, holeMaterial);
            hole.position.set(position.x, 0.01, position.z); // Slightly above ground to avoid z-fighting
            hole.rotation.x = -Math.PI / 2;
            hole.userData = { isHole: true, position: position };
            hole.scale.set(0, 0, 0); // Start with zero scale

            floorGroup.add(hole);
            activeHoles.push(hole);

            // Animate hole appearing
            animateHoleAppear(hole);

            return hole;
        }

        // Animate hole appearance
        function animateHoleAppear(hole) {
            const duration = 200; // ms
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                hole.scale.set(progress, progress, progress);

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }

            update();
        }

        // Animate hole disappearing
        function animateHoleDisappear(hole) {
            if (!hole || !floorGroup.children.includes(hole)) return;
            
            const duration = 200; // ms
            const startTime = Date.now();
            let removed = false;
            
            function cleanup() {
                if (removed) return;
                removed = true;
                if (floorGroup.children.includes(hole)) {
                    floorGroup.remove(hole);
                }
                activeHoles = activeHoles.filter(h => h !== hole);
            }

            function update() {
                if (removed) return;
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                const scale = 1 - progress;
                hole.scale.set(scale, scale, scale);

                if (progress < 1) {
                    requestAnimationFrame(update);
                } else {
                    cleanup();
                }
            }
            
            // Fallback cleanup
            setTimeout(cleanup, duration + 300);

            update();
        }

        // Spawn a mole at a random position
        function spawnMole() {
            if (!gameActive) {
                debugPrint('spawnMole: game not active');
                return;
            }

            // Get available positions that don't have active moles or holes
            const availablePositions = holePositions.filter(pos => {
                // Check if any active mole or hole is at this position
                return !activeMoles.some(mole =>
                    mole.position.x === pos.x && mole.position.z === pos.z
                ) && !activeHoles.some(hole =>
                    hole.position.x === pos.x && hole.position.z === pos.z
                );
            });

            if (availablePositions.length === 0) {
                debugPrint('spawnMole: no available positions');
                return;
            }

            // Select a random position
            const position = availablePositions[Math.floor(Math.random() * availablePositions.length)];
            debugPrint(`Spawning mole at ${position.x}, ${position.z}`);

            // Create a hole
            const hole = createHole(position);
            debugPrint('Hole created');

            // Wait for the hole to appear before creating the mole
            setTimeout(() => {
                try {
                    // Create and add mole
                    debugPrint('Creating mole...');
                    const mole = createMole(position, hole);
                    if (!mole) {
                        debugPrint('ERROR: createMole returned null/undefined');
                        return;
                    }
                    debugPrint('Mole created, adding to group...');
                    activeMoles.push(mole);
                    moleGroup.add(mole);
                    debugPrint('Mole added! moleGroup.children.length=' + moleGroup.children.length);

                    // Animate mole coming up
                    animateMoleUp(mole);

                    // Schedule mole to go back down
                    setTimeout(() => {
                        if (mole.userData.active) {
                            animateMoleDown(mole);
                        }
                    }, mole.userData.duration);
                } catch (e) {
                    debugPrint('ERROR in mole spawn: ' + e.message);
                }
            }, 250); // Wait for hole to appear
        }

        // Animate mole coming up with varied animation speed by creature type
        function animateMoleUp(mole) {
            const startY = mole.position.y;
            const targetY = 0.05; // Slightly above ground so body shows

            // Spawn dirt burst effect
            createDirtBurst(mole.position.clone());

            // Vary animation duration based on creature type
            let duration = 300; // Default

            if (mole.userData && mole.userData.creatureType) {
                switch (mole.userData.creatureType.type) {
                    case 'mole':
                        duration = 300; // Brown moles - standard speed
                        break;
                    case 'redGopher':
                        duration = 250; // Red gophers - slightly faster
                        break;
                    case 'blueRabbit':
                        duration = 200; // Blue rabbits - quite fast
                        break;
                    case 'goldenMole':
                        duration = 150; // Golden moles - very fast
                        break;
                }

                // Add some random variation (Â±20%)
                duration = Math.floor(duration * (0.8 + Math.random() * 0.4));
            }

            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Use a slight ease-out effect for more natural movement
                const easedProgress = 1 - Math.pow(1 - progress, 2);
                mole.position.y = startY + (targetY - startY) * easedProgress;

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }

            update();
        }

        // Create dirt burst effect when creature emerges
        function createDirtBurst(position) {
            const dirtColors = [0x8B4513, 0x654321, 0x5C4033, 0x6B4423];
            for (let i = 0; i < 8; i++) {
                const dirt = new THREE.Mesh(
                    new THREE.BoxGeometry(0.03, 0.03, 0.03),
                    new THREE.MeshBasicMaterial({ color: dirtColors[Math.floor(Math.random() * dirtColors.length)] })
                );
                dirt.position.copy(position);
                dirt.position.y = 0.05;
                const angle = (i / 8) * Math.PI * 2;
                const speed = 0.03 + Math.random() * 0.02;
                dirt.userData = {
                    velocity: new THREE.Vector3(Math.cos(angle) * speed, 0.08 + Math.random() * 0.04, Math.sin(angle) * speed),
                    life: 0.6
                };
                scene.add(dirt);
                
                // Animate dirt
                function animateDirt() {
                    dirt.userData.velocity.y -= 0.004;
                    dirt.position.add(dirt.userData.velocity);
                    dirt.rotation.x += 0.2;
                    dirt.rotation.y += 0.15;
                    dirt.userData.life -= 0.02;
                    
                    if (dirt.userData.life > 0 && dirt.position.y > 0) {
                        requestAnimationFrame(animateDirt);
                    } else {
                        scene.remove(dirt);
                        dirt.geometry.dispose();
                        dirt.material.dispose();
                    }
                }
                animateDirt();
            }
        }

        // Animate mole exit with varied animations based on creature type
        function animateMoleDown(mole) {
            const exitAnim = mole.userData.creatureType?.exitAnim || 'down';
            const startPos = mole.position.clone();
            const startTime = Date.now();
            let duration = 400;

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                switch (exitAnim) {
                    case 'hop':
                        // Rabbit hops away - bouncing while moving away from camera
                        const hopHeight = Math.abs(Math.sin(progress * Math.PI * 4)) * 0.25;
                        mole.position.y = startPos.y + hopHeight;
                        mole.position.z = startPos.z - progress * 1.2; // Hop away from player
                        mole.position.x = startPos.x + (Math.random() > 0.5 ? 1 : -1) * progress * 0.3;
                        mole.rotation.x = Math.sin(progress * Math.PI * 4) * 0.4;
                        mole.scale.setScalar(1 - progress * 0.5); // Shrink as it hops away
                        break;
                    case 'dash':
                        // Speed dash to the side
                        mole.position.x = startPos.x + (Math.random() > 0.5 ? 1 : -1) * progress * 1.5;
                        mole.scale.x = 1 + progress * 0.5;
                        mole.scale.z = 1 - progress * 0.3;
                        createSpeedLines(mole.position);
                        break;
                    case 'flyaway':
                        // Bird flies up and away
                        mole.position.y = startPos.y + progress * 1.5;
                        mole.position.x = startPos.x + Math.sin(progress * Math.PI * 4) * 0.3;
                        mole.rotation.z = Math.sin(progress * Math.PI * 8) * 0.4;
                        break;
                    case 'fade':
                        // Ghost fades out
                        mole.traverse(child => {
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.opacity = 1 - progress;
                            }
                        });
                        mole.position.y = startPos.y + progress * 0.3;
                        break;
                    case 'poof':
                        // Ninja smoke poof
                        if (progress < 0.1) createSmokeEffect(mole.position);
                        mole.scale.setScalar(1 - progress);
                        break;
                    case 'sparkle':
                        // Golden sparkle exit
                        mole.position.y = startPos.y - progress * 0.3;
                        mole.rotation.y += 0.3;
                        if (Math.random() < 0.3) createSparkle(mole.position);
                        break;
                    case 'beam':
                        // Alien beam up
                        mole.position.y = startPos.y + progress * 2;
                        mole.scale.x = 1 - progress * 0.8;
                        mole.scale.z = 1 - progress * 0.8;
                        createBeamEffect(startPos);
                        break;
                    case 'bounce':
                        // Candy bounce away
                        mole.position.y = startPos.y + Math.abs(Math.sin(progress * Math.PI * 4)) * 0.3 - progress * 0.2;
                        mole.rotation.z = progress * Math.PI * 2;
                        break;
                    case 'cartwheel':
                        // Clown cartwheel
                        mole.position.x = startPos.x + progress * 0.8;
                        mole.rotation.z = progress * Math.PI * 4;
                        mole.position.y = startPos.y + Math.sin(progress * Math.PI) * 0.2;
                        break;
                    case 'teleport':
                        // Wizard teleport
                        if (progress < 0.5) {
                            mole.rotation.y += 0.5;
                            mole.scale.setScalar(1 - progress);
                        } else {
                            mole.visible = false;
                        }
                        if (progress < 0.1) createMagicSparkles(mole.position);
                        break;
                    case 'malfunction':
                        // Robot malfunction
                        mole.position.x = startPos.x + (Math.random() - 0.5) * 0.1;
                        mole.position.z = startPos.z + (Math.random() - 0.5) * 0.1;
                        mole.position.y = startPos.y - progress * 0.3;
                        if (Math.random() < 0.2) createSparkEffect(mole.position);
                        break;
                    case 'melt':
                        // Shadow melt into ground
                        mole.scale.y = 1 - progress * 0.9;
                        mole.position.y = startPos.y - progress * 0.15;
                        break;
                    case 'shatter':
                        // Ice shatter
                        if (progress < 0.1) createIceShards(mole.position);
                        mole.scale.setScalar(1 - progress);
                        break;
                    case 'float':
                        // Healer float up gently
                        mole.position.y = startPos.y + Math.sin(progress * Math.PI) * 0.4;
                        mole.rotation.y += 0.1;
                        mole.traverse(child => {
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.opacity = 1 - progress;
                            }
                        });
                        break;
                    default:
                        // Standard down animation
                        const easedProgress = progress * progress;
                        mole.position.y = startPos.y + (-0.3 - startPos.y) * easedProgress;
                }

                if (progress < 1) {
                    requestAnimationFrame(update);
                } else {
                    mole.userData.active = false;
                    mole.userData.active = false;

                    // PENALTY SYSTEM: Subtract points for missed creatures
                    if (mole.userData.creatureType && !mole.userData.wasHit) {
                        // Track miss
                        trackMiss();
                        
                        // Only apply effects if not in practice mode
                        if (!practiceMode) {
                            // Reset combo on miss
                            resetCombo();
                            
                            // Trigger damage vignette
                            triggerDamageVignette();
                            
                            // Handle survival mode
                            onMiss();
                        }

                        console.log(`Missed ${mole.userData.creatureType.type}! Score: ${score}`);
                    }

                    // Remove mole after animation
                    moleGroup.remove(mole);
                    activeMoles = activeMoles.filter(m => m !== mole);

                    // Also remove the hole
                    if (mole.userData.holeRef && floorGroup.children.includes(mole.userData.holeRef)) {
                        animateHoleDisappear(mole.userData.holeRef);
                    }
                }
            }

            // Keep mole active during descent animation so it can still be hit
            update();
        }

        // Create level complete UI
        function createLevelCompleteUI() {
            // HTML UI works for both desktop and VR browser
            if (levelCompleteUI) {
                document.body.removeChild(levelCompleteUI);
            }

            levelCompleteUI = document.createElement('div');
            levelCompleteUI.style.position = 'absolute';
            levelCompleteUI.style.left = '50%';
            levelCompleteUI.style.top = '50%';
            levelCompleteUI.style.transform = 'translate(-50%, -50%)';
            levelCompleteUI.style.textAlign = 'center';
            levelCompleteUI.style.backgroundColor = 'rgba(0,0,0,0.7)';
            levelCompleteUI.style.color = 'white';
            levelCompleteUI.style.padding = '20px';
            levelCompleteUI.style.borderRadius = '5px';
            levelCompleteUI.style.zIndex = '100';

            const levelTitle = document.createElement('h2');
            levelTitle.textContent = `Level ${level} Complete!`;
            levelTitle.style.color = '#FFD700';
            levelCompleteUI.appendChild(levelTitle);

            const scoreInfo = document.createElement('p');
            scoreInfo.textContent = `Score: ${score}`;
            levelCompleteUI.appendChild(scoreInfo);

            const timeInfo = document.createElement('p');
            timeInfo.textContent = `Time: ${formatTime(gameTimer)}`;
            levelCompleteUI.appendChild(timeInfo);

            // Show max combo achieved
            if (maxCombo > 1) {
                const comboInfo = document.createElement('p');
                comboInfo.textContent = `ðŸ”¥ Max Combo: ${maxCombo}x`;
                comboInfo.style.color = '#FF6600';
                levelCompleteUI.appendChild(comboInfo);
            }

            // Show which new creature is unlocked if applicable
            if (level < creatureTypes.length) {
                const newCreature = creatureTypes.find(c => c.minLevel === level + 1);
                if (newCreature) {
                    const unlockInfo = document.createElement('p');
                    unlockInfo.textContent = `New creature unlocked: ${getCreatureDisplayName(newCreature.type)}!`;
                    unlockInfo.style.color = '#' + newCreature.color.toString(16).padStart(6, '0');
                    levelCompleteUI.appendChild(unlockInfo);
                }
            }

            // If this is the final level, add a congratulations message
            if (level >= 4) {
                const congratsMessage = document.createElement('h3');
                congratsMessage.textContent = 'Congratulations! You completed all levels!';
                congratsMessage.style.color = '#FFD700';
                congratsMessage.style.marginTop = '15px';
                levelCompleteUI.appendChild(congratsMessage);

                const finalMessage = document.createElement('p');
                finalMessage.textContent = `You found all creature types and earned ${score} total points.`;
                levelCompleteUI.appendChild(finalMessage);
            }

            const nextButton = document.createElement('button');

            if (level >= 4) {
                // This is the final level completion
                nextButton.textContent = 'Restart Game';
                nextButton.addEventListener('click', () => {
                    // Restart the game from level 1
                    if (levelCompleteUI) {
                        document.body.removeChild(levelCompleteUI);
                        levelCompleteUI = null;
                    }
                    startGame();
                });
            } else {
                // Continue to next level
                nextButton.textContent = `Start Level ${level + 1}`;
                nextButton.addEventListener('click', () => {
                    startNextLevel();
                });
            }

            nextButton.style.padding = '10px 20px';
            nextButton.style.backgroundColor = '#4CAF50';
            nextButton.style.border = 'none';
            nextButton.style.borderRadius = '4px';
            nextButton.style.color = 'white';
            nextButton.style.fontSize = '16px';
            nextButton.style.cursor = 'pointer';
            nextButton.style.marginTop = '15px';
            levelCompleteUI.appendChild(nextButton);

            document.body.appendChild(levelCompleteUI);
        }

        // Get friendly name for creature type
        function getCreatureDisplayName(type) {
            switch (type) {
                case 'mole': return 'Brown Mole';
                case 'redGopher': return 'Red Gopher';
                case 'blueRabbit': return 'Blue Rabbit';
                case 'goldenMole': return 'Golden Mole';
                default: return type;
            }
        }

        // Format time as MM:SS
        function formatTime(timeInMs) {
            const totalSeconds = Math.floor(timeInMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Start the game
        function startGame() {
            // Clean up any level complete UI
            if (levelCompleteUI) {
                document.body.removeChild(levelCompleteUI);
                levelCompleteUI = null;
            }
            
            score = 0;
            levelScore = 0;
            level = 1;
            moleSpeed = 2000;
            gameActive = true;
            gamePaused = false;
            levelEnding = false;
            gameTimer = 0;
            levelStartTime = Date.now();
            lastTimestamp = Date.now();
            
            debugPrint('startGame: gameActive=' + gameActive);
            
            // Track games played
            gamesPlayed++;
            saveProgress();
            
            // Reset combo system
            combo = 0;
            maxCombo = 0;
            lastBossScore = 0;
            currentBoss = null;
            bossesDefeatedThisGame = 0;
            activeChaosEvent = null;
            updateComboDisplay();
            
            // Initialize biome system
            debugPrint('Initializing biome...');
            if (!biomeGroup) initBiome();
            const startBiome = settings.selectedBiome === 'random' 
                ? Math.floor(Math.random() * biomesExpanded.length) 
                : parseInt(settings.selectedBiome);
            setBiome(startBiome);
            debugPrint('Biome set to: ' + biomesExpanded[startBiome]?.name);
            
            // Start power-up spawning
            startPowerUpSpawning();
            
            // Start chaos events (not in practice mode)
            if (!practiceMode) startChaosEventTimer();
            
            updateScoreSign(scoreSign, score);
            updateTimer();

            // Initialize audio context with user interaction
            initAudioContext();

            // Start spawning moles
            debugPrint('Calling spawnMoles...');
            spawnMoles();
            debugPrint('spawnMoles called');
        }

        // Start the next level
        function startNextLevel() {
            // Hide the level complete UI (both HTML and 3D)
            if (levelCompleteUI) {
                document.body.removeChild(levelCompleteUI);
                levelCompleteUI = null;
            }

            // Increment level
            level++;

            // Reset level-specific variables
            levelScore = 0;
            moleSpeed = Math.max(800, 2000 - (level - 1) * 200);
            gameActive = true;
            gamePaused = false;
            levelEnding = false;
            levelStartTime = Date.now();
            lastTimestamp = Date.now();

            // Clear any remaining moles and holes
            while (moleGroup.children.length > 0) {
                moleGroup.remove(moleGroup.children[0]);
            }
            activeMoles = [];

            while (activeHoles.length > 0) {
                const hole = activeHoles[0];
                floorGroup.remove(hole);
                activeHoles.shift();
            }

            updateScoreSign(scoreSign, score);
            updateTimer();

         // Audio already initialized - no background music needed

            // Start spawning moles
            spawnMoles();
        }

        // Update timer display
        function updateTimer() {
            if (!gameActive) return;

            const currentTime = Date.now();

            // Only update timer if not paused
            if (!gamePaused) {
                gameTimer += currentTime - lastTimestamp;
            }

            lastTimestamp = currentTime;

            // Handle timed mode
            if (gameMode === 'timed') {
                updateTimedMode();
            } else {
                // Update timer display for endless/practice mode
                timerDisplay.textContent = `Time: ${formatTime(gameTimer)}`;
            }

            // Schedule next update
            requestAnimationFrame(updateTimer);
        }

        // Spawn multiple moles based on current level
        function spawnMoles() {
            if (!gameActive || levelEnding) return;

            // Spawn moles based on level
            const numMolesToSpawn = Math.min(level, 5); // Cap at 5 moles at once

            for (let i = 0; i < numMolesToSpawn; i++) {
                setTimeout(() => {
                    if (!levelEnding) spawnMole();
                }, i * 500); // Stagger spawns
            }

            // Schedule next wave of moles with decreasing interval based on level
            // Spawn interval decreases from 2000ms at level 1 to 600ms at higher levels
            const spawnInterval = Math.max(600, 2000 - (level - 1) * 200);
            setTimeout(spawnMoles, spawnInterval);
        }

        // Handle controller select event (shooting)
        function onSelect(event) {
            // Get controller position and direction
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            if (!gameActive) return;

            // Check for intersections with moles
            if (!moleGroup) return;
            const intersects = raycaster.intersectObjects(moleGroup.children, true);

            if (intersects.length > 0) {
                // Find the mole group that was hit
                let moleHit = intersects[0].object;
                while (moleHit.parent && !moleHit.userData.isMole) {
                    moleHit = moleHit.parent;
                }

                if (moleHit.userData && moleHit.userData.isMole && moleHit.userData.active) {
                    hitMole(moleHit);
                }
            }
            
            // Check for power-up collection
            const powerUpIntersects = raycaster.intersectObjects(powerUpObjects, false);
            if (powerUpIntersects.length > 0) {
                collectPowerUp(powerUpIntersects[0].object);
            }
        }

        // Handle mouse click for fallback mode
        function onMouseClick(event) {
            if (!gameActive) return;

            // Calculate mouse position in normalized device coordinates (-1 to +1)
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);

            // Check for intersections with moles
            const intersects = raycaster.intersectObjects(moleGroup.children, true);

            if (intersects.length > 0) {
                // Find the mole group that was hit
                let moleHit = intersects[0].object;
                while (moleHit.parent && !moleHit.userData.isMole) {
                    moleHit = moleHit.parent;
                }

                if (moleHit.userData && moleHit.userData.isMole && moleHit.userData.active) {
                    hitMole(moleHit);
                }
            }
            
            // Check for power-up collection
            const powerUpIntersects = raycaster.intersectObjects(powerUpObjects, false);
            if (powerUpIntersects.length > 0) {
                collectPowerUp(powerUpIntersects[0].object);
            }
        }

        // Create explosion particles at a position
        function createExplosion(position) {
            const numParticles = 20;
            const particles = new THREE.Group();

            // Create particle geometries and materials
            const particleGeometry = new THREE.SphereGeometry(0.03, 8, 8);

            // Different colors for particles
            const colors = [
                0x8B4513,  // Brown (mole color)
                0xFF0000,  // Red
                0xFF6600,  // Orange
                0xFFFF00,  // Yellow
            ];

            // Create particles
            for (let i = 0; i < numParticles; i++) {
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)]
                });

                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                // Set random direction for particle
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 0.01 + Math.random() * 0.03;

                const direction = new THREE.Vector3();
                direction.x = Math.sin(phi) * Math.cos(theta);
                direction.y = Math.cos(phi);
                direction.z = Math.sin(phi) * Math.sin(theta);
                direction.multiplyScalar(speed);

                particle.position.copy(position);
                particle.userData = {
                    direction: direction,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03  // Random decay rate
                };

                particles.add(particle);
            }

            particlesGroup.add(particles);

            // Remove particles after a certain time
            setTimeout(() => {
                if (particlesGroup.children.includes(particles)) {
                    particlesGroup.remove(particles);
                }
            }, 2000);

            return particles;
        }

        // Global audio context for better performance and compatibility
        let globalAudioContext = null;

        // Initialize audio context with user interaction
        function initAudioContext() {
            if (!globalAudioContext) {
                try {
                    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    console.error("Error creating audio context:", error);
                    return false;
                }
            }

            // Resume context if suspended
            if (globalAudioContext.state === 'suspended') {
                globalAudioContext.resume().catch(error => {
                    console.error("Error resuming audio context:", error);
                });
            }

            return globalAudioContext.state === 'running' || globalAudioContext.state === 'suspended';
        }

        // Create audio elements
        function createHitSound() {
            // Create function to play hit sound
            hitSound = function () {
                if (!initAudioContext()) {
                    console.warn("Audio context not available");
                    return;
                }

                // Verify audio context is running
                if (globalAudioContext.state !== 'running') {
                    console.warn("Audio context not in running state:", globalAudioContext.state);
                    return;
                }

                try {
                    // Create oscillator
                    const oscillator = globalAudioContext.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(800, globalAudioContext.currentTime); // Start frequency
                    oscillator.frequency.exponentialRampToValueAtTime(200, globalAudioContext.currentTime + 0.2); // End frequency

                    // Create gain node for volume control
                    const gainNode = globalAudioContext.createGain();
                    gainNode.gain.setValueAtTime(0.3, globalAudioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, globalAudioContext.currentTime + 0.2);

                    // Connect and start
                    oscillator.connect(gainNode);
                    gainNode.connect(globalAudioContext.destination);

                    oscillator.start();
                    oscillator.stop(globalAudioContext.currentTime + 0.2);

                    // Clean up when done
                    oscillator.onended = () => {
                        oscillator.disconnect();
                        gainNode.disconnect();
                    };
                } catch (error) {
                    console.error("Error playing sound:", error);
                }
            };

            // Hit sound created - no background music needed
        }

        // Note: Background music code removed as it was never used
        // If background music is desired in the future, it can be re-implemented

        // Update particles in animation loop
        function updateParticles() {
            // Track particle systems to remove
            const systemsToRemove = [];

            particlesGroup.children.forEach(particleSystem => {
                let allDead = true;

                particleSystem.children.forEach(particle => {
                    // Update position based on direction
                    particle.position.add(particle.userData.direction);

                    // Apply gravity
                    particle.userData.direction.y -= 0.0005;

                    // Update life
                    particle.userData.life -= particle.userData.decay;

                    if (particle.userData.life > 0) {
                        // Scale particle based on remaining life
                        const scale = particle.userData.life;
                        particle.scale.set(scale, scale, scale);
                        allDead = false;
                    } else {
                        particle.visible = false;
                    }
                });

                if (allDead) {
                    systemsToRemove.push(particleSystem);
                }
            });

            // Remove dead particle systems from scene
            systemsToRemove.forEach(system => {
                particlesGroup.remove(system);
            });
        }

        // Handle hitting a mole
        function hitMole(mole) {
            // If game is paused, do nothing
            if (gamePaused) return;

            // Check if this is a boss
            if (mole.userData.isBoss) {
                hitBoss(mole);
                return;
            }
            
            // Handle special creature behaviors
            const behavior = mole.userData.creatureType?.behavior;
            
            // Dodge behavior - shadow mole might dodge
            if (behavior === 'dodge' && Math.random() < 0.4) {
                mole.userData.dodgeCooldown = Date.now() + 1000;
                // Dodge animation
                const dodgeDir = Math.random() > 0.5 ? 0.2 : -0.2;
                mole.position.x += dodgeDir;
                createSmokeEffect(mole.position);
                showFloatingScore(0, mole.position, null); // Miss indicator
                return;
            }
            
            // Armored creatures need multiple hits
            if (behavior === 'armored' || mole.userData.health > 1) {
                mole.userData.health = (mole.userData.health || 1) - currentWeapon.damage;
                if (mole.userData.health > 0) {
                    // Flash but don't kill
                    mole.traverse(child => {
                        if (child.material) {
                            const orig = child.material.color.getHex();
                            child.material.color.setHex(0xFFFFFF);
                            setTimeout(() => child.material.color.setHex(orig), 100);
                        }
                    });
                    triggerHitEffect(mole.position.clone(), 0x708090, 0.5);
                    playHitSound('armoredGopher');
                    return;
                }
            }
            
            // Mimic creature - penalty!
            if (behavior === 'mimic') {
                triggerDamageVignette();
                score = Math.max(0, score - 5);
                showFloatingScore(-5, mole.position.clone(), null);
                updateScoreSign(scoreSign, score);
            }

            // Mark as inactive and hit
            mole.userData.active = false;
            mole.userData.wasHit = true;

            // Create explosion effect at mole position
            const explosionPos = new THREE.Vector3().copy(mole.position);
            explosionPos.y += 0.1;

            // === VISUAL EFFECTS ===
            const creatureColor = mole.userData.creatureType?.color || 0xA06630;
            const intensity = (mole.userData.pointValue || 1) * 0.5;
            triggerHitEffect(explosionPos, creatureColor, intensity);
            triggerComboFire(explosionPos);
            
            // Trigger slow motion on high-value hits
            if (mole.userData.pointValue >= 5 || combo >= 10) {
                triggerSlowMotion(300, 0.3);
            }
            
            // Swing weapon
            swingWeapon(explosionPos);
            
            createExplosion(explosionPos);

            // Play hit sound with creature-specific pitch
            playHitSound(mole.userData.creatureType?.type);

            // Remove the mole immediately
            moleGroup.remove(mole);
            activeMoles = activeMoles.filter(m => m !== mole);

            // Also remove the hole with animation
            if (mole.userData.holeRef && floorGroup.children.includes(mole.userData.holeRef)) {
                animateHoleDisappear(mole.userData.holeRef);
            }

            // === COMBO SYSTEM ===
            combo++;
            if (combo > maxCombo) maxCombo = combo;
            updateComboDisplay();
            
            // Reset combo timer
            if (comboTimer) clearTimeout(comboTimer);
            comboTimer = setTimeout(() => {
                if (combo > 0) {
                    combo = 0;
                    updateComboDisplay();
                }
            }, COMBO_TIMEOUT);

            // Calculate combo multiplier (1x, 1.5x, 2x, 2.5x, 3x max)
            const comboMultiplier = Math.min(1 + (combo - 1) * 0.5, 3);

            // Update score based on creature point value
            let pointsAwarded = mole.userData.pointValue || 1;
            
            // Skip points for mimic (already penalized)
            if (behavior === 'mimic') pointsAwarded = 0;
            
            // Apply weapon damage bonus
            pointsAwarded *= currentWeapon.damage;
            
            // Apply double points power-up
            if (activePowerUps.some(p => p.type === 'doublePoints')) {
                pointsAwarded *= 2;
            }
            
            // Apply combo multiplier
            pointsAwarded = Math.floor(pointsAwarded * comboMultiplier);
            
            // Add coins
            playerCoins += Math.ceil(pointsAwarded / 2);
            
            score += pointsAwarded;
            levelScore += pointsAwarded;

            // Show floating score text with combo info
            if (pointsAwarded > 0) {
                showFloatingScore(pointsAwarded, explosionPos, combo > 1 ? combo : null);
            }

            // Update score display
            updateScoreSign(scoreSign, score);
            
            // Track hit for stats and creature gallery
            trackHit();
            if (!creaturesSeen.includes(mole.userData.creatureType?.type)) {
                creaturesSeen.push(mole.userData.creatureType?.type);
            }

            // Check for boss spawn
            if (score - lastBossScore >= BOSS_SPAWN_SCORE && !currentBoss) {
                lastBossScore = score;
                spawnBoss();
            }
            
            // Boss rush mode - spawn next boss quickly
            if (currentChallenge === 'bossrush' && !currentBoss) {
                setTimeout(() => spawnBoss(), 3000);
            }
            
            // Speed run check
            if (currentChallenge === 'speedrun' && score >= 100) {
                const time = ((Date.now() - speedrunStartTime) / 1000).toFixed(2);
                gameOver(`100 points in ${time} seconds!`);
                return;
            }

            // Check for level completion
            const levelGoal = levelGoals[Math.min(level - 1, levelGoals.length - 1)];
            if (levelScore >= levelGoal) {
                completedLevel();
            }
        }

        // Show floating score text
        function showFloatingScore(points, position, comboCount = null) {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Larger font for better visibility
            const fontSize = comboCount && comboCount >= 5 ? 72 : 56;
            ctx.font = `bold ${fontSize}px Arial`;

            // Choose color based on points or combo
            if (comboCount && comboCount >= 5) {
                ctx.fillStyle = '#FF00FF'; // Purple for high combo
            } else if (comboCount && comboCount >= 3) {
                ctx.fillStyle = '#FF6600'; // Orange for medium combo
            } else if (points >= 5) {
                ctx.fillStyle = '#FFDD00'; // Gold for high points
            } else if (points >= 3) {
                ctx.fillStyle = '#6666FF'; // Blue for 3 points
            } else if (points >= 2) {
                ctx.fillStyle = '#FF6666'; // Red for 2 points
            } else {
                ctx.fillStyle = '#FFFFFF'; // White for 1 point
            }

            // Add glow effect
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Draw text with combo info
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const text = comboCount ? `+${points} x${comboCount}` : `+${points}`;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            // Create texture and sprite
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);

            // Position sprite
            sprite.position.copy(position);
            sprite.position.y += 0.15;
            const baseScale = comboCount && comboCount >= 5 ? 0.5 : 0.35;
            sprite.scale.set(baseScale, baseScale * 0.5, 1);

            scene.add(sprite);

            // Animate with bounce and scale
            const startTime = Date.now();
            const duration = 1200;
            const startY = sprite.position.y;
            let removed = false;
            
            function cleanup() {
                if (removed) return;
                removed = true;
                scene.remove(sprite);
                sprite.material.dispose();
                texture.dispose();
            }

            function animateScore() {
                if (removed) return;
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Bounce up with easing
                const bounce = Math.sin(progress * Math.PI) * 0.3;
                sprite.position.y = startY + progress * 0.2 + bounce;

                // Scale pop effect at start
                const scalePop = progress < 0.1 ? 1 + (1 - progress / 0.1) * 0.3 : 1;
                sprite.scale.set(baseScale * scalePop, baseScale * 0.5 * scalePop, 1);

                // Fade out in last 40%
                sprite.material.opacity = progress > 0.6 ? 1 - (progress - 0.6) / 0.4 : 1;

                if (progress < 1) {
                    requestAnimationFrame(animateScore);
                } else {
                    cleanup();
                }
            }
            
            // Fallback cleanup in case animation doesn't complete
            setTimeout(cleanup, duration + 500);

            animateScore();
        }

        // Show penalty effect when creatures are missed
        function showPenaltyEffect(penalty, position) {
            // Create canvas for text
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Set text properties
            ctx.font = 'bold 48px Arial';
            ctx.fillStyle = '#FF3333'; // Red for penalty

            // Add glow/shadow for better visibility
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Draw penalty text
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`-${penalty}`, canvas.width / 2, canvas.height / 2);

            // Create texture and sprite
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);

            // Position sprite
            sprite.position.copy(position);
            sprite.position.y += 0.15; // Position above the mole
            sprite.scale.set(0.3, 0.15, 1);

            scene.add(sprite);

            // Animate sprite sinking and fading (opposite of score)
            const startTime = Date.now();
            const duration = 1000; // 1 second

            function animatePenalty() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Move downward (opposite of score)
                sprite.position.y -= 0.002;

                // Fade out
                sprite.material.opacity = 1 - progress;

                if (progress < 1) {
                    requestAnimationFrame(animatePenalty);
                } else {
                    // Remove sprite when animation completes
                    scene.remove(sprite);
                    sprite.material.dispose();
                    texture.dispose();
                }
            }

            animatePenalty();
        }

        // Complete the current level
        // Level completion state
        let levelEnding = false;
        
        function completedLevel() {
            // Stop spawning new creatures but let player clear existing ones
            levelEnding = true;
            gamePaused = false; // Keep game active so player can still hit
            
            // Save progress and check achievements
            saveProgress();
            checkAchievements();
            
            // Check periodically if all creatures are cleared
            function checkCleared() {
                if (activeMoles.length === 0 && (!currentBoss || !currentBoss.userData.active)) {
                    // All cleared - now end the level
                    levelEnding = false;
                    gameActive = false;
                    gamePaused = true;
                    
                    // Trigger celebration effect
                    triggerCelebration(new THREE.Vector3(0, 1, 0));
                    
                    // Show level complete UI
                    setTimeout(() => {
                        createLevelCompleteUI();
                    }, 800);
                } else {
                    // Still creatures remaining, check again
                    setTimeout(checkCleared, 200);
                }
            }
            
            // Start checking after a brief delay
            setTimeout(checkCleared, 300);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Main render loop
        function render(timestamp, frame) {
            // Apply slow motion
            const deltaMultiplier = slowMotion.active ? slowMotion.factor : 1;
            
            // Update particle animations
            updateParticles();
            
            // Update creature animations
            updateCreatureAnimations();
            
            // Update creature behaviors (new AI)
            updateCreatureBehaviors();
            
            // Update environment particles
            updateEnvironmentParticles();
            
            // Update power-ups
            updatePowerUps();

            // Update visual enhancements
            updateVisualEnhancements();
            
            // Update background decorations
            updateBackgroundDecorations();
            
            // Update music system
            updateMusic();

            // Render scene with bloom (desktop) or standard (XR)
            if (composer && !renderer.xr.isPresenting) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // === PHASE 1: COMBO SYSTEM FUNCTIONS ===
        function updateComboDisplay() {
            if (!comboDisplay) return;
            
            if (combo >= 2) {
                const multiplier = Math.min(1 + (combo - 1) * 0.5, 3);
                comboDisplay.textContent = `ðŸ”¥ ${combo}x COMBO! (${multiplier.toFixed(1)}x points)`;
                comboDisplay.style.opacity = '1';
                comboDisplay.style.transform = 'scale(1.1)';
                setTimeout(() => comboDisplay.style.transform = 'scale(1)', 100);
                
                // Change color based on combo level
                if (combo >= 10) {
                    comboDisplay.style.color = '#FF00FF';
                    comboDisplay.style.textShadow = '0 0 20px #FF00FF';
                } else if (combo >= 5) {
                    comboDisplay.style.color = '#FF6600';
                    comboDisplay.style.textShadow = '0 0 15px #FF6600';
                } else {
                    comboDisplay.style.color = '#FFD700';
                    comboDisplay.style.textShadow = '0 0 10px #FF6600';
                }
            } else {
                comboDisplay.style.opacity = '0';
            }
        }

        function resetCombo() {
            combo = 0;
            updateComboDisplay();
            if (comboTimer) {
                clearTimeout(comboTimer);
                comboTimer = null;
            }
        }

        // === PHASE 1: ENHANCED AUDIO ===
        function playHitSound(creatureType) {
            if (!initAudioContext()) return;
            if (globalAudioContext.state !== 'running') return;

            try {
                const oscillator = globalAudioContext.createOscillator();
                const gainNode = globalAudioContext.createGain();
                
                // Different sounds per creature type
                let freq = 800, endFreq = 200, duration = 0.2;
                switch (creatureType) {
                    case 'mole': freq = 600; endFreq = 200; break;
                    case 'redGopher': freq = 900; endFreq = 300; break;
                    case 'blueRabbit': freq = 1100; endFreq = 400; break;
                    case 'goldenMole': freq = 1400; endFreq = 600; duration = 0.3; break;
                }
                
                // Add combo bonus sound
                if (combo >= 3) {
                    freq += combo * 50;
                    playComboSound();
                }
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, globalAudioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(endFreq, globalAudioContext.currentTime + duration);
                
                gainNode.gain.setValueAtTime(0.3, globalAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, globalAudioContext.currentTime + duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(globalAudioContext.destination);
                oscillator.start();
                oscillator.stop(globalAudioContext.currentTime + duration);
            } catch (e) { console.error('Audio error:', e); }
        }

        function playComboSound() {
            if (!globalAudioContext || globalAudioContext.state !== 'running') return;
            try {
                const osc = globalAudioContext.createOscillator();
                const gain = globalAudioContext.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200 + combo * 100, globalAudioContext.currentTime);
                gain.gain.setValueAtTime(0.15, globalAudioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, globalAudioContext.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(globalAudioContext.destination);
                osc.start();
                osc.stop(globalAudioContext.currentTime + 0.1);
            } catch (e) {}
        }

        function playPowerUpSound() {
            if (!globalAudioContext || globalAudioContext.state !== 'running') return;
            try {
                const osc = globalAudioContext.createOscillator();
                const gain = globalAudioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, globalAudioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, globalAudioContext.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, globalAudioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, globalAudioContext.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(globalAudioContext.destination);
                osc.start();
                osc.stop(globalAudioContext.currentTime + 0.3);
            } catch (e) {}
        }

        function playBossSound() {
            if (!globalAudioContext || globalAudioContext.state !== 'running') return;
            try {
                const osc = globalAudioContext.createOscillator();
                const gain = globalAudioContext.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, globalAudioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, globalAudioContext.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, globalAudioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, globalAudioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(globalAudioContext.destination);
                osc.start();
                osc.stop(globalAudioContext.currentTime + 0.5);
            } catch (e) {}
        }

        // === PHASE 1: CREATURE ANIMATIONS ===
        function updateCreatureAnimations() {
            const time = Date.now() * 0.001;
            
            activeMoles.forEach(mole => {
                if (!mole.userData.active) return;
                
                // Animate ears (if present)
                mole.traverse(child => {
                    if (child.userData?.isEar) {
                        child.rotation.z = child.userData.baseRotZ + Math.sin(time * 8) * 0.1;
                    }
                    // Animate tail
                    if (child.userData?.isTail) {
                        child.rotation.x = child.userData.baseRotX + Math.sin(time * 10) * 0.2;
                    }
                    // Animate glow aura
                    if (child.userData?.isGlow) {
                        child.material.opacity = 0.2 + Math.sin(time * 4) * 0.15;
                        child.scale.setScalar(1 + Math.sin(time * 3) * 0.1);
                    }
                });
                
                // Subtle body bob
                if (mole.position.y >= -0.05) {
                    mole.children[0].position.y = 0.06 + Math.sin(time * 6) * 0.01;
                }
            });
        }

        // === PHASE 2: BIOME SYSTEM ===
        function initBiome() {
            biomeGroup = new THREE.Group();
            scene.add(biomeGroup);
            setBiome(0);
        }

        function setBiome(index) {
            currentBiome = index % biomesExpanded.length;
            const biome = biomesExpanded[currentBiome];
            
            // Update floor color (with safety check)
            if (floorGroup && floorGroup.children) {
                floorGroup.children.forEach(child => {
                    if (child.material && !child.userData?.isHole) {
                        child.material.color.setHex(biome.groundColor);
                    }
                });
            }
            
            // Update ambient light
            if (scene && scene.children) {
                scene.children.forEach(child => {
                    if (child.isAmbientLight) {
                        child.color.setHex(biome.ambient);
                    }
                });
            }
            
            // Update sky colors
            if (skyMesh && skyMesh.material && skyMesh.material.uniforms) {
                skyMesh.material.uniforms.topColor.value.setHex(biome.skyTop);
                skyMesh.material.uniforms.midColor.value.lerp(new THREE.Color(biome.skyBottom), 0.5);
            }
            
            // Update visual enhancements for biome
            updateBiomeVisuals();
            
            // Clear old environment particles
            if (biomeGroup) {
                environmentParticles.forEach(p => biomeGroup.remove(p));
            }
            environmentParticles = [];
            
            // Create new environment particles
            createEnvironmentParticles(biome);
            
            // Show biome notification
            showBiomeNotification(biome.name);
        }

        function createEnvironmentParticles(biome) {
            const particleCount = 30;
            const geometry = new THREE.SphereGeometry(0.02, 4, 4);
            const material = new THREE.MeshBasicMaterial({ 
                color: biome.particle || biome.particleColor || 0xFFFFFF, 
                transparent: true, 
                opacity: 0.6 
            });
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(geometry, material.clone());
                particle.position.set(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 4
                );
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.01,
                        -0.005 - Math.random() * 0.01,
                        (Math.random() - 0.5) * 0.01
                    ),
                    startY: particle.position.y
                };
                biomeGroup.add(particle);
                environmentParticles.push(particle);
            }
        }

        function updateEnvironmentParticles() {
            environmentParticles.forEach(p => {
                p.position.add(p.userData.velocity);
                
                // Reset particle when it falls below ground
                if (p.position.y < 0) {
                    p.position.y = 2;
                    p.position.x = (Math.random() - 0.5) * 4;
                    p.position.z = (Math.random() - 0.5) * 4;
                }
            });
        }

        function showBiomeNotification(biomeName) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute; top: 120px; width: 100%; text-align: center;
                color: white; font-size: 20px; font-family: Arial; font-weight: bold;
                text-shadow: 0 0 10px black; pointer-events: none;
                opacity: 0; transition: opacity 0.5s;
            `;
            notification.textContent = `ðŸŒ ${biomeName} Biome`;
            document.body.appendChild(notification);
            
            setTimeout(() => notification.style.opacity = '1', 50);
            setTimeout(() => notification.style.opacity = '0', 2500);
            setTimeout(() => document.body.removeChild(notification), 3000);
        }

        // === PHASE 2: POWER-UP SYSTEM ===
        function startPowerUpSpawning() {
            if (powerUpSpawnTimer) clearInterval(powerUpSpawnTimer);
            powerUpSpawnTimer = setInterval(() => {
                if (gameActive && !gamePaused && Math.random() < 0.3) {
                    spawnPowerUp();
                }
            }, 8000);
        }

        function spawnPowerUp() {
            const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            const position = holePositions[Math.floor(Math.random() * holePositions.length)];
            
            // Check if position is occupied
            if (activeMoles.some(m => m.position.x === position.x && m.position.z === position.z)) return;
            
            const geometry = new THREE.OctahedronGeometry(0.1, 0);
            const material = new THREE.MeshBasicMaterial({ color: type.color, transparent: true, opacity: 0.8 });
            const powerUp = new THREE.Mesh(geometry, material);
            
            powerUp.position.set(position.x, 0.2, position.z);
            powerUp.userData = { isPowerUp: true, type: type.type, duration: type.duration, spawnTime: Date.now() };
            
            scene.add(powerUp);
            powerUpObjects.push(powerUp);
            
            // Remove after 5 seconds if not collected
            setTimeout(() => {
                if (powerUpObjects.includes(powerUp)) {
                    scene.remove(powerUp);
                    powerUpObjects = powerUpObjects.filter(p => p !== powerUp);
                }
            }, 5000);
        }

        function updatePowerUps() {
            const time = Date.now() * 0.003;
            
            // Animate power-up objects
            powerUpObjects.forEach(p => {
                p.rotation.y = time;
                p.rotation.x = time * 0.5;
                p.position.y = 0.2 + Math.sin(time * 2) * 0.05;
            });
            
            // Check for expired power-ups
            activePowerUps = activePowerUps.filter(p => {
                if (Date.now() > p.endTime) {
                    showPowerUpExpired(p.type);
                    return false;
                }
                return true;
            });
        }

        function collectPowerUp(powerUp) {
            playPowerUpSound();
            
            const type = powerUp.userData.type;
            const duration = powerUp.userData.duration;
            
            // Apply slow time effect
            if (type === 'slowTime') {
                moleSpeed *= 1.5;
                setTimeout(() => moleSpeed /= 1.5, duration);
            }
            
            activePowerUps.push({ type, endTime: Date.now() + duration });
            
            scene.remove(powerUp);
            powerUpObjects = powerUpObjects.filter(p => p !== powerUp);
            
            showPowerUpCollected(type);
        }

        function showPowerUpCollected(type) {
            const icons = { slowTime: 'â±ï¸ SLOW TIME!', doublePoints: 'Ã—2 DOUBLE POINTS!', multiHit: 'ðŸ’¥ MULTI-HIT!' };
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute; top: 150px; width: 100%; text-align: center;
                color: #00FF00; font-size: 24px; font-family: Arial; font-weight: bold;
                text-shadow: 0 0 15px #00FF00; pointer-events: none;
            `;
            notification.textContent = icons[type] || type;
            document.body.appendChild(notification);
            setTimeout(() => document.body.removeChild(notification), 2000);
        }

        function showPowerUpExpired(type) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute; top: 150px; width: 100%; text-align: center;
                color: #FF6666; font-size: 18px; font-family: Arial;
                text-shadow: 0 0 10px black; pointer-events: none;
            `;
            notification.textContent = `${type} expired`;
            document.body.appendChild(notification);
            setTimeout(() => document.body.removeChild(notification), 1500);
        }

        // === PHASE 2: BOSS SYSTEM ===
        const bossTypes = [
            { name: 'Demon Mole', color: 0x8B0000, health: 5, points: 20, style: 'demon' },
            { name: 'Mecha Gopher', color: 0x708090, health: 7, points: 30, style: 'robot' },
            { name: 'Giant Centipede', color: 0x2F4F2F, health: 6, points: 25, style: 'centipede' },
            { name: 'Crystal Golem', color: 0x87CEEB, health: 8, points: 35, style: 'crystal' },
            { name: 'Shadow Lord', color: 0x1a1a2e, health: 6, points: 28, style: 'shadow' },
            { name: 'Candy King', color: 0xFF69B4, health: 5, points: 22, style: 'candy' }
        ];
        let bossesDefeatedThisGame = 0;

        function spawnBoss() {
            if (currentBoss || gamePaused) return;
            
            playBossSound();
            showBossWarning();
            
            setTimeout(() => {
                if (gamePaused) return;
                
                const bossType = bossTypes[bossesDefeatedThisGame % bossTypes.length];
                const position = { x: 0, z: 0 };
                const bossGroup = new THREE.Group();
                
                switch (bossType.style) {
                    case 'robot':
                        createRobotBoss(bossGroup, bossType.color);
                        break;
                    case 'centipede':
                        createCentipedeBoss(bossGroup, bossType.color);
                        break;
                    case 'crystal':
                        createCrystalBoss(bossGroup, bossType.color);
                        break;
                    case 'shadow':
                        createShadowBoss(bossGroup, bossType.color);
                        break;
                    case 'candy':
                        createCandyBoss(bossGroup, bossType.color);
                        break;
                    default:
                        createDemonBoss(bossGroup, bossType.color);
                }
                
                bossGroup.position.set(position.x, -0.3, position.z);
                bossGroup.userData = {
                    isMole: true,
                    isBoss: true,
                    active: true,
                    health: bossType.health,
                    maxHealth: bossType.health,
                    pointValue: bossType.points,
                    bossName: bossType.name
                };
                
                currentBoss = bossGroup;
                moleGroup.add(bossGroup);
                
                // Animate boss rising
                const startY = bossGroup.position.y;
                const targetY = 0;
                const startTime = Date.now();
                function animateBossUp() {
                    const progress = Math.min((Date.now() - startTime) / 500, 1);
                    bossGroup.position.y = startY + (targetY - startY) * progress;
                    if (progress < 1) requestAnimationFrame(animateBossUp);
                }
                animateBossUp();
                
                createBossHealthBar(bossType.name);
            }, 1500);
        }

        function createDemonBoss(group, color) {
            const bodyMat = new THREE.MeshLambertMaterial({ color });
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 12), bodyMat);
            body.position.y = 0.15;
            group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 10), bodyMat);
            head.position.y = 0.4;
            group.add(head);
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            [-0.08, 0.08].forEach(x => {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
                eye.position.set(x, 0.42, 0.14);
                group.add(eye);
            });
            // Horns
            const hornMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            [-1, 1].forEach(side => {
                const horn = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.15, 6), hornMat);
                horn.position.set(side * 0.12, 0.55, 0);
                horn.rotation.z = side * -0.3;
                group.add(horn);
            });
        }

        function createRobotBoss(group, color) {
            const mat = new THREE.MeshLambertMaterial({ color });
            // Boxy body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.35, 0.3), mat);
            body.position.y = 0.2;
            group.add(body);
            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.2, 0.2), mat);
            head.position.y = 0.5;
            group.add(head);
            // Antenna
            const antenna = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.15, 6), new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
            antenna.position.set(0, 0.65, 0);
            group.add(antenna);
            // Eyes (screens)
            const screenMat = new THREE.MeshBasicMaterial({ color: 0x00FF00 });
            [-0.06, 0.06].forEach(x => {
                const eye = new THREE.Mesh(new THREE.PlaneGeometry(0.06, 0.04), screenMat);
                eye.position.set(x, 0.52, 0.11);
                group.add(eye);
            });
            // Arms
            [-1, 1].forEach(side => {
                const arm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.25, 0.08), mat);
                arm.position.set(side * 0.28, 0.15, 0);
                group.add(arm);
            });
        }

        function createCentipedeBoss(group, color) {
            const mat = new THREE.MeshLambertMaterial({ color });
            // Segmented body
            for (let i = 0; i < 6; i++) {
                const segment = new THREE.Mesh(new THREE.SphereGeometry(0.12 - i * 0.01, 10, 8), mat);
                segment.position.set(0, 0.12, -i * 0.15 + 0.3);
                group.add(segment);
                // Legs
                if (i < 5) {
                    [-1, 1].forEach(side => {
                        const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.01, 0.12, 6), mat);
                        leg.position.set(side * 0.1, 0.05, -i * 0.15 + 0.3);
                        leg.rotation.z = side * 0.5;
                        group.add(leg);
                    });
                }
            }
            // Head with mandibles
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), mat);
            head.position.set(0, 0.15, 0.45);
            group.add(head);
            // Antennae
            [-1, 1].forEach(side => {
                const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.005, 0.2, 6), mat);
                ant.position.set(side * 0.08, 0.25, 0.55);
                ant.rotation.x = -0.5;
                ant.rotation.z = side * 0.3;
                group.add(ant);
            });
        }

        function createCrystalBoss(group, color) {
            const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 });
            // Main crystal body
            const body = new THREE.Mesh(new THREE.OctahedronGeometry(0.25), mat);
            body.position.y = 0.25;
            body.rotation.y = Math.PI / 4;
            group.add(body);
            // Smaller crystals
            for (let i = 0; i < 5; i++) {
                const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(0.08 + Math.random() * 0.05), mat.clone());
                const angle = (i / 5) * Math.PI * 2;
                crystal.position.set(Math.cos(angle) * 0.25, 0.1 + Math.random() * 0.2, Math.sin(angle) * 0.25);
                crystal.rotation.set(Math.random(), Math.random(), Math.random());
                group.add(crystal);
            }
            // Glowing core
            const core = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFFFFFF }));
            core.position.y = 0.25;
            group.add(core);
        }

        function createShadowBoss(group, color) {
            const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.7 });
            // Ghostly body
            const body = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.5, 8), mat);
            body.position.y = 0.25;
            group.add(body);
            // Floating head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), mat);
            head.position.y = 0.55;
            group.add(head);
            // Glowing eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            [-0.06, 0.06].forEach(x => {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.03, 6, 6), eyeMat);
                eye.position.set(x, 0.57, 0.12);
                group.add(eye);
            });
            // Wispy tendrils
            for (let i = 0; i < 4; i++) {
                const tendril = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.005, 0.3, 6), mat.clone());
                const angle = (i / 4) * Math.PI * 2;
                tendril.position.set(Math.cos(angle) * 0.15, 0.05, Math.sin(angle) * 0.15);
                tendril.rotation.z = Math.cos(angle) * 0.5;
                tendril.rotation.x = Math.sin(angle) * 0.5;
                group.add(tendril);
            }
        }

        function createCandyBoss(group, color) {
            const mat = new THREE.MeshLambertMaterial({ color });
            // Round candy body
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 12), mat);
            body.position.y = 0.2;
            group.add(body);
            // Swirl pattern (stripes)
            const stripeMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.02, 8, 16), stripeMat);
                stripe.position.y = 0.2;
                stripe.rotation.x = Math.PI / 2;
                stripe.rotation.z = (i / 3) * Math.PI;
                group.add(stripe);
            }
            // Crown
            const crownMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const crown = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.1, 6), crownMat);
            crown.position.y = 0.5;
            group.add(crown);
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            [-0.08, 0.08].forEach(x => {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
                eye.position.set(x, 0.25, 0.22);
                group.add(eye);
            });
        }

        function showBossWarning() {
            const warning = document.createElement('div');
            warning.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                color: #FF0000; font-size: 48px; font-family: Arial; font-weight: bold;
                text-shadow: 0 0 20px #FF0000; pointer-events: none;
                animation: pulse 0.5s ease-in-out 3;
            `;
            warning.innerHTML = 'âš ï¸ BOSS INCOMING! âš ï¸';
            document.body.appendChild(warning);
            
            const style = document.createElement('style');
            style.textContent = '@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }';
            document.head.appendChild(style);
            
            setTimeout(() => {
                document.body.removeChild(warning);
                document.head.removeChild(style);
            }, 1500);
        }

        function createBossHealthBar(bossName = 'BOSS') {
            if (bossHealthBar) document.body.removeChild(bossHealthBar);
            
            bossHealthBar = document.createElement('div');
            bossHealthBar.style.cssText = `
                position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
                width: 250px; height: 20px; background: #333; border: 2px solid #666;
                border-radius: 10px; overflow: hidden;
            `;
            const fill = document.createElement('div');
            fill.id = 'bossHealthFill';
            fill.style.cssText = 'width: 100%; height: 100%; background: linear-gradient(90deg, #FF0000, #FF6600); transition: width 0.2s;';
            bossHealthBar.appendChild(fill);
            
            const label = document.createElement('div');
            label.style.cssText = 'position: absolute; top: -25px; width: 100%; text-align: center; color: #FF0000; font-weight: bold; font-size: 14px;';
            label.textContent = `ðŸ‘¹ ${bossName}`;
            bossHealthBar.appendChild(label);
            
            document.body.appendChild(bossHealthBar);
        }

        function hitBoss(boss) {
            boss.userData.health--;
            
            // Update health bar
            const fill = document.getElementById('bossHealthFill');
            if (fill) {
                fill.style.width = `${(boss.userData.health / boss.userData.maxHealth) * 100}%`;
            }
            
            // Flash effect
            boss.traverse(child => {
                if (child.material) {
                    const origColor = child.material.color.getHex();
                    child.material.color.setHex(0xFFFFFF);
                    setTimeout(() => child.material.color.setHex(origColor), 100);
                }
            });
            
            // Screen shake on boss hit
            screenShake.intensity = 0.03;
            triggerHitEffect(boss.position.clone().add(new THREE.Vector3(0, 0.2, 0)), 0xFFD700, 2);
            
            playHitSound('goldenMole');
            
            if (boss.userData.health <= 0) {
                defeatBoss(boss);
            }
        }

        function defeatBoss(boss) {
            // Big screen shake
            screenShake.intensity = 0.08;
            
            // Big explosion
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const pos = boss.position.clone();
                    pos.x += (Math.random() - 0.5) * 0.3;
                    pos.z += (Math.random() - 0.5) * 0.3;
                    pos.y += Math.random() * 0.3;
                    createExplosion(pos);
                    triggerHitEffect(pos, 0xFFD700, 3);
                }, i * 100);
            }
            
            // Celebration confetti
            triggerCelebration(boss.position.clone().add(new THREE.Vector3(0, 0.5, 0)));
            
            // Award points and coins
            const points = boss.userData.pointValue;
            score += points;
            levelScore += points;
            playerCoins += points * 2; // Bosses give extra coins
            showFloatingScore(points, boss.position, null);
            updateScoreSign(scoreSign, score);
            
            // Track this game's boss defeats
            bossesDefeatedThisGame++;
            
            // Remove boss
            moleGroup.remove(boss);
            currentBoss = null;
            
            // Remove health bar
            if (bossHealthBar) {
                document.body.removeChild(bossHealthBar);
                bossHealthBar = null;
            }
            
            // Change biome after boss defeat
            setBiome(currentBiome + 1);
            
            // Show victory message with boss name
            const bossName = boss.userData.bossName || 'BOSS';
            const victory = document.createElement('div');
            victory.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                color: #FFD700; font-size: 32px; font-family: Arial; font-weight: bold;
                text-shadow: 0 0 20px #FFD700; pointer-events: none; text-align: center;
            `;
            victory.innerHTML = `ðŸ† ${bossName} DEFEATED!<br>+${points} points`;
            document.body.appendChild(victory);
            setTimeout(() => document.body.removeChild(victory), 2500);
            
            // Track boss defeats for achievements
            const bossesDefeated = parseInt(localStorage.getItem('bossesDefeated') || '0') + 1;
            localStorage.setItem('bossesDefeated', bossesDefeated);
            
            // In endless mode, schedule next boss sooner (every 15 points after first)
            if (gameMode === 'endless') {
                lastBossScore = score; // Reset the counter
            }
            checkAchievements();
        }

        // === PHASE 3: CHAOS EVENTS ===
        function startChaosEventTimer() {
            if (chaosEventTimer) clearInterval(chaosEventTimer);
            chaosEventTimer = setInterval(() => {
                if (gameActive && !gamePaused && !activeChaosEvent && Math.random() < 0.4) {
                    triggerChaosEvent();
                }
            }, CHAOS_SPAWN_INTERVAL);
        }

        function triggerChaosEvent() {
            const event = chaosEvents[Math.floor(Math.random() * chaosEvents.length)];
            activeChaosEvent = event;
            
            showChaosNotification(event);
            applyChaosEffect(event);
            
            setTimeout(() => {
                removeChaosEffect(event);
                activeChaosEvent = null;
            }, event.duration);
        }

        function showChaosNotification(event) {
            const notification = document.createElement('div');
            notification.id = 'chaosNotification';
            notification.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                color: #FF00FF; font-size: 32px; font-family: Arial; font-weight: bold;
                text-shadow: 0 0 20px #FF00FF; pointer-events: none;
                animation: chaosFlash 0.3s ease-in-out 3;
            `;
            notification.innerHTML = `${event.icon} ${event.name}! ${event.icon}`;
            document.body.appendChild(notification);
            
            // Add animation style
            const style = document.createElement('style');
            style.id = 'chaosStyle';
            style.textContent = '@keyframes chaosFlash { 0%,100% { opacity:1; transform:translate(-50%,-50%) scale(1); } 50% { opacity:0.5; transform:translate(-50%,-50%) scale(1.2); } }';
            document.head.appendChild(style);
            
            setTimeout(() => {
                if (document.getElementById('chaosNotification')) document.body.removeChild(notification);
                if (document.getElementById('chaosStyle')) document.head.removeChild(style);
            }, 2000);
        }

        function applyChaosEffect(event) {
            switch (event.effect) {
                case 'speed':
                    moleSpeed *= event.multiplier;
                    break;
                case 'size':
                    activeMoles.forEach(m => m.scale.multiplyScalar(event.multiplier));
                    break;
                case 'rainbow':
                    activeMoles.forEach(m => {
                        m.traverse(child => {
                            if (child.material && !child.userData?.isEye) {
                                child.userData.originalColor = child.material.color.getHex();
                            }
                        });
                    });
                    break;
            }
        }

        function removeChaosEffect(event) {
            switch (event.effect) {
                case 'speed':
                    moleSpeed /= event.multiplier;
                    break;
                case 'size':
                    activeMoles.forEach(m => m.scale.multiplyScalar(1 / event.multiplier));
                    break;
            }
            showNotification('Chaos event ended', '#888888');
        }

        // === PHASE 3: PERSISTENT PROGRESSION ===
        function loadProgress() {
            highScore = parseInt(localStorage.getItem('highScore') || '0');
            totalHits = parseInt(localStorage.getItem('totalHits') || '0');
            totalMisses = parseInt(localStorage.getItem('totalMisses') || '0');
            gamesPlayed = parseInt(localStorage.getItem('gamesPlayed') || '0');
            achievements = JSON.parse(localStorage.getItem('achievements') || '[]');
            playerCoins = parseInt(localStorage.getItem('playerCoins') || '0');
            unlockedWeapons = JSON.parse(localStorage.getItem('unlockedWeapons') || '["hammer"]');
            creaturesSeen = JSON.parse(localStorage.getItem('creaturesSeen') || '[]');
            
            const savedSettings = localStorage.getItem('settings');
            if (savedSettings) settings = { ...settings, ...JSON.parse(savedSettings) };
        }

        function saveProgress() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                showNotification('ðŸ† NEW HIGH SCORE!', '#FFD700');
            }
            localStorage.setItem('totalHits', totalHits);
            localStorage.setItem('totalMisses', totalMisses);
            localStorage.setItem('gamesPlayed', gamesPlayed);
            localStorage.setItem('achievements', JSON.stringify(achievements));
            localStorage.setItem('settings', JSON.stringify(settings));
            localStorage.setItem('playerCoins', playerCoins);
            localStorage.setItem('unlockedWeapons', JSON.stringify(unlockedWeapons));
            localStorage.setItem('creaturesSeen', JSON.stringify(creaturesSeen));
        }

        function checkAchievements() {
            ACHIEVEMENTS.forEach(ach => {
                if (!achievements.includes(ach.id) && ach.condition()) {
                    achievements.push(ach.id);
                    showAchievement(ach);
                    triggerCelebration(new THREE.Vector3(0, 1.5, -1));
                    saveProgress();
                }
            });
        }

        function showAchievement(ach) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute; top: 180px; left: 50%; transform: translateX(-50%);
                background: linear-gradient(135deg, #FFD700, #FFA500); color: #000;
                padding: 15px 25px; border-radius: 10px; font-family: Arial;
                font-weight: bold; text-align: center; z-index: 200;
                box-shadow: 0 0 20px rgba(255,215,0,0.8);
            `;
            notification.innerHTML = `ðŸ… Achievement Unlocked!<br><span style="font-size:14px">${ach.name}: ${ach.desc}</span>`;
            document.body.appendChild(notification);
            setTimeout(() => document.body.removeChild(notification), 4000);
        }

        function showNotification(text, color) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute; top: 200px; width: 100%; text-align: center;
                color: ${color}; font-size: 18px; font-family: Arial; font-weight: bold;
                text-shadow: 0 0 10px black; pointer-events: none;
            `;
            notification.textContent = text;
            document.body.appendChild(notification);
            setTimeout(() => document.body.removeChild(notification), 2000);
        }

        // === PHASE 3: SETTINGS MENU ===
        function createSettingsButton() {
            const btn = document.createElement('button');
            btn.id = 'settingsBtn';
            btn.textContent = 'âš™ï¸';
            btn.style.cssText = `
                position: absolute; top: 10px; right: 10px; width: 40px; height: 40px;
                font-size: 24px; border: none; border-radius: 50%; cursor: pointer;
                background: rgba(0,0,0,0.5); color: white; z-index: 100;
            `;
            btn.onclick = toggleSettingsMenu;
            document.body.appendChild(btn);
        }

        function toggleSettingsMenu() {
            if (settingsMenu) {
                document.body.removeChild(settingsMenu);
                settingsMenu = null;
                gamePaused = false;
                return;
            }
            
            gamePaused = true;
            settingsMenu = document.createElement('div');
            settingsMenu.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9); color: white; padding: 30px;
                border-radius: 15px; font-family: Arial; min-width: 300px; z-index: 300;
            `;
            
            settingsMenu.innerHTML = `
                <h2 style="text-align:center;margin-top:0">âš™ï¸ Settings</h2>
                <div style="margin:15px 0">
                    <label>ðŸ”Š SFX Volume: <span id="sfxVal">${Math.round(settings.sfxVolume*100)}%</span></label><br>
                    <input type="range" id="sfxSlider" min="0" max="100" value="${settings.sfxVolume*100}" style="width:100%">
                </div>
                <div style="margin:15px 0">
                    <label>ðŸŒ Starting Biome:</label><br>
                    <select id="biomeSelect" style="width:100%;padding:5px;margin-top:5px">
                        <option value="random" ${settings.selectedBiome==='random'?'selected':''}>Random</option>
                        ${biomesExpanded.map((b,i) => `<option value="${i}" ${settings.selectedBiome==i?'selected':''}>${b.name}</option>`).join('')}
                    </select>
                </div>
                <div style="margin:15px 0">
                    <label>âœ¨ Particle Quality:</label><br>
                    <select id="qualitySelect" style="width:100%;padding:5px;margin-top:5px">
                        <option value="low" ${settings.particleQuality==='low'?'selected':''}>Low</option>
                        <option value="medium" ${settings.particleQuality==='medium'?'selected':''}>Medium</option>
                        <option value="high" ${settings.particleQuality==='high'?'selected':''}>High</option>
                    </select>
                </div>
                <hr style="border-color:#444">
                <div style="text-align:center;margin-top:15px">
                    <p>ðŸ† High Score: ${highScore}</p>
                    <p>ðŸŽ¯ Total Hits: ${totalHits} | Misses: ${totalMisses}</p>
                    <p>ðŸŽ® Games Played: ${gamesPlayed}</p>
                    <p>ðŸ… Achievements: ${achievements.length}/${ACHIEVEMENTS.length}</p>
                </div>
                <button id="closeSettings" style="width:100%;padding:10px;margin-top:15px;cursor:pointer;background:#4CAF50;border:none;color:white;border-radius:5px;font-size:16px">Close</button>
            `;
            
            document.body.appendChild(settingsMenu);
            
            document.getElementById('sfxSlider').oninput = (e) => {
                settings.sfxVolume = e.target.value / 100;
                document.getElementById('sfxVal').textContent = e.target.value + '%';
                saveProgress();
            };
            document.getElementById('biomeSelect').onchange = (e) => {
                settings.selectedBiome = e.target.value;
                saveProgress();
            };
            document.getElementById('qualitySelect').onchange = (e) => {
                settings.particleQuality = e.target.value;
                saveProgress();
            };
            document.getElementById('closeSettings').onclick = toggleSettingsMenu;
        }

        // === PHASE 4: GAME MODE SELECTION ===
        function createGameModeMenu() {
            const menu = document.createElement('div');
            menu.id = 'gameModeMenu';
            menu.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.95); color: white; padding: 30px;
                border-radius: 15px; font-family: Arial; text-align: center; z-index: 200;
                max-height: 90vh; overflow-y: auto;
            `;
            menu.innerHTML = `
                <h2 style="color:#FFD700;margin-top:0">ðŸŽ® WHACK-A-MOLE</h2>
                <p style="color:#888">ðŸ’° Coins: ${playerCoins}</p>
                
                <h3 style="color:#4CAF50;margin-bottom:10px">Game Modes</h3>
                <div style="display:flex;flex-wrap:wrap;justify-content:center;gap:10px">
                    <button class="modeBtn" data-mode="endless" style="width:140px;padding:12px;font-size:14px;cursor:pointer;background:#4CAF50;border:none;color:white;border-radius:8px">
                        â™¾ï¸ Endless<br><small>Classic mode</small>
                    </button>
                    <button class="modeBtn" data-mode="timed" style="width:140px;padding:12px;font-size:14px;cursor:pointer;background:#2196F3;border:none;color:white;border-radius:8px">
                        â±ï¸ Time Attack<br><small>60 seconds</small>
                    </button>
                    <button class="modeBtn" data-mode="survival" style="width:140px;padding:12px;font-size:14px;cursor:pointer;background:#f44336;border:none;color:white;border-radius:8px">
                        â¤ï¸ Survival<br><small>3 lives only</small>
                    </button>
                    <button class="modeBtn" data-mode="speedrun" style="width:140px;padding:12px;font-size:14px;cursor:pointer;background:#FF9800;border:none;color:white;border-radius:8px">
                        ðŸƒ Speed Run<br><small>100 pts fastest</small>
                    </button>
                    <button class="modeBtn" data-mode="precision" style="width:140px;padding:12px;font-size:14px;cursor:pointer;background:#9C27B0;border:none;color:white;border-radius:8px">
                        ðŸŽ¯ Precision<br><small>Golden only</small>
                    </button>
                    <button class="modeBtn" data-mode="bossrush" style="width:140px;padding:12px;font-size:14px;cursor:pointer;background:#E91E63;border:none;color:white;border-radius:8px">
                        ðŸ‘‘ Boss Rush<br><small>Boss after boss</small>
                    </button>
                </div>
                
                <h3 style="color:#FFD700;margin:20px 0 10px">ðŸ”¨ Weapons</h3>
                <div id="weaponShop" style="display:flex;flex-wrap:wrap;justify-content:center;gap:8px">
                </div>
                
                <h3 style="color:#87CEEB;margin:20px 0 10px">ðŸ“Š Stats</h3>
                <p style="font-size:12px;color:#aaa">
                    ðŸ† High Score: ${highScore} | ðŸŽ¯ Accuracy: ${getAccuracy()}%<br>
                    ðŸ‘¾ Creatures Seen: ${creaturesSeen.length}/15 | ðŸŽ® Games: ${gamesPlayed}
                </p>
            `;
            document.body.appendChild(menu);
            
            // Populate weapon shop
            const shop = document.getElementById('weaponShop');
            weapons.forEach(w => {
                const owned = unlockedWeapons.includes(w.id);
                const canBuy = playerCoins >= (w.cost || 0);
                const isEquipped = currentWeapon.id === w.id;
                
                const btn = document.createElement('button');
                btn.style.cssText = `
                    width:100px;padding:8px;font-size:11px;cursor:pointer;
                    background:${isEquipped ? '#FFD700' : owned ? '#4CAF50' : canBuy ? '#2196F3' : '#666'};
                    border:none;color:${isEquipped ? '#000' : 'white'};border-radius:6px;
                `;
                btn.innerHTML = `
                    ${w.name}<br>
                    <small>${owned ? (isEquipped ? 'âœ“ Equipped' : 'Click to equip') : `ðŸ’° ${w.cost}`}</small>
                `;
                btn.onclick = () => {
                    if (owned) {
                        currentWeapon = w;
                        createGameModeMenu(); // Refresh
                    } else if (canBuy) {
                        playerCoins -= w.cost;
                        unlockedWeapons.push(w.id);
                        currentWeapon = w;
                        saveProgress();
                        createGameModeMenu(); // Refresh
                    }
                };
                shop.appendChild(btn);
            });
            
            menu.querySelectorAll('.modeBtn').forEach(btn => {
                btn.onclick = () => {
                    gameMode = btn.dataset.mode;
                    currentChallenge = btn.dataset.mode;
                    practiceMode = false;
                    document.body.removeChild(menu);
                    startChallenge(gameMode);
                    startGame();
                };
            });
        }

        // === PHASE 4: ENHANCED STATS TRACKING ===
        function trackHit() {
            totalHits++;
            checkAchievements();
        }

        function trackMiss() {
            if (!practiceMode) totalMisses++;
        }

        function getAccuracy() {
            const total = totalHits + totalMisses;
            return total > 0 ? Math.round((totalHits / total) * 100) : 0;
        }

        // === PHASE 4: TIMED MODE ===
        function updateTimedMode() {
            if (gameMode !== 'timed' || !gameActive) return;
            
            const elapsed = Math.floor((Date.now() - levelStartTime) / 1000);
            const remaining = Math.max(0, timedModeSeconds - elapsed);
            
            timerDisplay.textContent = `â±ï¸ Time: ${remaining}s`;
            timerDisplay.style.color = remaining <= 10 ? '#FF0000' : 'white';
            
            if (remaining <= 0) {
                endTimedMode();
            }
        }

        function endTimedMode() {
            gameActive = false;
            gamePaused = true;
            saveProgress();
            
            const results = document.createElement('div');
            results.style.cssText = `
                position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9); color: white; padding: 30px;
                border-radius: 15px; font-family: Arial; text-align: center; z-index: 200;
            `;
            results.innerHTML = `
                <h2 style="color:#FFD700">â±ï¸ Time's Up!</h2>
                <p style="font-size:24px">Final Score: <span style="color:#FFD700">${score}</span></p>
                <p>Max Combo: ${maxCombo}x</p>
                <p>Accuracy: ${getAccuracy()}%</p>
                ${score > highScore ? '<p style="color:#FFD700">ðŸ† NEW HIGH SCORE!</p>' : ''}
                <button id="playAgain" style="padding:15px 30px;margin:10px;font-size:18px;cursor:pointer;background:#4CAF50;border:none;color:white;border-radius:8px">Play Again</button>
                <button id="mainMenu" style="padding:15px 30px;margin:10px;font-size:18px;cursor:pointer;background:#666;border:none;color:white;border-radius:8px">Main Menu</button>
            `;
            document.body.appendChild(results);
            
            document.getElementById('playAgain').onclick = () => {
                document.body.removeChild(results);
                startGame();
            };
            document.getElementById('mainMenu').onclick = () => {
                document.body.removeChild(results);
                createGameModeMenu();
            };
        }

        // Initialize everything
        loadProgress();
        init();
    </script>
</head>

<body>
    <div id="container"></div>
    <div id="info">Score: 0 | Level: 1</div>
    <button id="startAR" class="hidden">Start AR Game</button>
</body>

</html>
