<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack-a-Mole AR</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000; }
        #score-display { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; }
        #total-score { font-size: 2.5em; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        #timer { font-size: 1.2em; opacity: 0.9; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); margin-top: 5px; }
        #level-info {
            position: absolute; top: 20px; right: 20px; text-align: right;
            font-size: 1.2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #level-progress {
            font-size: 0.9em; opacity: 0.8; margin-top: 5px;
        }
        #high-score {
            position: absolute; bottom: 20px; left: 20px;
            font-size: 1.2em; opacity: 0.9; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 10px;
        }
        #combo-display {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            text-align: center; font-size: 2em; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            color: #FFD700; display: none;
            transition: transform 0.1s ease-out, color 0.2s ease-out;
        }
        #combo-multiplier {
            font-size: 1.5em; color: #FF6B6B;
        }
        #level-complete-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; flex-direction: column;
            justify-content: center; align-items: center; text-align: center; z-index: 2100;
        }
        #level-complete-screen h2 { font-size: 2.5em; margin-bottom: 20px; color: #4CAF50; }
        .stats { background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px; }
        .stat-row { display: flex; justify-content: space-between; margin: 10px 0; font-size: 1.2em; min-width: 300px; }
        .stat-label { font-weight: bold; }
        .stat-value { color: #4CAF50; }
        #next-level-button, #restart-button {
            padding: 15px 40px; font-size: 1.3em;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white; border: none; border-radius: 25px; cursor: pointer;
            margin-top: 20px; pointer-events: auto;
        }
        #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; flex-direction: column;
            justify-content: center; align-items: center; text-align: center; z-index: 2200;
        }
        #game-over-screen h2 { font-size: 3em; margin-bottom: 20px; color: #FFD700; }
        #game-over-screen.lost h2 { color: #FF6B6B; }
        @keyframes missAnim {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(1.5); }
        }
        @keyframes eventBanner {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center; z-index: 2000;
        }
        #start-screen h1 { font-size: 3em; margin-bottom: 20px; }
        #start-button {
            padding: 15px 30px; font-size: 1.3em;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white; border: none; border-radius: 25px; cursor: pointer;
            pointer-events: auto;
        }
        #error-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.9); color: white; padding: 20px;
            border-radius: 10px; z-index: 3000; display: none;
        }
        #settings-button {
            position: absolute; top: 20px; left: 20px;
            padding: 10px 20px; font-size: 1em;
            background: rgba(255,255,255,0.2); color: white;
            border: 2px solid rgba(255,255,255,0.5); border-radius: 10px;
            cursor: pointer; pointer-events: auto; z-index: 1001;
            backdrop-filter: blur(5px);
        }
        #settings-button:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
        }
        #settings-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 2300;
        }
        #settings-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px; border-radius: 15px; min-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #settings-content h2 {
            font-size: 2em; margin-bottom: 20px; text-align: center;
        }
        .setting-row {
            margin: 20px 0; display: flex; flex-direction: column;
        }
        .setting-row label {
            font-size: 1.1em; margin-bottom: 8px; font-weight: bold;
        }
        .setting-row select, .setting-row input[type="checkbox"] {
            font-size: 1em; padding: 8px; border-radius: 5px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1); color: white;
            cursor: pointer;
        }
        .setting-row select {
            width: 100%;
        }
        .setting-row select option {
            background: #764ba2; color: white;
        }
        .checkbox-container {
            display: flex; align-items: center; gap: 10px;
        }
        .checkbox-container input[type="checkbox"] {
            width: 20px; height: 20px;
        }
        #close-settings-button {
            padding: 12px 30px; font-size: 1.1em;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white; border: none; border-radius: 25px;
            cursor: pointer; margin-top: 20px; width: 100%;
        }
        #close-settings-button:hover {
            background: linear-gradient(45deg, #45a049, #3d8b40);
        }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="canvas-container"></div>
        <div id="ui-overlay">
            <button id="settings-button">‚öôÔ∏è Settings</button>
            <div id="score-display">
                <div id="total-score">0</div>
                <div id="timer">00:00</div>
            </div>
            <div id="high-score">High Score: <span id="high-score-value">0</span></div>
            <div id="level-info">
                <div id="current-level">2x Gophers</div>
                <div id="level-progress">0% Accuracy</div>
            </div>
            <div id="combo-display">
                <div id="combo-count">0 Combo</div>
                <div id="combo-multiplier">1.0x</div>
            </div>
        </div>
        <div id="start-screen">
            <h1>üéØ Whack-a-Mole AR</h1>
            <p>Hit creatures as they emerge from holes!</p>
            <button id="start-button">Start Game</button>
        </div>
        <div id="error-message">
            <h3>Error</h3>
            <p id="error-text"></p>
        </div>
        <div id="level-complete-screen">
            <h2>Level Complete!</h2>
            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Level:</span>
                    <span class="stat-value" id="completed-level">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Hits:</span>
                    <span class="stat-value" id="completed-hits">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Score:</span>
                    <span class="stat-value" id="completed-score">0</span>
                </div>
            </div>
            <button id="next-level-button">Next Level</button>
        </div>
        <div id="game-over-screen">
            <h2>üéâ All Levels Complete! üéâ</h2>
            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Final Score:</span>
                    <span class="stat-value" id="final-score">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Time:</span>
                    <span class="stat-value" id="final-time">00:00</span>
                </div>
            </div>
            <button id="restart-button">Play Again</button>
        </div>
        <div id="settings-modal">
            <div id="settings-content">
                <h2>‚öôÔ∏è Settings</h2>
                <div class="setting-row">
                    <label for="biome-select">Biome:</label>
                    <select id="biome-select">
                        <option value="random">Random</option>
                        <option value="forest">üå≤ Forest</option>
                        <option value="desert">üèúÔ∏è Desert</option>
                        <option value="arctic">‚ùÑÔ∏è Arctic</option>
                        <option value="volcanic">üåã Volcanic</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>Weather Effects:</label>
                    <div class="checkbox-container">
                        <input type="checkbox" id="weather-toggle" checked>
                        <label for="weather-toggle">Enable Weather</label>
                    </div>
                </div>
                <div class="setting-row">
                    <label>Day-Night Cycle:</label>
                    <div class="checkbox-container">
                        <input type="checkbox" id="daynight-toggle">
                        <label for="daynight-toggle">Enable Day-Night Cycle</label>
                    </div>
                </div>
                <button id="close-settings-button">Close</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
    <script>
        const DEBUG_MODE = true;
        const debug = {
            log: (...args) => DEBUG_MODE && console.log(...args),
            error: (...args) => console.error(...args)
        };

        function showError(message) {
            const errorElement = document.getElementById('error-message');
            const errorText = document.getElementById('error-text');
            if (errorElement && errorText) {
                errorText.textContent = message;
                errorElement.style.display = 'block';
            }
        }

        // Lives Manager
        class LivesManager {
            constructor() {
                this.lives = 3;
                this.maxLives = 3;
            }

            loseLife() {
                this.lives--;
                this.updateUI();
                
                if (this.lives <= 0) {
                    this.gameOver();
                }
            }

            updateUI() {
                document.getElementById('lives-count').textContent = this.lives;
            }

            gameOver() {
                debug.log('Game Over - No lives remaining');
                
                const screen = document.getElementById('game-over-screen');
                screen.classList.add('lost');
                screen.querySelector('h2').textContent = 'üíÄ Game Over üíÄ';
                
                document.getElementById('final-score').textContent = gameState.scoreManager.score;
                
                const elapsed = Math.floor((Date.now() - gameState.scoreManager.startTime) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('final-time').textContent = `${mins}:${secs}`;
                
                screen.style.display = 'flex';
                gameState.paused = true;
                
                // Audio manager pause handling removed (simplified audio system)
            }
        }

        // High Score Manager
        class HighScoreManager {
            constructor() {
                this.highScore = this.loadHighScore();
                this.updateUI();
            }

            loadHighScore() {
                const saved = localStorage.getItem('whackamole_highscore');
                return saved ? parseInt(saved) : 0;
            }

            saveHighScore(score) {
                if (score > this.highScore) {
                    this.highScore = score;
                    localStorage.setItem('whackamole_highscore', score.toString());
                    this.updateUI();
                    return true;
                }
                return false;
            }

            updateUI() {
                document.getElementById('high-score-value').textContent = this.highScore;
            }

            checkAndSave(score) {
                return this.saveHighScore(score);
            }
        }

        // Audio Manager for sound effects
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.enabled = true;
            }

            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Resume context on user interaction
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }

            playHit() {
                if (!this.enabled || !this.audioContext) return;
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                
                // Upward pitch sweep for hit
                osc.frequency.setValueAtTime(400, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.1);
            }

            playMiss() {
                if (!this.enabled || !this.audioContext) return;
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                
                // Downward pitch for miss (negative feedback)
                osc.frequency.setValueAtTime(300, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(150, this.audioContext.currentTime + 0.15);
                
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.15);
            }

            playExplosion() {
                if (!this.enabled || !this.audioContext) return;
                
                // Create explosion sound with noise
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.3);
            }

            playPowerUp() {
                if (!this.enabled || !this.audioContext) return;
                
                // Magical ascending arpeggio
                const notes = [523, 659, 784, 1047]; // C, E, G, C
                notes.forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    
                    const startTime = this.audioContext.currentTime + i * 0.08;
                    gain.gain.setValueAtTime(0.15, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                    
                    osc.start(startTime);
                    osc.stop(startTime + 0.2);
                });
            }

            playEventStart() {
                if (!this.enabled || !this.audioContext) return;
                
                // Dramatic fanfare
                const notes = [392, 523, 659, 784]; // G, C, E, G
                notes.forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.value = freq;
                    osc.type = 'square';
                    
                    const startTime = this.audioContext.currentTime + i * 0.1;
                    gain.gain.setValueAtTime(0.2, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);
                    
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            }

            playCombo() {
                if (!this.enabled || !this.audioContext) return;
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                
                // Higher pitch for combo
                osc.frequency.setValueAtTime(600, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.08);
                
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);
                
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.08);
            }

            playLevelComplete() {
                if (!this.enabled || !this.audioContext) return;
                
                // Play ascending chord
                const frequencies = [523, 659, 784]; // C, E, G
                frequencies.forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.15, this.audioContext.currentTime + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.1 + 0.3);
                    
                    osc.start(this.audioContext.currentTime + i * 0.1);
                    osc.stop(this.audioContext.currentTime + i * 0.1 + 0.3);
                });
            }

            playGameComplete() {
                if (!this.enabled || !this.audioContext) return;
                
                // Victory fanfare
                const melody = [523, 659, 784, 1047]; // C, E, G, C
                melody.forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.2, this.audioContext.currentTime + i * 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.15 + 0.4);
                    
                    osc.start(this.audioContext.currentTime + i * 0.15);
                    osc.stop(this.audioContext.currentTime + i * 0.15 + 0.4);
                });
            }

            playBossSpawn() {
                if (!this.enabled || !this.audioContext) return;
                
                // Dramatic boss spawn sound - deep rumble followed by high pitch
                const osc1 = this.audioContext.createOscillator();
                const gain1 = this.audioContext.createGain();
                
                osc1.connect(gain1);
                gain1.connect(this.audioContext.destination);
                
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(80, this.audioContext.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(40, this.audioContext.currentTime + 0.3);
                
                gain1.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gain1.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                osc1.start(this.audioContext.currentTime);
                osc1.stop(this.audioContext.currentTime + 0.3);
                
                // High pitch warning
                const osc2 = this.audioContext.createOscillator();
                const gain2 = this.audioContext.createGain();
                
                osc2.connect(gain2);
                gain2.connect(this.audioContext.destination);
                
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(800, this.audioContext.currentTime + 0.3);
                osc2.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.5);
                
                gain2.gain.setValueAtTime(0.3, this.audioContext.currentTime + 0.3);
                gain2.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                
                osc2.start(this.audioContext.currentTime + 0.3);
                osc2.stop(this.audioContext.currentTime + 0.5);
            }


        }

        // Combo Manager for tracking consecutive hits
        class ComboManager {
            constructor() {
                this.combo = 0;
                this.maxCombo = 0;
                this.comboTimeout = 3000; // 3 seconds
                this.lastHitTime = 0;
                this.multipliers = [1.0, 1.5, 2.0, 2.5, 3.0]; // 0-4+ combo
                this.comboTimer = null;
            }

            addHit() {
                this.combo++;
                if (this.combo > this.maxCombo) {
                    this.maxCombo = this.combo;
                }
                
                // Play combo sound when reaching 2+ combo
                if (this.combo >= 2 && gameState.audioManager) {
                    gameState.audioManager.playCombo();
                }
                
                this.lastHitTime = Date.now();
                this.updateUI();
                
                // Reset timer
                if (this.comboTimer) {
                    clearTimeout(this.comboTimer);
                }
                
                this.comboTimer = setTimeout(() => {
                    this.resetCombo();
                }, this.comboTimeout);
            }

            resetCombo() {
                if (this.combo > 0) {
                    debug.log('Combo broken at', this.combo);
                    
                    // Flash the combo display red when broken
                    const display = document.getElementById('combo-display');
                    if (display.style.display === 'block') {
                        display.style.color = '#ff4444';
                        setTimeout(() => {
                            display.style.color = '#FFD700';
                        }, 200);
                    }
                }
                this.combo = 0;
                this.updateUI();
                
                if (this.comboTimer) {
                    clearTimeout(this.comboTimer);
                    this.comboTimer = null;
                }
            }

            getMultiplier() {
                const index = Math.min(this.combo - 1, this.multipliers.length - 1);
                return this.combo > 0 ? this.multipliers[index] : 1.0;
            }

            updateUI() {
                const display = document.getElementById('combo-display');
                const countEl = document.getElementById('combo-count');
                const multEl = document.getElementById('combo-multiplier');
                
                if (this.combo >= 2) {
                    display.style.display = 'block';
                    countEl.textContent = `${this.combo} Combo!`;
                    multEl.textContent = `${this.getMultiplier().toFixed(1)}x`;
                    
                    // Pulse animation
                    display.style.transform = 'translateX(-50%) scale(1.2)';
                    setTimeout(() => {
                        display.style.transform = 'translateX(-50%) scale(1)';
                    }, 100);
                } else {
                    display.style.display = 'none';
                }
            }
        }

        // StreakManager for combo multipliers
        class StreakManager {
            constructor() {
                this.streak = 0;
                this.personalBest = this.loadPersonalBest();
                
                // Multiplier tiers
                this.multiplierTiers = [
                    { threshold: 5, multiplier: 1.5 },
                    { threshold: 10, multiplier: 2.0 },
                    { threshold: 15, multiplier: 3.0 },
                    { threshold: 20, multiplier: 5.0 }
                ];
                
                this.celebrationCallback = null;
            }

            loadPersonalBest() {
                const saved = localStorage.getItem('whackamole_personal_best_streak');
                return saved ? parseInt(saved) : 0;
            }

            savePersonalBest() {
                if (this.streak > this.personalBest) {
                    this.personalBest = this.streak;
                    localStorage.setItem('whackamole_personal_best_streak', this.streak.toString());
                    debug.log('New personal best streak:', this.personalBest);
                }
            }

            setCelebrationCallback(callback) {
                this.celebrationCallback = callback;
            }

            addHit() {
                this.streak++;
                this.savePersonalBest();
                this.updateUI();
                
                // Trigger celebration at 20-hit streak
                if (this.streak === 20 && this.celebrationCallback) {
                    this.celebrationCallback();
                }
            }

            resetStreak() {
                if (this.streak > 0) {
                    debug.log('Streak broken at', this.streak);
                }
                this.streak = 0;
                this.updateUI();
            }

            getMultiplier() {
                let multiplier = 1.0;
                
                for (const tier of this.multiplierTiers) {
                    if (this.streak >= tier.threshold) {
                        multiplier = tier.multiplier;
                    }
                }
                
                return multiplier;
            }

            getStreak() {
                return this.streak;
            }

            getPersonalBest() {
                return this.personalBest;
            }

            updateUI() {
                const display = document.getElementById('combo-display');
                const countEl = document.getElementById('combo-count');
                const multEl = document.getElementById('combo-multiplier');
                
                if (this.streak >= 5) {
                    display.style.display = 'block';
                    countEl.textContent = `${this.streak} Hit Streak!`;
                    multEl.textContent = `${this.getMultiplier().toFixed(1)}x`;
                    
                    // Pulse animation
                    display.style.transform = 'translateX(-50%) scale(1.2)';
                    setTimeout(() => {
                        display.style.transform = 'translateX(-50%) scale(1)';
                    }, 100);
                } else {
                    display.style.display = 'none';
                }
            }

            setBaseMultiplier(multiplier) {
                this.baseMultiplier = multiplier;
                debug.log('Base multiplier set to:', multiplier);
                this.updateUI();
            }

            getBaseMultiplier() {
                return this.baseMultiplier || 1.0;
            }

            // Override getMultiplier to include base multiplier
            getMultiplier() {
                let tierMultiplier = 1.0;
                
                for (const tier of this.multiplierTiers) {
                    if (this.streak >= tier.threshold) {
                        tierMultiplier = tier.multiplier;
                    }
                }
                
                const baseMultiplier = this.baseMultiplier || 1.0;
                return tierMultiplier * baseMultiplier;
            }
        }

        // CameraEffectsManager for dynamic camera movements
        class CameraEffectsManager {
            constructor(camera) {
                this.camera = camera;
                this.defaultFOV = camera.fov;
                this.defaultPosition = camera.position.clone();
                this.defaultRotation = camera.rotation.clone();
                
                // Effect queue
                this.activeEffects = [];
                
                // FOV limits
                this.minFOV = 50;
                this.maxFOV = 90;
                
                // Shake state
                this.shakeOffset = new THREE.Vector3();
                
                // Zoom state
                this.targetFOV = this.defaultFOV;
                this.currentFOV = this.defaultFOV;
            }

            shake(intensity, duration) {
                const effect = {
                    type: 'shake',
                    intensity: intensity,
                    duration: duration,
                    elapsed: 0
                };
                
                this.activeEffects.push(effect);
                debug.log('Camera shake effect added:', intensity, duration);
            }

            zoom(targetFOV, duration) {
                // Clamp FOV to safe range
                const clampedFOV = Math.max(this.minFOV, Math.min(this.maxFOV, targetFOV));
                
                const effect = {
                    type: 'zoom',
                    startFOV: this.camera.fov,
                    targetFOV: clampedFOV,
                    duration: duration,
                    elapsed: 0
                };
                
                this.activeEffects.push(effect);
                debug.log('Camera zoom effect added:', clampedFOV, duration);
            }

            pulse(intensity) {
                const effect = {
                    type: 'pulse',
                    intensity: intensity,
                    duration: 0.3, // Fixed duration for pulse
                    elapsed: 0
                };
                
                this.activeEffects.push(effect);
                debug.log('Camera pulse effect added:', intensity);
            }

            focusOn(position, duration) {
                const effect = {
                    type: 'focus',
                    targetPosition: position.clone(),
                    startPosition: this.camera.position.clone(),
                    duration: duration,
                    elapsed: 0
                };
                
                this.activeEffects.push(effect);
                debug.log('Camera focus effect added:', position, duration);
            }

            update(deltaTime) {
                // Reset shake offset
                this.shakeOffset.set(0, 0, 0);
                
                // Process all active effects
                for (let i = this.activeEffects.length - 1; i >= 0; i--) {
                    const effect = this.activeEffects[i];
                    effect.elapsed += deltaTime;
                    
                    const progress = Math.min(effect.elapsed / effect.duration, 1.0);
                    
                    switch (effect.type) {
                        case 'shake':
                            this.applyShake(effect, progress);
                            break;
                        case 'zoom':
                            this.applyZoom(effect, progress);
                            break;
                        case 'pulse':
                            this.applyPulse(effect, progress);
                            break;
                        case 'focus':
                            this.applyFocus(effect, progress);
                            break;
                    }
                    
                    // Remove completed effects
                    if (progress >= 1.0) {
                        this.activeEffects.splice(i, 1);
                    }
                }
                
                // Apply accumulated shake offset
                if (this.shakeOffset.length() > 0) {
                    this.camera.position.add(this.shakeOffset);
                }
                
                // Update camera
                this.camera.updateProjectionMatrix();
            }

            applyShake(effect, progress) {
                // Decay shake intensity over time
                const currentIntensity = effect.intensity * (1 - progress);
                
                // Random shake offset
                this.shakeOffset.x += (Math.random() - 0.5) * currentIntensity;
                this.shakeOffset.y += (Math.random() - 0.5) * currentIntensity;
                this.shakeOffset.z += (Math.random() - 0.5) * currentIntensity;
            }

            applyZoom(effect, progress) {
                // Smooth interpolation using easeInOutCubic
                const t = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                this.camera.fov = effect.startFOV + (effect.targetFOV - effect.startFOV) * t;
            }

            applyPulse(effect, progress) {
                // Pulse in and out using sine wave
                const pulseAmount = Math.sin(progress * Math.PI) * effect.intensity;
                
                // Apply pulse as FOV change
                const pulseFOV = this.defaultFOV + pulseAmount * 10;
                this.camera.fov = Math.max(this.minFOV, Math.min(this.maxFOV, pulseFOV));
            }

            applyFocus(effect, progress) {
                // Smooth interpolation
                const t = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                // Interpolate camera position
                this.camera.position.lerpVectors(effect.startPosition, effect.targetPosition, t);
            }

            reset() {
                // Clear all active effects
                this.activeEffects = [];
                
                // Reset camera to default state
                this.camera.fov = this.defaultFOV;
                this.camera.position.copy(this.defaultPosition);
                this.camera.rotation.copy(this.defaultRotation);
                this.camera.updateProjectionMatrix();
                
                debug.log('Camera reset to default state');
            }
        }

        // IntensityManager for progressive difficulty
        class IntensityManager {
            constructor() {
                this.gameDuration = 0; // in seconds
                this.startTime = null;
                
                // Time-based thresholds (in seconds)
                this.thresholds = [
                    { time: 120, type: 'spawnRate', value: 0.10, applied: false, name: '2-minute spawn boost' },
                    { time: 240, type: 'spawnRate', value: 0.15, applied: false, name: '4-minute spawn boost' },
                    { time: 360, type: 'chaosFrequency', value: 0.50, applied: false, name: '6-minute chaos boost' },
                    { time: 480, type: 'baseMultiplier', value: 1.5, applied: false, name: '8-minute score multiplier' }
                ];
                
                this.creatureManager = null;
                this.chaosEventManager = null;
                this.streakManager = null;
                
                this.currentSpawnRateMultiplier = 1.0;
                this.currentChaosFrequencyMultiplier = 1.0;
                this.currentBaseMultiplier = 1.0;
            }

            setCreatureManager(creatureManager) {
                this.creatureManager = creatureManager;
            }

            setChaosEventManager(chaosEventManager) {
                this.chaosEventManager = chaosEventManager;
            }

            setStreakManager(streakManager) {
                this.streakManager = streakManager;
            }

            start() {
                this.startTime = Date.now();
                this.gameDuration = 0;
                debug.log('IntensityManager started');
            }

            update(deltaTime) {
                if (!this.startTime) {
                    return;
                }
                
                this.gameDuration += deltaTime;
                this.checkThresholds();
                this.updateTimerDisplay();
            }

            checkThresholds() {
                for (const threshold of this.thresholds) {
                    if (!threshold.applied && this.gameDuration >= threshold.time) {
                        this.applyThreshold(threshold);
                        threshold.applied = true;
                    }
                }
            }

            applyThreshold(threshold) {
                debug.log('Applying intensity threshold:', threshold.name);
                
                if (threshold.type === 'spawnRate') {
                    this.currentSpawnRateMultiplier += threshold.value;
                    if (this.creatureManager) {
                        this.creatureManager.setSpawnRateMultiplier(this.currentSpawnRateMultiplier);
                    }
                } else if (threshold.type === 'chaosFrequency') {
                    this.currentChaosFrequencyMultiplier += threshold.value;
                    if (this.chaosEventManager) {
                        this.chaosEventManager.setChaosFrequencyMultiplier(this.currentChaosFrequencyMultiplier);
                    }
                } else if (threshold.type === 'baseMultiplier') {
                    this.currentBaseMultiplier = threshold.value;
                    if (this.streakManager) {
                        this.streakManager.setBaseMultiplier(this.currentBaseMultiplier);
                    }
                }
            }

            updateTimerDisplay() {
                const timerElement = document.getElementById('timer');
                if (timerElement) {
                    const mins = Math.floor(this.gameDuration / 60).toString().padStart(2, '0');
                    const secs = Math.floor(this.gameDuration % 60).toString().padStart(2, '0');
                    timerElement.textContent = `${mins}:${secs}`;
                }
            }

            getGameDuration() {
                return this.gameDuration;
            }

            getSpawnRateMultiplier() {
                return this.currentSpawnRateMultiplier;
            }

            getChaosFrequencyMultiplier() {
                return this.currentChaosFrequencyMultiplier;
            }

            getBaseMultiplier() {
                return this.currentBaseMultiplier;
            }
        }

        // Special Events Manager
        class SpecialEventsManager {
            constructor(scene) {
                this.scene = scene;
                this.events = [];
                this.activeEvent = null;
                this.lastEventTime = 0;
                this.eventInterval = 15000; // 15 seconds between events
                this.eventTypes = ['stampede', 'goldenHour', 'slowMotion', 'reverseMode'];
            }

            update(deltaTime) {
                const now = Date.now();
                
                // Trigger random events
                if (!this.activeEvent && now - this.lastEventTime > this.eventInterval && !gameState.paused) {
                    if (Math.random() < 0.8) { // 80% chance when interval passes
                        this.triggerRandomEvent();
                    }
                    this.lastEventTime = now;
                }

                // Update active event
                if (this.activeEvent) {
                    if (now - this.activeEvent.startTime > this.activeEvent.duration) {
                        this.endEvent();
                    }
                }
            }

            triggerRandomEvent() {
                const eventType = this.eventTypes[Math.floor(Math.random() * this.eventTypes.length)];
                
                if (eventType === 'stampede') {
                    this.startStampede();
                } else if (eventType === 'goldenHour') {
                    this.startGoldenHour();
                } else if (eventType === 'slowMotion') {
                    this.startSlowMotion();
                } else if (eventType === 'reverseMode') {
                    this.startReverseMode();
                }
            }

            startStampede() {
                debug.log('üêæ STAMPEDE EVENT!');
                this.activeEvent = {
                    type: 'stampede',
                    startTime: Date.now(),
                    duration: 5000
                };

                // Spawn 10 creatures rapidly
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        if (gameState.creatureManager) {
                            gameState.creatureManager.spawnCreature();
                        }
                    }, i * 200);
                }

                this.showEventBanner('üêæ STAMPEDE! üêæ');
            }

            startGoldenHour() {
                debug.log('‚ú® GOLDEN HOUR EVENT!');
                this.activeEvent = {
                    type: 'goldenHour',
                    startTime: Date.now(),
                    duration: 10000,
                    originalSpawnLogic: null
                };

                // Make all spawns golden
                if (gameState.creatureManager) {
                    this.activeEvent.originalSpawnLogic = gameState.creatureManager.spawnCreature;
                    const originalSpawn = gameState.creatureManager.spawnCreature.bind(gameState.creatureManager);
                    
                    gameState.creatureManager.spawnCreature = function() {
                        originalSpawn();
                        // Force last spawned creature to be golden
                        const lastCreature = this.creatures[this.creatures.length - 1];
                        if (lastCreature && lastCreature.type !== 'bomb') {
                            lastCreature.type = 'golden';
                        }
                    };
                }

                this.showEventBanner('‚ú® GOLDEN HOUR! ‚ú®');
            }

            startSlowMotion() {
                debug.log('üêå SLOW MOTION EVENT!');
                this.activeEvent = {
                    type: 'slowMotion',
                    startTime: Date.now(),
                    duration: 5000
                };

                // Slow down all creatures
                if (gameState.creatureManager) {
                    gameState.creatureManager.freezeMultiplier = 0.3;
                }

                this.showEventBanner('üêå SLOW MOTION! üêå');
            }

            startReverseMode() {
                debug.log('üîÑ REVERSE MODE EVENT!');
                this.activeEvent = {
                    type: 'reverseMode',
                    startTime: Date.now(),
                    duration: 8000
                };

                this.showEventBanner('üîÑ REVERSE MODE! Hit bombs! üîÑ');
            }

            endEvent() {
                debug.log('Event ended:', this.activeEvent.type);

                if (this.activeEvent.type === 'goldenHour' && this.activeEvent.originalSpawnLogic) {
                    gameState.creatureManager.spawnCreature = this.activeEvent.originalSpawnLogic;
                } else if (this.activeEvent.type === 'slowMotion') {
                    if (gameState.creatureManager) {
                        gameState.creatureManager.freezeMultiplier = 1.0;
                    }
                }

                this.activeEvent = null;
            }

            showEventBanner(text) {
                // Remove any existing event banners first
                const existingBanners = document.querySelectorAll('.chaos-event-banner');
                existingBanners.forEach(b => {
                    if (b.parentNode) {
                        b.parentNode.removeChild(b);
                    }
                });
                
                const banner = document.createElement('div');
                banner.className = 'chaos-event-banner';
                banner.textContent = text;
                banner.style.position = 'fixed';
                banner.style.top = '50%';
                banner.style.left = '50%';
                banner.style.transform = 'translate(-50%, -50%)';
                banner.style.fontSize = '3em';
                banner.style.fontWeight = 'bold';
                banner.style.color = '#FFD700';
                banner.style.textShadow = '4px 4px 8px rgba(0,0,0,0.8)';
                banner.style.zIndex = '10000';
                banner.style.pointerEvents = 'none';
                banner.style.animation = 'eventBanner 2s ease-out';
                
                document.body.appendChild(banner);

                setTimeout(() => {
                    if (banner.parentNode) {
                        banner.parentNode.removeChild(banner);
                    }
                }, 2000);

                if (gameState.audioManager) {
                    gameState.audioManager.playEventStart();
                }
            }

            isReverseMode() {
                return this.activeEvent && this.activeEvent.type === 'reverseMode';
            }
        }

        // Chaos Event Manager for wacky gameplay modifiers
        class ChaosEventManager {
            constructor(scene) {
                this.scene = scene;
                this.activeEvent = null;
                this.lastEventCheck = 0;
                this.checkInterval = 45000; // Check every 45 seconds
                this.triggerProbability = 0.3; // 30% chance to trigger
                
                // Store original parameters for restoration
                this.originalParams = {
                    gravityDirection: 1, // 1 for normal, -1 for flipped
                    creatureScales: new Map(), // Store original scales
                    creatureColors: new Map(), // Store original colors
                    timeScale: 1.0,
                    spawnMultiplier: 1
                };
                
                debug.log('ChaosEventManager initialized');
            }

            // Update timer and check for event triggers
            update(deltaTime) {
                if (gameState.paused) return;
                
                const now = Date.now();
                
                // Check for new event trigger
                if (!this.activeEvent && now - this.lastEventCheck >= this.checkInterval) {
                    this.rollForEvent();
                    this.lastEventCheck = now;
                }
                
                // Update active event
                if (this.activeEvent) {
                    const elapsed = now - this.activeEvent.startTime;
                    
                    // Handle time warp alternating speed
                    if (this.activeEvent.type === 'timeWarp') {
                        const cycleTime = elapsed % 4000; // 4 second cycle (2s slow + 2s fast)
                        if (cycleTime < 2000) {
                            // Slow motion phase
                            if (gameState.creatureManager) {
                                gameState.creatureManager.freezeMultiplier = 0.5;
                            }
                        } else {
                            // Fast forward phase
                            if (gameState.creatureManager) {
                                gameState.creatureManager.freezeMultiplier = 2.0;
                            }
                        }
                    }
                    
                    // Check if event duration has expired
                    if (elapsed >= this.activeEvent.duration) {
                        this.endEvent();
                    }
                }
            }

            // Roll for random event with 30% probability
            rollForEvent() {
                if (Math.random() < this.triggerProbability) {
                    this.triggerRandomEvent();
                }
            }

            // Trigger a random chaos event
            triggerRandomEvent() {
                const eventTypes = ['gravityFlip', 'sizeChaos', 'colorMadness', 'timeWarp', 'cloneStorm'];
                const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                this.triggerEvent(eventType);
            }

            // Trigger specific chaos event
            triggerEvent(eventType) {
                // Ensure only one event active at a time
                if (this.activeEvent) {
                    debug.log('Event already active, skipping new event');
                    return;
                }
                
                switch(eventType) {
                    case 'gravityFlip':
                        this.triggerGravityFlip();
                        break;
                    case 'sizeChaos':
                        this.triggerSizeChaos();
                        break;
                    case 'colorMadness':
                        this.triggerColorMadness();
                        break;
                    case 'timeWarp':
                        this.triggerTimeWarp();
                        break;
                    case 'cloneStorm':
                        this.triggerCloneStorm();
                        break;
                    default:
                        debug.error('Unknown event type:', eventType);
                }
            }

            // Gravity Flip: Invert emergence direction for 8 seconds
            triggerGravityFlip() {
                debug.log('üîÑ GRAVITY FLIP EVENT!');
                
                this.activeEvent = {
                    type: 'gravityFlip',
                    startTime: Date.now(),
                    duration: 8000
                };
                
                // Store original gravity direction
                this.originalParams.gravityDirection = 1;
                
                // Invert emergence direction for all creatures
                if (gameState.creatureManager) {
                    gameState.creatureManager.gravityFlipped = true;
                }
                
                this.showEventBanner('üîÑ GRAVITY FLIP! üîÑ');
            }

            // Size Chaos: Random scales 0.5x-2x for 10 seconds
            triggerSizeChaos() {
                debug.log('üìè SIZE CHAOS EVENT!');
                
                this.activeEvent = {
                    type: 'sizeChaos',
                    startTime: Date.now(),
                    duration: 10000
                };
                
                // Store original scales and apply random scales
                if (gameState.creatureManager && gameState.creatureManager.creatures) {
                    this.originalParams.creatureScales.clear();
                    
                    gameState.creatureManager.creatures.forEach(creature => {
                        if (creature.mesh) {
                            // Store original scale
                            this.originalParams.creatureScales.set(creature, {
                                x: creature.mesh.scale.x,
                                y: creature.mesh.scale.y,
                                z: creature.mesh.scale.z
                            });
                            
                            // Apply random scale between 0.5x and 2x
                            const randomScale = 0.5 + Math.random() * 1.5;
                            creature.mesh.scale.set(randomScale, randomScale, randomScale);
                        }
                    });
                    
                    // Set flag for new creatures
                    gameState.creatureManager.sizeChaosActive = true;
                }
                
                this.showEventBanner('üìè SIZE CHAOS! üìè');
            }

            // Color Madness: Random vibrant colors for 12 seconds
            triggerColorMadness() {
                debug.log('üåà COLOR MADNESS EVENT!');
                
                this.activeEvent = {
                    type: 'colorMadness',
                    startTime: Date.now(),
                    duration: 12000
                };
                
                // Store original colors and apply random vibrant colors
                if (gameState.creatureManager && gameState.creatureManager.creatures) {
                    this.originalParams.creatureColors.clear();
                    
                    gameState.creatureManager.creatures.forEach(creature => {
                        if (creature.mesh && creature.mesh.material) {
                            // Store original color
                            this.originalParams.creatureColors.set(creature, creature.mesh.material.color.getHex());
                            
                            // Apply random vibrant color
                            const vibrantColors = [
                                0xFF00FF, // Magenta
                                0x00FFFF, // Cyan
                                0xFFFF00, // Yellow
                                0xFF0000, // Red
                                0x00FF00, // Green
                                0x0000FF, // Blue
                                0xFF6600, // Orange
                                0xFF00AA  // Pink
                            ];
                            const randomColor = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];
                            creature.mesh.material.color.setHex(randomColor);
                        }
                    });
                    
                    // Set flag for new creatures
                    gameState.creatureManager.colorMadnessActive = true;
                }
                
                this.showEventBanner('üåà COLOR MADNESS! üåà');
            }

            // Time Warp: Alternate slow/fast every 2s for 10 seconds total
            triggerTimeWarp() {
                debug.log('‚è∞ TIME WARP EVENT!');
                
                this.activeEvent = {
                    type: 'timeWarp',
                    startTime: Date.now(),
                    duration: 10000
                };
                
                // Store original time scale
                this.originalParams.timeScale = 1.0;
                
                // Time scale will be handled in update() method
                
                this.showEventBanner('‚è∞ TIME WARP! ‚è∞');
            }

            // Clone Storm: 3x creatures per hole for 6 seconds
            triggerCloneStorm() {
                debug.log('üë• CLONE STORM EVENT!');
                
                this.activeEvent = {
                    type: 'cloneStorm',
                    startTime: Date.now(),
                    duration: 6000
                };
                
                // Store original spawn multiplier
                this.originalParams.spawnMultiplier = 1;
                
                // Set spawn multiplier for creature manager
                if (gameState.creatureManager) {
                    gameState.creatureManager.cloneStormActive = true;
                    gameState.creatureManager.cloneMultiplier = 3;
                }
                
                this.showEventBanner('üë• CLONE STORM! üë•');
            }

            // End active event and restore normal parameters
            endEvent() {
                if (!this.activeEvent) return;
                
                debug.log('Chaos event ended:', this.activeEvent.type);
                
                const eventType = this.activeEvent.type;
                
                // Restore parameters based on event type
                if (eventType === 'gravityFlip') {
                    if (gameState.creatureManager) {
                        gameState.creatureManager.gravityFlipped = false;
                    }
                } else if (eventType === 'sizeChaos') {
                    // Restore original scales
                    if (gameState.creatureManager && gameState.creatureManager.creatures) {
                        gameState.creatureManager.creatures.forEach(creature => {
                            const originalScale = this.originalParams.creatureScales.get(creature);
                            if (originalScale && creature.mesh) {
                                creature.mesh.scale.set(originalScale.x, originalScale.y, originalScale.z);
                            }
                        });
                        this.originalParams.creatureScales.clear();
                        gameState.creatureManager.sizeChaosActive = false;
                    }
                } else if (eventType === 'colorMadness') {
                    // Restore original colors
                    if (gameState.creatureManager && gameState.creatureManager.creatures) {
                        gameState.creatureManager.creatures.forEach(creature => {
                            const originalColor = this.originalParams.creatureColors.get(creature);
                            if (originalColor !== undefined && creature.mesh && creature.mesh.material) {
                                creature.mesh.material.color.setHex(originalColor);
                            }
                        });
                        this.originalParams.creatureColors.clear();
                        gameState.creatureManager.colorMadnessActive = false;
                    }
                } else if (eventType === 'timeWarp') {
                    // Restore normal time scale
                    if (gameState.creatureManager) {
                        gameState.creatureManager.freezeMultiplier = 1.0;
                    }
                } else if (eventType === 'cloneStorm') {
                    // Restore normal spawn multiplier
                    if (gameState.creatureManager) {
                        gameState.creatureManager.cloneStormActive = false;
                        gameState.creatureManager.cloneMultiplier = 1;
                    }
                }
                
                this.activeEvent = null;
            }

            // Display event banner with animation
            showEventBanner(text) {
                // Remove any existing event banners first
                const existingBanners = document.querySelectorAll('.chaos-event-banner');
                existingBanners.forEach(b => {
                    if (b.parentNode) {
                        b.parentNode.removeChild(b);
                    }
                });
                
                const banner = document.createElement('div');
                banner.className = 'chaos-event-banner';
                banner.textContent = text;
                banner.style.position = 'fixed';
                banner.style.top = '50%';
                banner.style.left = '50%';
                banner.style.transform = 'translate(-50%, -50%)';
                banner.style.fontSize = '3em';
                banner.style.fontWeight = 'bold';
                banner.style.color = '#FFD700';
                banner.style.textShadow = '4px 4px 8px rgba(0,0,0,0.8)';
                banner.style.zIndex = '10000';
                banner.style.pointerEvents = 'none';
                banner.style.animation = 'eventBanner 2s ease-out';
                
                document.body.appendChild(banner);

                setTimeout(() => {
                    if (banner.parentNode) {
                        banner.parentNode.removeChild(banner);
                    }
                }, 2000);

                if (gameState.audioManager) {
                    gameState.audioManager.playEventStart();
                }
                
                // Trigger camera shake effect for chaos events (Requirement 9.1)
                if (gameState.cameraEffectsManager) {
                    gameState.cameraEffectsManager.shake(0.02, 0.5);
                    debug.log('Camera shake triggered for chaos event');
                }
            }

            setChaosFrequencyMultiplier(multiplier) {
                this.checkInterval = 45000 / multiplier;
                debug.log('Chaos frequency multiplier set to:', multiplier, 'New interval:', this.checkInterval);
            }

            getChaosFrequencyMultiplier() {
                return 45000 / this.checkInterval;
            }
        }

        // Power-Up Manager
        class PowerUpManager {
            constructor(scene) {
                this.scene = scene;
                this.powerUps = [];
                this.spawnInterval = 15000; // 15 seconds
                this.lastSpawn = 0;
                this.activePowerUps = {
                    freeze: false,
                    doublePoints: false
                };
            }

            update(deltaTime) {
                const now = Date.now();
                
                // Spawn power-ups periodically
                if (now - this.lastSpawn > this.spawnInterval && !gameState.paused) {
                    this.spawnPowerUp();
                    this.lastSpawn = now;
                }

                // Update existing power-ups (rotate them)
                this.powerUps.forEach(powerUp => {
                    powerUp.mesh.rotation.y += deltaTime * 2;
                    powerUp.mesh.position.y = powerUp.baseY + Math.sin(now * 0.003) * 0.05;
                });
            }

            spawnPowerUp() {
                const rand = Math.random();
                let type;
                
                if (rand < 0.4) {
                    type = 'freeze';
                } else if (rand < 0.8) {
                    type = 'doublePoints';
                } else {
                    type = 'extraLife';
                }

                // Random position on ground
                const x = (Math.random() - 0.5) * 2;
                const z = (Math.random() - 0.5) * 2;
                const y = 0.2;

                const mesh = this.createPowerUpMesh(type);
                mesh.position.set(x, y, z);
                this.scene.add(mesh);

                const powerUp = {
                    mesh: mesh,
                    type: type,
                    baseY: y,
                    spawnTime: Date.now()
                };

                this.powerUps.push(powerUp);

                // Auto-despawn after 10 seconds
                setTimeout(() => {
                    this.removePowerUp(powerUp);
                }, 10000);

                debug.log('Power-up spawned:', type);
            }

            createPowerUpMesh(type) {
                const group = new THREE.Group();
                
                // Glowing orb
                const orbGeo = new THREE.SphereGeometry(0.1, 16, 16);
                let color, emissive;
                
                if (type === 'freeze') {
                    color = 0x00ffff; // Cyan
                    emissive = 0x00ffff;
                } else if (type === 'doublePoints') {
                    color = 0xffff00; // Yellow
                    emissive = 0xffff00;
                } else {
                    color = 0x00ff00; // Green
                    emissive = 0x00ff00;
                }
                
                const orbMat = new THREE.MeshStandardMaterial({ 
                    color: color,
                    emissive: emissive,
                    emissiveIntensity: 0.5,
                    metalness: 0.3,
                    roughness: 0.2
                });
                const orb = new THREE.Mesh(orbGeo, orbMat);
                group.add(orb);
                
                // Outer glow
                const glowGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                group.add(glow);
                
                group.userData.powerUpType = type;
                
                return group;
            }

            collectPowerUp(powerUp) {
                debug.log('Collected power-up:', powerUp.type);
                
                if (gameState.audioManager) {
                    gameState.audioManager.playPowerUp();
                }
                
                // Screen flash effect (requirement 6.4)
                this.createScreenFlash();
                
                // Animated icon effect (requirement 6.4)
                this.showPowerUpIcon(powerUp.type);
                
                // Spawn visual effect at power-up location
                if (gameState.visualEffectsManager) {
                    gameState.visualEffectsManager.spawnPowerUpEffect(powerUp.mesh.position, powerUp.type);
                }
                
                // Trigger camera pulse effect (Requirement 9.4)
                if (gameState.cameraEffectsManager) {
                    gameState.cameraEffectsManager.pulse(0.01);
                    debug.log('Camera pulse triggered for power-up collection');
                }

                if (powerUp.type === 'freeze') {
                    this.activateFreeze();
                } else if (powerUp.type === 'doublePoints') {
                    this.activateDoublePoints();
                } else if (powerUp.type === 'extraLife') {
                    this.activateExtraLife();
                }

                this.removePowerUp(powerUp);
            }
            
            createScreenFlash() {
                // Create a full-screen white flash overlay
                const flash = document.createElement('div');
                flash.style.position = 'fixed';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
                flash.style.pointerEvents = 'none';
                flash.style.zIndex = '9999';
                flash.style.transition = 'opacity 0.3s ease-out';
                
                document.body.appendChild(flash);
                
                // Fade out and remove
                setTimeout(() => {
                    flash.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(flash);
                    }, 300);
                }, 50);
            }
            
            showPowerUpIcon(powerUpType) {
                // Determine icon based on power-up type
                let icon = '‚≠ê';
                let color = '#FFD700';
                let text = 'Power-Up!';
                
                if (powerUpType === 'freeze') {
                    icon = 'üßä';
                    color = '#00BFFF';
                    text = 'Freeze Time!';
                } else if (powerUpType === 'doublePoints') {
                    icon = 'üí∞';
                    color = '#FFD700';
                    text = 'Double Points!';
                } else if (powerUpType === 'extraLife') {
                    icon = 'üíö';
                    color = '#00FF00';
                    text = 'Extra Life!';
                }
                
                // Create animated icon element
                const iconElement = document.createElement('div');
                iconElement.style.position = 'fixed';
                iconElement.style.top = '50%';
                iconElement.style.left = '50%';
                iconElement.style.transform = 'translate(-50%, -50%) scale(0)';
                iconElement.style.fontSize = '5em';
                iconElement.style.pointerEvents = 'none';
                iconElement.style.zIndex = '10000';
                iconElement.style.textAlign = 'center';
                iconElement.style.transition = 'all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
                iconElement.innerHTML = `
                    <div style="font-size: 1em; filter: drop-shadow(0 0 10px ${color});">${icon}</div>
                    <div style="font-size: 0.3em; color: ${color}; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); margin-top: 10px;">${text}</div>
                `;
                
                document.body.appendChild(iconElement);
                
                // Animate in
                setTimeout(() => {
                    iconElement.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 10);
                
                // Animate out and remove
                setTimeout(() => {
                    iconElement.style.transform = 'translate(-50%, -80%) scale(0.5)';
                    iconElement.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(iconElement);
                    }, 500);
                }, 1500);
            }

            activateFreeze() {
                debug.log('üßä Freeze Time activated!');
                this.activePowerUps.freeze = true;
                
                // Slow down all creatures
                if (gameState.creatureManager) {
                    gameState.creatureManager.freezeMultiplier = 0.3;
                }

                setTimeout(() => {
                    this.activePowerUps.freeze = false;
                    if (gameState.creatureManager) {
                        gameState.creatureManager.freezeMultiplier = 1.0;
                    }
                    debug.log('Freeze ended');
                }, 5000);
            }

            activateDoublePoints() {
                debug.log('üí∞ Double Points activated!');
                this.activePowerUps.doublePoints = true;

                setTimeout(() => {
                    this.activePowerUps.doublePoints = false;
                    debug.log('Double Points ended');
                }, 10000);
            }

            activateExtraLife() {
                debug.log('üíö Extra Life! +500 points');
                gameState.scoreManager.addScore(500);
            }

            removePowerUp(powerUp) {
                this.scene.remove(powerUp.mesh);
                const index = this.powerUps.indexOf(powerUp);
                if (index > -1) {
                    this.powerUps.splice(index, 1);
                }
            }

            getPointsMultiplier() {
                return this.activePowerUps.doublePoints ? 2 : 1;
            }
        }

        // Biome configuration constants
        const BIOMES = {
            forest: {
                groundColor: 0x2d4a2b,
                skyColor: 0x87CEEB,
                ambientLight: { color: 0xffffff, intensity: 0.5 },
                directionalLight: { color: 0xffffcc, intensity: 0.9 },
                fogColor: 0x88aa88,
                fogDensity: 0.02
            },
            desert: {
                groundColor: 0xd4a574,
                skyColor: 0xffd89b,
                ambientLight: { color: 0xffffee, intensity: 0.7 },
                directionalLight: { color: 0xffffaa, intensity: 1.2 },
                fogColor: 0xffddaa,
                fogDensity: 0.01
            },
            arctic: {
                groundColor: 0xe0f0ff,
                skyColor: 0xb0d0e8,
                ambientLight: { color: 0xccddff, intensity: 0.4 },
                directionalLight: { color: 0xeeeeff, intensity: 0.7 },
                fogColor: 0xddeeff,
                fogDensity: 0.03
            },
            volcanic: {
                groundColor: 0x5a2a1a,
                skyColor: 0x4a2020,
                ambientLight: { color: 0xff8844, intensity: 0.6 },
                directionalLight: { color: 0xff6633, intensity: 1.0 },
                fogColor: 0x663333,
                fogDensity: 0.04
            }
        };

        // Visual Effects Manager for particle systems and animations
        class VisualEffectsManager {
            constructor(scene) {
                this.scene = scene;
                this.activeEffects = [];
                this.maxActiveEffects = 50;
                
                // Particle pool for performance
                this.particlePool = [];
                this.maxPoolSize = 100;
                
                debug.log('VisualEffectsManager initialized');
            }

            // Get or create a particle from the pool
            getParticle() {
                if (this.particlePool.length > 0) {
                    return this.particlePool.pop();
                }
                
                // Create new particle
                const geo = new THREE.SphereGeometry(0.02, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ transparent: true });
                const particle = new THREE.Mesh(geo, mat);
                return particle;
            }

            // Return particle to pool
            returnParticle(particle) {
                if (this.particlePool.length < this.maxPoolSize) {
                    this.scene.remove(particle);
                    particle.userData = {};
                    this.particlePool.push(particle);
                } else {
                    // Dispose if pool is full
                    this.scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                }
            }

            // Spawn hit particle burst with color matching for creature types
            spawnHitEffect(position, creatureType, comboMultiplier = 1.0) {
                // Limit active effects
                if (this.activeEffects.length >= this.maxActiveEffects) {
                    return;
                }

                // Determine color based on creature type
                let color = 0xffff00; // Default yellow
                if (creatureType === 'mole') color = 0x8B4513;
                else if (creatureType === 'rabbit') color = 0xE0E0E0;
                else if (creatureType === 'squirrel') color = 0xD2691E;
                else if (creatureType === 'badger') color = 0x808080;
                else if (creatureType === 'fox') color = 0xFF6347;
                else if (creatureType === 'raccoon') color = 0x696969;
                else if (creatureType === 'hedgehog') color = 0xA0522D;
                else if (creatureType === 'gopher') color = 0xDEB887;

                // Scale particle count and size with combo multiplier
                const baseParticleCount = 8;
                const particleCount = Math.min(baseParticleCount + Math.floor(comboMultiplier * 2), 20);
                const baseSize = 0.02;
                const particleSize = baseSize * (1 + comboMultiplier * 0.2);

                const particles = [];
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.getParticle();
                    particle.material.color.setHex(color);
                    particle.material.opacity = 1.0;
                    particle.scale.setScalar(particleSize);
                    
                    particle.position.copy(position);
                    
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 0.5 + Math.random() * 0.3;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.5 + 0.3,
                        Math.sin(angle) * speed
                    );
                    particle.userData.life = 1.0;
                    particle.userData.maxLife = 1.0;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.activeEffects.push({
                    type: 'hit',
                    particles: particles,
                    age: 0
                });
            }

            // Spawn subtle miss indicator
            spawnMissEffect(position) {
                if (this.activeEffects.length >= this.maxActiveEffects) {
                    return;
                }

                const particleCount = 4;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.getParticle();
                    particle.material.color.setHex(0x888888); // Gray for miss
                    particle.material.opacity = 0.5;
                    particle.scale.setScalar(0.015);
                    
                    particle.position.copy(position);
                    
                    const angle = (i / particleCount) * Math.PI * 2;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * 0.2,
                        0.1,
                        Math.sin(angle) * 0.2
                    );
                    particle.userData.life = 0.5;
                    particle.userData.maxLife = 0.5;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.activeEffects.push({
                    type: 'miss',
                    particles: particles,
                    age: 0
                });
            }

            // Spawn power-up collection effect with pulsing glow
            spawnPowerUpEffect(position, powerUpType) {
                if (this.activeEffects.length >= this.maxActiveEffects) {
                    return;
                }

                const particleCount = 12;
                const particles = [];
                const color = 0xFFD700; // Gold for power-ups
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.getParticle();
                    particle.material.color.setHex(color);
                    particle.material.opacity = 1.0;
                    particle.scale.setScalar(0.03);
                    
                    particle.position.copy(position);
                    
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 0.6 + Math.random() * 0.4;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.8 + 0.4,
                        Math.sin(angle) * speed
                    );
                    particle.userData.life = 1.5;
                    particle.userData.maxLife = 1.5;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.activeEffects.push({
                    type: 'powerup',
                    particles: particles,
                    age: 0
                });
            }

            // Spawn environment transition particles
            spawnTransitionEffect(biomeType) {
                if (this.activeEffects.length >= this.maxActiveEffects) {
                    return;
                }

                // Determine color based on biome
                let color = 0xffffff;
                if (biomeType === 'forest') color = 0x228B22;
                else if (biomeType === 'desert') color = 0xF4A460;
                else if (biomeType === 'arctic') color = 0xE0FFFF;
                else if (biomeType === 'volcanic') color = 0xFF4500;

                const particleCount = 20;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.getParticle();
                    particle.material.color.setHex(color);
                    particle.material.opacity = 0.6;
                    particle.scale.setScalar(0.025);
                    
                    // Spawn particles in a circle around the scene
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 2.0;
                    particle.position.set(
                        Math.cos(angle) * radius,
                        Math.random() * 0.5,
                        Math.sin(angle) * radius
                    );
                    
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.3 + 0.1,
                        (Math.random() - 0.5) * 0.2
                    );
                    particle.userData.life = 2.0;
                    particle.userData.maxLife = 2.0;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.activeEffects.push({
                    type: 'transition',
                    particles: particles,
                    age: 0
                });
            }

            // Spawn creature emergence dust particles
            spawnEmergenceEffect(position) {
                if (this.activeEffects.length >= this.maxActiveEffects) {
                    return;
                }

                const particleCount = 6;
                const particles = [];
                const color = 0x8B7355; // Brown dust color
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.getParticle();
                    particle.material.color.setHex(color);
                    particle.material.opacity = 0.7;
                    particle.scale.setScalar(0.02);
                    
                    particle.position.copy(position);
                    particle.position.y = 0.05; // Ground level
                    
                    const angle = (i / particleCount) * Math.PI * 2;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * 0.3,
                        Math.random() * 0.2,
                        Math.sin(angle) * 0.3
                    );
                    particle.userData.life = 0.8;
                    particle.userData.maxLife = 0.8;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.activeEffects.push({
                    type: 'emergence',
                    particles: particles,
                    age: 0
                });
            }

            // Create combo trail effect for cursor/controller
            createComboTrail(startPos, endPos, comboCount) {
                if (this.activeEffects.length >= this.maxActiveEffects) {
                    return;
                }

                const particleCount = Math.min(5 + comboCount, 15);
                const particles = [];
                const color = 0xFFD700; // Gold trail
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.getParticle();
                    particle.material.color.setHex(color);
                    particle.material.opacity = 0.8;
                    particle.scale.setScalar(0.015);
                    
                    // Interpolate between start and end
                    const t = i / particleCount;
                    particle.position.lerpVectors(startPos, endPos, t);
                    
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        Math.random() * 0.1,
                        (Math.random() - 0.5) * 0.1
                    );
                    particle.userData.life = 0.5;
                    particle.userData.maxLife = 0.5;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.activeEffects.push({
                    type: 'trail',
                    particles: particles,
                    age: 0
                });
            }

            // Update all active effects
            update(deltaTime) {
                for (let i = this.activeEffects.length - 1; i >= 0; i--) {
                    const effect = this.activeEffects[i];
                    effect.age += deltaTime;
                    
                    let allParticlesDead = true;
                    
                    for (let j = effect.particles.length - 1; j >= 0; j--) {
                        const particle = effect.particles[j];
                        
                        // Update position
                        particle.position.add(
                            particle.userData.velocity.clone().multiplyScalar(deltaTime)
                        );
                        
                        // Apply gravity
                        particle.userData.velocity.y -= deltaTime * 2;
                        
                        // Update life
                        particle.userData.life -= deltaTime;
                        
                        // Update opacity based on life
                        particle.material.opacity = Math.max(0, particle.userData.life / particle.userData.maxLife);
                        
                        if (particle.userData.life <= 0) {
                            this.returnParticle(particle);
                            effect.particles.splice(j, 1);
                        } else {
                            allParticlesDead = false;
                        }
                    }
                    
                    // Remove effect if all particles are dead
                    if (allParticlesDead) {
                        this.activeEffects.splice(i, 1);
                    }
                }
            }

            // Clean up all effects
            dispose() {
                for (const effect of this.activeEffects) {
                    for (const particle of effect.particles) {
                        this.scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    }
                }
                this.activeEffects = [];
                
                for (const particle of this.particlePool) {
                    particle.geometry.dispose();
                    particle.material.dispose();
                }
                this.particlePool = [];
            }
        }

        // Environment Cycle Manager for automatic biome transitions
        class EnvironmentCycleManager {
            constructor(environmentManager) {
                this.environmentManager = environmentManager;
                this.isActive = false;
                this.timeSinceLastCycle = 0;
                this.cycleInterval = this.getRandomInterval();
                this.currentBiome = null;
                this.previousBiome = null;
                this.availableBiomes = ['forest', 'desert', 'arctic', 'volcanic'];
                
                debug.log('EnvironmentCycleManager initialized with interval:', this.cycleInterval);
            }

            // Get random interval between 20-30 seconds
            getRandomInterval() {
                return 20000 + Math.random() * 10000; // 20-30 seconds in milliseconds
            }

            // Start automatic cycling
            startCycling() {
                this.isActive = true;
                this.timeSinceLastCycle = 0;
                this.currentBiome = this.environmentManager.getCurrentBiome();
                this.previousBiome = this.currentBiome;
                debug.log('Environment cycling started');
            }

            // Stop cycling (on pause)
            stopCycling() {
                this.isActive = false;
                debug.log('Environment cycling stopped');
            }

            // Select next random biome (no repeats)
            selectNextBiome() {
                // Filter out the previous biome to prevent consecutive repeats
                const availableChoices = this.availableBiomes.filter(biome => biome !== this.previousBiome);
                
                // Select random biome from available choices
                const nextBiome = availableChoices[Math.floor(Math.random() * availableChoices.length)];
                
                debug.log('Selected next biome:', nextBiome, '(previous was:', this.previousBiome + ')');
                return nextBiome;
            }

            // Trigger transition to new biome
            transitionToBiome(biomeType) {
                this.previousBiome = this.currentBiome;
                this.currentBiome = biomeType;
                
                // Use EnvironmentManager's transition method with 2-second duration
                this.environmentManager.transitionToBiome(biomeType, 2000);
                
                debug.log('Transitioning from', this.previousBiome, 'to', biomeType);
            }

            // Update timer and trigger transitions
            update(deltaTime) {
                if (!this.isActive) {
                    return;
                }

                // Convert deltaTime from seconds to milliseconds
                const deltaMs = deltaTime * 1000;
                this.timeSinceLastCycle += deltaMs;

                // Check if it's time to transition
                if (this.timeSinceLastCycle >= this.cycleInterval) {
                    // Select and transition to next biome
                    const nextBiome = this.selectNextBiome();
                    this.transitionToBiome(nextBiome);
                    
                    // Reset timer and get new random interval
                    this.timeSinceLastCycle = 0;
                    this.cycleInterval = this.getRandomInterval();
                    
                    debug.log('Next cycle in:', this.cycleInterval / 1000, 'seconds');
                }
            }
        }

        // Environment Manager for biomes, weather, and day-night cycles
        class EnvironmentManager {
            constructor(scene, audioManager, performanceMonitor) {
                this.scene = scene;
                this.audioManager = audioManager;
                this.performanceMonitor = performanceMonitor;
                
                this.currentBiome = null;
                this.transitionInProgress = false;
                this.transitionStartTime = 0;
                this.transitionDuration = 2000; // 2 seconds in milliseconds
                this.transitionFromBiome = null;
                this.transitionTargetBiome = null;
                
                // Store references to scene objects for transitions
                this.groundMesh = null;
                this.ambientLight = null;
                this.directionalLight = null;
                
                // Weather system - with error handling
                try {
                    this.weatherSystem = new WeatherSystem(scene);
                    this.weatherSystemEnabled = true;
                } catch (e) {
                    debug.error('Failed to initialize weather system:', e);
                    this.weatherSystem = null;
                    this.weatherSystemEnabled = false;
                    // Continue game without weather effects
                }
                
                // Day-night cycle (will be initialized after scene references are set)
                this.dayNightCycle = null;
                
                // In-memory storage fallback for when localStorage is unavailable
                this.inMemoryPreferences = null;
            }

            // Set references to scene objects
            setSceneReferences(groundMesh, ambientLight, directionalLight) {
                this.groundMesh = groundMesh;
                this.ambientLight = ambientLight;
                this.directionalLight = directionalLight;
                
                // Initialize day-night cycle with light references
                this.dayNightCycle = new DayNightCycle(ambientLight, directionalLight);
            }

            // Set active biome immediately
            setActiveBiome(biomeType) {
                if (!BIOMES[biomeType]) {
                    debug.error('Invalid biome type:', biomeType);
                    biomeType = 'forest'; // Default fallback
                }

                debug.log('Setting active biome:', biomeType);
                this.currentBiome = biomeType;
                this.applyBiomeConfiguration(biomeType);
                
                // Update creature appearances to match new biome
                if (gameState.creatureManager) {
                    gameState.creatureManager.updateCreatureBiomeTints();
                }
                
                // Save biome preference to localStorage (Requirement 11.1)
                this.savePreferences();
            }

            // Get current biome
            getCurrentBiome() {
                return this.currentBiome;
            }

            // Transition to a new biome with interpolation
            transitionToBiome(biomeType, duration = 2000) {
                if (!BIOMES[biomeType]) {
                    debug.error('Invalid biome type:', biomeType);
                    return;
                }

                if (this.currentBiome === biomeType) {
                    debug.log('Already in biome:', biomeType);
                    return;
                }

                // If a transition is already in progress, complete it immediately to target state
                if (this.transitionInProgress) {
                    debug.log('Interrupting current transition, completing immediately');
                    this.applyBiomeConfiguration(this.currentBiome);
                    this.transitionInProgress = false;
                }

                debug.log('Starting transition to biome:', biomeType);
                this.transitionInProgress = true;
                this.transitionStartTime = Date.now();
                this.transitionDuration = duration;
                this.transitionFromBiome = this.currentBiome ? BIOMES[this.currentBiome] : BIOMES[biomeType];
                this.transitionTargetBiome = BIOMES[biomeType];
                this.currentBiome = biomeType;
            }

            // Apply biome configuration immediately
            applyBiomeConfiguration(biomeType) {
                const config = BIOMES[biomeType];
                
                // Update ground color
                if (this.groundMesh && this.groundMesh.material) {
                    this.groundMesh.material.color.setHex(config.groundColor);
                    // Ensure material is opaque and updated
                    this.groundMesh.material.transparent = false;
                    this.groundMesh.material.opacity = 1.0;
                    this.groundMesh.material.needsUpdate = true;
                }

                // Update sky color
                this.scene.background.setHex(config.skyColor);

                // Update ambient light
                if (this.ambientLight) {
                    this.ambientLight.color.setHex(config.ambientLight.color);
                    this.ambientLight.intensity = config.ambientLight.intensity;
                }

                // Update directional light
                if (this.directionalLight) {
                    this.directionalLight.color.setHex(config.directionalLight.color);
                    this.directionalLight.intensity = config.directionalLight.intensity;
                }

                debug.log('Applied biome configuration:', biomeType);
            }

            // Set weather type
            setWeather(weatherType) {
                try {
                    if (this.weatherSystem && this.weatherSystemEnabled) {
                        this.weatherSystem.setWeatherType(weatherType);
                        
                        // Update fog color based on active biome
                        if (weatherType === 'fog' && this.currentBiome) {
                            const config = BIOMES[this.currentBiome];
                            if (this.scene.fog) {
                                this.scene.fog.color.setHex(config.fogColor);
                            }
                        }
                    } else if (!this.weatherSystemEnabled) {
                        debug.log('Weather system disabled, skipping weather change');
                        return;
                    }
                    
                    // Weather audio removed (simplified audio system)
                } catch (e) {
                    debug.error('Failed to set weather:', e);
                    // Disable weather system on failure
                    this.weatherSystemEnabled = false;
                    debug.log('Weather system disabled due to error');
                }
                
                // Save weather preference to localStorage (Requirement 11.4)
                this.savePreferences();
            }

            // Update weather particles
            updateWeather(deltaTime) {
                if (this.weatherSystem) {
                    this.weatherSystem.update(deltaTime);
                }
            }

            // Enable or disable day-night cycle
            enableDayNightCycle(enabled) {
                if (this.dayNightCycle) {
                    this.dayNightCycle.enableDayNightCycle(enabled);
                }
                
                // Save day-night preference to localStorage (Requirement 11.5)
                this.savePreferences();
            }

            // Get current day-night phase
            getCurrentPhase() {
                if (this.dayNightCycle) {
                    return this.dayNightCycle.getCurrentPhase();
                }
                return null;
            }

            // Update day-night cycle
            updateDayNightCycle(deltaTime) {
                if (this.dayNightCycle) {
                    this.dayNightCycle.update(deltaTime);
                }
            }

            // Update method called each frame
            update(deltaTime) {
                // Handle biome transitions
                if (this.transitionInProgress) {
                    const elapsed = Date.now() - this.transitionStartTime;
                    const progress = Math.min(elapsed / this.transitionDuration, 1.0);

                    // Lerp between biome configurations
                    this.lerpBiomeProperties(this.transitionFromBiome, this.transitionTargetBiome, progress);

                    if (progress >= 1.0) {
                        this.transitionInProgress = false;
                        debug.log('Biome transition complete');
                        
                        // Update creature appearances to match new biome
                        if (gameState.creatureManager) {
                            gameState.creatureManager.updateCreatureBiomeTints();
                        }
                    }
                }
                
                // Update weather system
                this.updateWeather(deltaTime);
                
                // Update day-night cycle
                this.updateDayNightCycle(deltaTime);
            }

            // Linear interpolation between two biome configurations
            lerpBiomeProperties(fromBiome, toBiome, t) {
                // Lerp ground color
                if (this.groundMesh && this.groundMesh.material) {
                    const fromColor = new THREE.Color(fromBiome.groundColor);
                    const toColor = new THREE.Color(toBiome.groundColor);
                    this.groundMesh.material.color.lerpColors(fromColor, toColor, t);
                }

                // Lerp sky color
                const fromSky = new THREE.Color(fromBiome.skyColor);
                const toSky = new THREE.Color(toBiome.skyColor);
                this.scene.background.lerpColors(fromSky, toSky, t);

                // Lerp ambient light
                if (this.ambientLight) {
                    const fromAmbient = new THREE.Color(fromBiome.ambientLight.color);
                    const toAmbient = new THREE.Color(toBiome.ambientLight.color);
                    this.ambientLight.color.lerpColors(fromAmbient, toAmbient, t);
                    this.ambientLight.intensity = fromBiome.ambientLight.intensity + 
                        (toBiome.ambientLight.intensity - fromBiome.ambientLight.intensity) * t;
                }

                // Lerp directional light
                if (this.directionalLight) {
                    const fromDir = new THREE.Color(fromBiome.directionalLight.color);
                    const toDir = new THREE.Color(toBiome.directionalLight.color);
                    this.directionalLight.color.lerpColors(fromDir, toDir, t);
                    this.directionalLight.intensity = fromBiome.directionalLight.intensity + 
                        (toBiome.directionalLight.intensity - fromBiome.directionalLight.intensity) * t;
                }
            }

            // Save preferences to localStorage (Requirements 11.1, 11.4, 11.5)
            savePreferences() {
                try {
                    // Save biome preference
                    if (this.currentBiome) {
                        localStorage.setItem('whackamole_biome', this.currentBiome);
                        debug.log('Saved biome preference:', this.currentBiome);
                    }
                    
                    // Save weather preference
                    if (this.weatherSystem) {
                        localStorage.setItem('whackamole_weather_enabled', 
                            this.weatherSystem.weatherType !== 'clear' ? 'true' : 'false');
                        localStorage.setItem('whackamole_weather_type', this.weatherSystem.weatherType);
                        debug.log('Saved weather preference:', this.weatherSystem.weatherType);
                    }
                    
                    // Save day-night cycle preference
                    if (this.dayNightCycle) {
                        localStorage.setItem('whackamole_daynight_enabled', 
                            this.dayNightCycle.enabled ? 'true' : 'false');
                        debug.log('Saved day-night preference:', this.dayNightCycle.enabled);
                    }
                } catch (e) {
                    debug.error('Failed to save preferences:', e);
                    
                    // Check if it's a quota exceeded error
                    if (e.name === 'QuotaExceededError' || e.code === 22) {
                        debug.log('localStorage quota exceeded, clearing old preferences');
                        try {
                            // Clear old game preferences to make space
                            const keysToKeep = ['whackamole_biome', 'whackamole_weather_enabled', 
                                              'whackamole_weather_type', 'whackamole_daynight_enabled', 
                                              'whackamole_highscore'];
                            const allKeys = Object.keys(localStorage);
                            allKeys.forEach(key => {
                                if (!keysToKeep.includes(key)) {
                                    localStorage.removeItem(key);
                                }
                            });
                            // Try saving again
                            this.savePreferences();
                            return;
                        } catch (e2) {
                            debug.error('Failed to clear localStorage:', e2);
                        }
                    }
                    
                    // Fallback to in-memory storage if localStorage unavailable
                    this.inMemoryPreferences = {
                        biome: this.currentBiome,
                        weatherEnabled: this.weatherSystem ? this.weatherSystem.weatherType !== 'clear' : false,
                        weatherType: this.weatherSystem ? this.weatherSystem.weatherType : 'clear',
                        dayNightEnabled: this.dayNightCycle ? this.dayNightCycle.enabled : false
                    };
                    debug.log('Using in-memory storage fallback');
                }
            }

            // Load preferences from localStorage (Requirements 11.2, 11.3)
            loadPreferences() {
                const preferences = {
                    biome: null,
                    weatherEnabled: false,
                    weatherType: 'clear',
                    dayNightEnabled: false
                };
                
                try {
                    // Load biome preference
                    const savedBiome = localStorage.getItem('whackamole_biome');
                    if (savedBiome && BIOMES[savedBiome]) {
                        preferences.biome = savedBiome;
                        debug.log('Loaded biome preference:', savedBiome);
                    } else {
                        debug.log('No valid biome preference found, will use random selection');
                    }
                    
                    // Load weather preference
                    const weatherEnabled = localStorage.getItem('whackamole_weather_enabled');
                    const weatherType = localStorage.getItem('whackamole_weather_type');
                    if (weatherEnabled === 'true' && weatherType) {
                        preferences.weatherEnabled = true;
                        preferences.weatherType = weatherType;
                        debug.log('Loaded weather preference:', weatherType);
                    }
                    
                    // Load day-night cycle preference
                    const dayNightEnabled = localStorage.getItem('whackamole_daynight_enabled');
                    if (dayNightEnabled === 'true') {
                        preferences.dayNightEnabled = true;
                        debug.log('Loaded day-night preference: enabled');
                    }
                } catch (e) {
                    debug.error('Failed to load preferences:', e);
                    // Try to use in-memory fallback if available
                    if (this.inMemoryPreferences) {
                        debug.log('Using in-memory preferences fallback');
                        return this.inMemoryPreferences;
                    }
                    // Handle corrupted preferences by resetting to defaults
                    debug.log('Resetting to default preferences');
                }
                
                return preferences;
            }
        }

        // Weather System for particle-based weather effects
        class WeatherSystem {
            constructor(scene) {
                this.scene = scene;
                this.weatherType = 'clear';
                this.maxParticles = 500;
                this.particlePool = [];
                this.activeParticles = [];
                this.particleGeometry = null;
                this.particleMaterial = null;
                this.particleSystem = null;
                this.memoryPressureDetected = false;
                
                // Initialize particle pool with error handling
                try {
                    this.initializeParticlePool();
                } catch (e) {
                    debug.error('Failed to initialize particle pool:', e);
                    // Try with reduced particle count on memory pressure
                    this.maxParticles = 250;
                    this.memoryPressureDetected = true;
                    debug.log('Retrying with reduced particle count:', this.maxParticles);
                    try {
                        this.initializeParticlePool();
                    } catch (e2) {
                        debug.error('Failed to initialize particle pool even with reduced count:', e2);
                        throw e2; // Re-throw to be caught by EnvironmentManager
                    }
                }
            }

            // Initialize particle pool with reusable particles
            initializeParticlePool() {
                const positions = new Float32Array(this.maxParticles * 3);
                const velocities = new Float32Array(this.maxParticles * 3);
                
                this.particleGeometry = new THREE.BufferGeometry();
                this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                
                this.particleMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.02,
                    transparent: true,
                    opacity: 0.6
                });
                
                this.particleSystem = new THREE.Points(this.particleGeometry, this.particleMaterial);
                this.scene.add(this.particleSystem);
                
                // Initialize all particles as inactive
                for (let i = 0; i < this.maxParticles; i++) {
                    this.particlePool.push({
                        index: i,
                        active: false,
                        position: new THREE.Vector3(),
                        velocity: new THREE.Vector3()
                    });
                }
                
                debug.log('Weather particle pool initialized with', this.maxParticles, 'particles');
            }

            // Set weather type
            setWeatherType(type) {
                if (!['clear', 'rain', 'snow', 'fog'].includes(type)) {
                    debug.error('Invalid weather type:', type);
                    return;
                }
                
                debug.log('Setting weather type:', type);
                this.weatherType = type;
                
                // Clear all active particles when changing weather
                this.clearAllParticles();
                
                // Apply weather-specific settings
                if (type === 'rain') {
                    this.setupRainParticles();
                } else if (type === 'snow') {
                    this.setupSnowParticles();
                } else if (type === 'fog') {
                    this.setupFog();
                } else if (type === 'clear') {
                    this.clearFog();
                }
            }

            // Setup rain particle appearance
            setupRainParticles() {
                this.particleMaterial.color.setHex(0x4444ff);
                this.particleMaterial.size = 0.015;
                this.particleMaterial.opacity = 0.6;
                
                // Spawn initial rain particles
                for (let i = 0; i < Math.min(300, this.maxParticles); i++) {
                    this.spawnRainParticle();
                }
            }

            // Setup snow particle appearance
            setupSnowParticles() {
                this.particleMaterial.color.setHex(0xffffff);
                this.particleMaterial.size = 0.03;
                this.particleMaterial.opacity = 0.8;
                
                // Spawn initial snow particles
                for (let i = 0; i < Math.min(200, this.maxParticles); i++) {
                    this.spawnSnowParticle();
                }
            }

            // Setup fog effect
            setupFog() {
                // Fog will be handled separately in the scene
                // This is a placeholder for fog-specific setup
                const fogColor = 0xcccccc;
                const fogNear = 1;
                const fogFar = 10;
                
                this.scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);
                debug.log('Fog applied to scene');
            }

            // Clear fog effect
            clearFog() {
                if (this.scene.fog) {
                    this.scene.fog = null;
                    debug.log('Fog cleared from scene');
                }
            }

            // Spawn a rain particle
            spawnRainParticle() {
                const particle = this.getInactiveParticle();
                if (!particle) return;
                
                // Random position above the play area
                particle.position.set(
                    (Math.random() - 0.5) * 4,
                    2 + Math.random() * 2,
                    (Math.random() - 0.5) * 4
                );
                
                // Downward velocity for rain
                particle.velocity.set(
                    0,
                    -2.0 - Math.random() * 1.0, // Negative Y velocity
                    0
                );
                
                particle.active = true;
                this.activeParticles.push(particle);
                this.updateParticleInGeometry(particle);
            }

            // Spawn a snow particle
            spawnSnowParticle() {
                const particle = this.getInactiveParticle();
                if (!particle) return;
                
                // Random position above the play area
                particle.position.set(
                    (Math.random() - 0.5) * 4,
                    2 + Math.random() * 2,
                    (Math.random() - 0.5) * 4
                );
                
                // Gentle downward drift with lateral movement
                particle.velocity.set(
                    (Math.random() - 0.5) * 0.3, // Lateral X movement
                    -0.3 - Math.random() * 0.2,  // Gentle downward
                    (Math.random() - 0.5) * 0.3  // Lateral Z movement
                );
                
                particle.active = true;
                this.activeParticles.push(particle);
                this.updateParticleInGeometry(particle);
            }

            // Get an inactive particle from the pool
            getInactiveParticle() {
                for (let i = 0; i < this.particlePool.length; i++) {
                    if (!this.particlePool[i].active) {
                        return this.particlePool[i];
                    }
                }
                return null; // Pool is full
            }

            // Update particle position in geometry
            updateParticleInGeometry(particle) {
                const positions = this.particleGeometry.attributes.position.array;
                const velocities = this.particleGeometry.attributes.velocity.array;
                const idx = particle.index * 3;
                
                positions[idx] = particle.position.x;
                positions[idx + 1] = particle.position.y;
                positions[idx + 2] = particle.position.z;
                
                velocities[idx] = particle.velocity.x;
                velocities[idx + 1] = particle.velocity.y;
                velocities[idx + 2] = particle.velocity.z;
            }

            // Clear all active particles
            clearAllParticles() {
                for (let particle of this.activeParticles) {
                    particle.active = false;
                    
                    // Move particle far away (effectively hiding it)
                    const positions = this.particleGeometry.attributes.position.array;
                    const idx = particle.index * 3;
                    positions[idx] = 0;
                    positions[idx + 1] = -1000;
                    positions[idx + 2] = 0;
                }
                
                this.activeParticles = [];
                this.particleGeometry.attributes.position.needsUpdate = true;
            }

            // Update weather particles each frame
            update(deltaTime) {
                if (this.weatherType === 'clear' || this.weatherType === 'fog') {
                    return; // No particles to update
                }
                
                const positions = this.particleGeometry.attributes.position.array;
                
                // Update active particles
                for (let i = this.activeParticles.length - 1; i >= 0; i--) {
                    const particle = this.activeParticles[i];
                    
                    // Update position based on velocity
                    particle.position.x += particle.velocity.x * deltaTime;
                    particle.position.y += particle.velocity.y * deltaTime;
                    particle.position.z += particle.velocity.z * deltaTime;
                    
                    // Update geometry
                    const idx = particle.index * 3;
                    positions[idx] = particle.position.x;
                    positions[idx + 1] = particle.position.y;
                    positions[idx + 2] = particle.position.z;
                    
                    // Recycle particle if it falls below ground
                    if (particle.position.y < 0) {
                        this.recycleParticle(particle, i);
                    }
                }
                
                this.particleGeometry.attributes.position.needsUpdate = true;
            }

            // Recycle a particle (reuse it)
            recycleParticle(particle, activeIndex) {
                // Remove from active list
                this.activeParticles.splice(activeIndex, 1);
                
                // Respawn based on weather type
                if (this.weatherType === 'rain') {
                    this.spawnRainParticle();
                } else if (this.weatherType === 'snow') {
                    this.spawnSnowParticle();
                }
            }

            // Set particle count (for performance adjustment)
            setParticleCount(count) {
                const targetCount = Math.min(count, this.maxParticles);
                const currentCount = this.activeParticles.length;
                
                if (targetCount < currentCount) {
                    // Reduce particles
                    const toRemove = currentCount - targetCount;
                    for (let i = 0; i < toRemove; i++) {
                        if (this.activeParticles.length > 0) {
                            const particle = this.activeParticles.pop();
                            particle.active = false;
                            
                            // Hide particle
                            const positions = this.particleGeometry.attributes.position.array;
                            const idx = particle.index * 3;
                            positions[idx + 1] = -1000;
                        }
                    }
                    this.particleGeometry.attributes.position.needsUpdate = true;
                } else if (targetCount > currentCount) {
                    // Add particles
                    const toAdd = targetCount - currentCount;
                    for (let i = 0; i < toAdd; i++) {
                        if (this.weatherType === 'rain') {
                            this.spawnRainParticle();
                        } else if (this.weatherType === 'snow') {
                            this.spawnSnowParticle();
                        }
                    }
                }
                
                debug.log('Particle count adjusted to:', this.activeParticles.length);
            }

            // Dispose of weather system
            dispose() {
                if (this.particleSystem) {
                    this.scene.remove(this.particleSystem);
                }
                if (this.particleGeometry) {
                    this.particleGeometry.dispose();
                }
                if (this.particleMaterial) {
                    this.particleMaterial.dispose();
                }
                this.clearFog();
            }
        }

        // Day-Night Cycle phase definitions
        const DAY_NIGHT_PHASES = {
            dawn: { duration: 30, ambientIntensity: 0.4, lightColor: 0xffaa88 },
            day: { duration: 60, ambientIntensity: 1.0, lightColor: 0xffffff },
            dusk: { duration: 30, ambientIntensity: 0.5, lightColor: 0xff8844 },
            night: { duration: 60, ambientIntensity: 0.3, lightColor: 0x6688cc }
        };

        // Day-Night Cycle for dynamic lighting transitions
        class DayNightCycle {
            constructor(ambientLight, directionalLight) {
                this.ambientLight = ambientLight;
                this.directionalLight = directionalLight;
                
                this.enabled = false;
                this.currentPhase = 'day';
                this.phaseElapsedTime = 0;
                this.transitionDuration = 30; // 30 seconds for transitions (Requirement 3.2)
                this.transitionProgress = 0;
                this.isTransitioning = false;
                
                // Phase order for progression
                this.phaseOrder = ['dawn', 'day', 'dusk', 'night'];
                this.currentPhaseIndex = 1; // Start at day
                
                // Store previous phase for transitions
                this.previousPhase = null;
                
                // Store original lighting values for restoration
                this.originalAmbientIntensity = ambientLight ? ambientLight.intensity : 1.0;
                this.originalDirectionalColor = directionalLight ? directionalLight.color.getHex() : 0xffffff;
                
                debug.log('DayNightCycle initialized');
            }

            // Enable or disable the day-night cycle
            enableDayNightCycle(enabled) {
                this.enabled = enabled;
                
                if (enabled) {
                    debug.log('Day-night cycle enabled');
                    // Start from current phase
                    this.phaseElapsedTime = 0;
                    this.isTransitioning = false;
                } else {
                    debug.log('Day-night cycle disabled');
                    // Restore to day phase
                    this.currentPhase = 'day';
                    this.currentPhaseIndex = 1;
                    this.applyPhase('day');
                }
            }

            // Get current phase
            getCurrentPhase() {
                return this.currentPhase;
            }

            // Update the day-night cycle
            update(deltaTime) {
                if (!this.enabled) return;
                
                this.phaseElapsedTime += deltaTime;
                
                const currentPhaseConfig = DAY_NIGHT_PHASES[this.currentPhase];
                const phaseDuration = currentPhaseConfig.duration;
                
                // Check if we're in transition period (first 30 seconds of phase)
                if (this.phaseElapsedTime <= this.transitionDuration) {
                    this.isTransitioning = true;
                    // Calculate transition progress (0 to 1) over 30 seconds
                    this.transitionProgress = this.phaseElapsedTime / this.transitionDuration;
                    this.updatePhaseTransition();
                } else {
                    // Transition complete, maintain current phase lighting
                    this.isTransitioning = false;
                    if (this.transitionProgress < 1.0) {
                        // Ensure we're at full phase values
                        this.transitionProgress = 1.0;
                        this.applyPhase(this.currentPhase);
                    }
                }
                
                // Check if phase is complete
                if (this.phaseElapsedTime >= phaseDuration) {
                    // Move to next phase
                    this.advanceToNextPhase();
                }
            }

            // Advance to the next phase in the cycle
            advanceToNextPhase() {
                // Store current phase as previous
                this.previousPhase = this.currentPhase;
                
                // Move to next phase
                this.currentPhaseIndex = (this.currentPhaseIndex + 1) % this.phaseOrder.length;
                this.currentPhase = this.phaseOrder[this.currentPhaseIndex];
                this.phaseElapsedTime = 0;
                this.transitionProgress = 0;
                this.isTransitioning = true;
                
                debug.log('Day-night cycle advanced to phase:', this.currentPhase);
            }

            // Update lighting during phase transition
            updatePhaseTransition() {
                if (!this.ambientLight || !this.directionalLight) return;
                
                // Get previous and current phase configs
                const prevPhase = this.previousPhase || this.phaseOrder[(this.currentPhaseIndex - 1 + this.phaseOrder.length) % this.phaseOrder.length];
                const prevPhaseConfig = DAY_NIGHT_PHASES[prevPhase];
                const currentPhaseConfig = DAY_NIGHT_PHASES[this.currentPhase];
                
                // Lerp ambient light intensity between previous and current phase
                const fromIntensity = prevPhaseConfig.ambientIntensity;
                const toIntensity = currentPhaseConfig.ambientIntensity;
                this.ambientLight.intensity = fromIntensity + (toIntensity - fromIntensity) * this.transitionProgress;
                
                // Lerp directional light color between previous and current phase
                const fromColor = new THREE.Color(prevPhaseConfig.lightColor);
                const toColor = new THREE.Color(currentPhaseConfig.lightColor);
                this.directionalLight.color.lerpColors(fromColor, toColor, this.transitionProgress);
            }

            // Apply a specific phase immediately (for initialization or disabling)
            applyPhase(phaseName) {
                if (!DAY_NIGHT_PHASES[phaseName]) {
                    debug.error('Invalid phase name:', phaseName);
                    return;
                }
                
                const phaseConfig = DAY_NIGHT_PHASES[phaseName];
                
                if (this.ambientLight) {
                    this.ambientLight.intensity = phaseConfig.ambientIntensity;
                }
                
                if (this.directionalLight) {
                    this.directionalLight.color.setHex(phaseConfig.lightColor);
                }
            }
        }

        // Performance Monitor for tracking FPS and adjusting quality
        class PerformanceMonitor {
            constructor() {
                this.currentFPS = 60;
                this.targetFPS = 60;
                this.qualityLevel = 3; // 0-3 (low to high)
                this.consecutiveLowFrames = 0;
                this.consecutiveHighFrames = 0;
                this.lastFPSCheck = 0;
                this.fpsCheckInterval = 1000; // 1 second in milliseconds
                this.frameCount = 0;
                this.lastFrameTime = performance.now();
                
                // Thresholds
                this.lowFPSThreshold = 60;
                this.criticalFPSThreshold = 45;
                this.highFPSThreshold = 65;
                this.lowFPSConsecutiveSeconds = 3;
                this.highFPSConsecutiveSeconds = 5;
                
                // Store previous quality settings for restoration
                this.previousQualityLevel = 3;
                this.previousParticleCount = 500;
                
                debug.log('PerformanceMonitor initialized');
            }

            // Update FPS tracking
            update(deltaTime) {
                const now = performance.now();
                this.frameCount++;
                
                // Check FPS every 1 second
                if (now - this.lastFPSCheck >= this.fpsCheckInterval) {
                    // Calculate FPS
                    const elapsed = (now - this.lastFPSCheck) / 1000;
                    this.currentFPS = this.frameCount / elapsed;
                    
                    // Reset counters
                    this.frameCount = 0;
                    this.lastFPSCheck = now;
                    
                    // Check performance thresholds
                    this.checkPerformanceThresholds();
                    
                    if (DEBUG_MODE) {
                        debug.log('FPS:', this.currentFPS.toFixed(1));
                    }
                }
            }

            // Check if FPS crosses thresholds
            checkPerformanceThresholds() {
                // Check for low FPS
                if (this.currentFPS < this.lowFPSThreshold) {
                    this.consecutiveLowFrames++;
                    this.consecutiveHighFrames = 0;
                    
                    if (DEBUG_MODE) {
                        debug.log('Low FPS detected:', this.currentFPS.toFixed(1), 'Consecutive:', this.consecutiveLowFrames);
                    }
                    
                    // Trigger quality reduction after consecutive low frames
                    if (this.consecutiveLowFrames >= this.lowFPSConsecutiveSeconds) {
                        this.reduceQuality();
                        this.consecutiveLowFrames = 0; // Reset after adjustment
                    }
                } 
                // Check for high FPS (recovery)
                else if (this.currentFPS > this.highFPSThreshold) {
                    this.consecutiveHighFrames++;
                    this.consecutiveLowFrames = 0;
                    
                    // Trigger quality restoration after consecutive high frames
                    if (this.consecutiveHighFrames >= this.highFPSConsecutiveSeconds) {
                        this.restoreQuality();
                        this.consecutiveHighFrames = 0; // Reset after adjustment
                    }
                } 
                // FPS is in acceptable range
                else {
                    this.consecutiveLowFrames = 0;
                    this.consecutiveHighFrames = 0;
                }
            }

            // Reduce quality settings
            reduceQuality() {
                if (this.qualityLevel <= 0) {
                    debug.log('Already at minimum quality level');
                    return;
                }
                
                // Store previous quality level for restoration
                this.previousQualityLevel = this.qualityLevel;
                
                // Check for severe performance degradation (FPS < 30) - disable ALL environmental effects
                if (this.currentFPS < 30) {
                    debug.error('üö® SEVERE PERFORMANCE DEGRADATION! Disabling all environmental effects');
                    this.qualityLevel = 0;
                    
                    // Disable all environmental effects
                    if (gameState.environmentManager) {
                        // Disable weather
                        if (gameState.environmentManager.weatherSystem) {
                            gameState.environmentManager.weatherSystem.setParticleCount(0);
                            gameState.environmentManager.weatherSystemEnabled = false;
                        }
                        
                        // Disable day-night cycle
                        if (gameState.environmentManager.dayNightCycle) {
                            gameState.environmentManager.dayNightCycle.enableDayNightCycle(false);
                        }
                        
                        // Environmental audio removed (simplified audio system)
                    }
                    
                    if (DEBUG_MODE) {
                        console.log('Performance adjustment: All environmental effects disabled due to severe performance degradation');
                    }
                }
                // Check if we need to disable weather entirely (critical FPS < 45)
                else if (this.currentFPS < this.criticalFPSThreshold) {
                    debug.log('‚ö†Ô∏è Critical FPS detected! Disabling weather entirely');
                    this.qualityLevel = 0;
                    
                    // Disable weather in environment manager
                    if (gameState.environmentManager && gameState.environmentManager.weatherSystem) {
                        gameState.environmentManager.weatherSystem.setParticleCount(0);
                    }
                    
                    if (DEBUG_MODE) {
                        console.log('Performance adjustment: Weather disabled due to critical FPS');
                    }
                } else {
                    // Reduce particle count by 50%
                    this.qualityLevel--;
                    
                    if (gameState.environmentManager && gameState.environmentManager.weatherSystem) {
                        const currentCount = gameState.environmentManager.weatherSystem.activeParticles.length;
                        const newCount = Math.floor(currentCount * 0.5);
                        
                        // Store previous count for restoration
                        this.previousParticleCount = currentCount;
                        
                        gameState.environmentManager.weatherSystem.setParticleCount(newCount);
                        
                        debug.log('‚ö†Ô∏è Reducing particle count by 50%:', currentCount, '->', newCount);
                        
                        if (DEBUG_MODE) {
                            console.log('Performance adjustment: Particle count reduced to', newCount);
                        }
                    }
                }
            }

            // Restore quality settings
            restoreQuality() {
                if (this.qualityLevel >= 3) {
                    debug.log('Already at maximum quality level');
                    return;
                }
                
                // Restore to previous quality level
                this.qualityLevel = Math.min(this.previousQualityLevel, 3);
                
                if (gameState.environmentManager && gameState.environmentManager.weatherSystem) {
                    // Restore particle count
                    const targetCount = this.previousParticleCount;
                    gameState.environmentManager.weatherSystem.setParticleCount(targetCount);
                    
                    debug.log('‚úì Restoring quality. Particle count:', targetCount);
                    
                    if (DEBUG_MODE) {
                        console.log('Performance adjustment: Quality restored to level', this.qualityLevel);
                    }
                }
            }

            // Get current FPS
            getCurrentFPS() {
                return this.currentFPS;
            }

            // Get quality level
            getQualityLevel() {
                return this.qualityLevel;
            }
        }

        // Adaptive Difficulty Manager
        class DifficultyManager {
            constructor() {
                this.hits = 0;
                this.misses = 0;
                this.spawnInterval = 1400;
                this.visibleTime = 1200;
                this.emergeTime = 0.3;
                this.maxSimultaneous = 2;
                
                // Difficulty progression thresholds
                this.accuracyCheckInterval = 3; // Check every 3 actions (more frequent)
                this.lastCheck = 0;
            }

            recordHit() {
                this.hits++;
                this.checkAndAdjust();
            }

            recordMiss() {
                this.misses++;
                this.checkAndAdjust();
            }

            getAccuracy() {
                const total = this.hits + this.misses;
                return total > 0 ? this.hits / total : 0;
            }

            checkAndAdjust() {
                const total = this.hits + this.misses;
                
                // Only adjust every N actions
                if (total - this.lastCheck < this.accuracyCheckInterval) return;
                
                this.lastCheck = total;
                const accuracy = this.getAccuracy();
                
                debug.log('Accuracy:', (accuracy * 100).toFixed(1) + '%', 'Hits:', this.hits, 'Misses:', this.misses);
                
                // High accuracy (>70%) - make it harder
                if (accuracy > 0.7) {
                    this.spawnInterval = Math.max(500, this.spawnInterval - 150);
                    this.visibleTime = Math.max(400, this.visibleTime - 120);
                    this.emergeTime = Math.max(0.15, this.emergeTime - 0.03);
                    
                    // Increase simultaneous creatures more aggressively
                    if (this.hits > 10 && this.maxSimultaneous < 3) {
                        this.maxSimultaneous = 3;
                    } else if (this.hits > 20 && this.maxSimultaneous < 4) {
                        this.maxSimultaneous = 4;
                    } else if (this.hits > 35 && this.maxSimultaneous < 5) {
                        this.maxSimultaneous = 5;
                    }
                    
                    debug.log('üî• Difficulty increased! Interval:', this.spawnInterval, 'Visible:', this.visibleTime, 'Simultaneous:', this.maxSimultaneous);
                }
                // Low accuracy (<50%) - make it easier
                else if (accuracy < 0.5) {
                    this.spawnInterval = Math.min(2000, this.spawnInterval + 150);
                    this.visibleTime = Math.min(1800, this.visibleTime + 120);
                    this.emergeTime = Math.min(0.4, this.emergeTime + 0.03);
                    this.maxSimultaneous = Math.max(1, this.maxSimultaneous - 1);
                    debug.log('üíö Difficulty decreased');
                }
                
                // Update creature manager immediately
                if (gameState.creatureManager) {
                    gameState.creatureManager.spawnInterval = this.spawnInterval;
                    gameState.creatureManager.visibleTime = this.visibleTime;
                    gameState.creatureManager.emergeTime = this.emergeTime;
                    gameState.creatureManager.maxSimultaneous = this.maxSimultaneous;
                }
                
                this.updateUI();
            }

            updateUI() {
                const accuracy = this.getAccuracy();
                const accuracyPercent = (accuracy * 100).toFixed(0);
                document.getElementById('level-progress').textContent = `${accuracyPercent}% Accuracy`;
                document.getElementById('current-level').textContent = `${this.maxSimultaneous}x Gophers`;
            }
        }

        let gameState = {
            initialized: false,
            webXRSupported: false,
            scene: null,
            camera: null,
            renderer: null,
            gameStarted: false,
            paused: false,
            holeManager: null,
            creatureManager: null,
            scoreManager: null,
            inputManager: null,
            difficultyManager: null,
            comboManager: null,
            audioManager: null,
            highScoreManager: null,
            powerUpManager: null,
            specialEventsManager: null,
            chaosEventManager: null,
            environmentManager: null,
            environmentCycleManager: null,
            performanceMonitor: null,
            progressionManager: null,
            visualEffectsManager: null,
            cameraEffectsManager: null,
            streakManager: null
        };

        // Minimal HoleManager
        class HoleManager {
            constructor(scene) {
                this.scene = scene;
                this.holes = [];
            }

            createHoleGrid() {
                // Create invisible spawn points across the grass area
                const numHoles = 12; // More spawn points for variety
                const areaSize = 2; // 2x2 meter area
                
                for (let i = 0; i < numHoles; i++) {
                    // Random positions within the play area
                    const x = (Math.random() - 0.5) * areaSize;
                    const z = (Math.random() - 0.5) * areaSize;
                    
                    this.holes.push({
                        position: new THREE.Vector3(x, 0, z),
                        occupied: false
                    });
                }
                debug.log('Created', this.holes.length, 'invisible spawn points');
            }

            getRandomHole() {
                const availableHoles = this.holes.filter(h => !h.occupied);
                if (availableHoles.length === 0) return null;
                return availableHoles[Math.floor(Math.random() * availableHoles.length)];
            }

            getAdjacentHoles(centerHole, count) {
                // Find the closest unoccupied holes to the center hole
                const availableHoles = this.holes.filter(h => !h.occupied && h !== centerHole);
                
                // Sort by distance to center hole
                availableHoles.sort((a, b) => {
                    const distA = centerHole.position.distanceTo(a.position);
                    const distB = centerHole.position.distanceTo(b.position);
                    return distA - distB;
                });
                
                // Return the closest 'count' holes
                return availableHoles.slice(0, count);
            }
        }

        // Easing function for smooth animations
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function easeInCubic(t) {
            return t * t * t;
        }

        // Particle effect system
        class ParticleEffect {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
            }

            createHitEffect(position) {
                const particleCount = 8;
                const particles = [];

                for (let i = 0; i < particleCount; i++) {
                    const geo = new THREE.SphereGeometry(0.02, 8, 8);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const particle = new THREE.Mesh(geo, mat);
                    
                    particle.position.copy(position);
                    
                    const angle = (i / particleCount) * Math.PI * 2;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * 0.5,
                        Math.random() * 0.5 + 0.3,
                        Math.sin(angle) * 0.5
                    );
                    particle.userData.life = 1.0;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.particles.push(...particles);
            }

            createExplosionEffect(position) {
                const particleCount = 16;
                const particles = [];

                for (let i = 0; i < particleCount; i++) {
                    const geo = new THREE.SphereGeometry(0.03, 8, 8);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const particle = new THREE.Mesh(geo, mat);
                    
                    particle.position.copy(position);
                    
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 0.8 + Math.random() * 0.4;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 0.8 + 0.2,
                        Math.sin(angle) * speed
                    );
                    particle.userData.life = 1.2;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }

                this.particles.push(...particles);
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(deltaTime));
                    particle.userData.velocity.y -= deltaTime * 2; // gravity
                    particle.userData.life -= deltaTime * 2;
                    
                    particle.material.opacity = particle.userData.life;
                    particle.material.transparent = true;
                    
                    if (particle.userData.life <= 0) {
                        this.scene.remove(particle);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        // Score popup system with enhanced animations
        class ScorePopup {
            constructor(scene) {
                this.scene = scene;
                this.popups = [];
            }

            create(position, score, comboMultiplier = 1.0) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                // Determine color based on score value
                let color = '#ffff00'; // Default yellow
                if (score < 0) {
                    color = '#ff4444'; // Red for negative
                } else if (score >= 300) {
                    color = '#FFD700'; // Gold for high scores
                } else if (comboMultiplier >= 2.0) {
                    color = '#FF6B6B'; // Orange-red for combos
                }
                
                // Scale font size based on combo multiplier
                const baseFontSize = 48;
                const fontSize = Math.min(baseFontSize * (1 + comboMultiplier * 0.2), 72);
                
                ctx.fillStyle = color;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const text = score > 0 ? '+' + score : score.toString();
                
                // Draw text with outline for better visibility
                ctx.strokeText(text, 128, 64);
                ctx.fillText(text, 128, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                
                sprite.position.copy(position);
                sprite.position.y += 0.3;
                
                // Scale sprite based on combo multiplier
                const baseScale = 0.4;
                const scale = baseScale * (1 + comboMultiplier * 0.15);
                sprite.scale.set(scale, scale * 0.5, 1);
                
                sprite.userData.life = 1.5; // Longer lifetime for better visibility
                sprite.userData.startY = sprite.position.y;
                sprite.userData.startScale = scale;
                
                this.scene.add(sprite);
                this.popups.push(sprite);
            }

            update(deltaTime) {
                for (let i = this.popups.length - 1; i >= 0; i--) {
                    const popup = this.popups[i];
                    
                    popup.userData.life -= deltaTime;
                    const lifeRatio = popup.userData.life / 1.5;
                    
                    // Animated upward movement with easing
                    const progress = 1 - lifeRatio;
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    popup.position.y = popup.userData.startY + easeOut * 0.8;
                    
                    // Fade out with slight scale animation
                    popup.material.opacity = Math.max(0, lifeRatio);
                    const scaleAnim = 1 + Math.sin(progress * Math.PI) * 0.1;
                    popup.scale.set(
                        popup.userData.startScale * scaleAnim,
                        popup.userData.startScale * 0.5 * scaleAnim,
                        1
                    );
                    
                    if (popup.userData.life <= 0) {
                        this.scene.remove(popup);
                        popup.material.map.dispose();
                        popup.material.dispose();
                        this.popups.splice(i, 1);
                    }
                }
            }
        }

        // Ability System for creature special abilities
        const CREATURE_ABILITIES = {
            teleport: {
                probability: 0.15,
                name: 'teleport',
                color: 0x9370DB, // Purple indicator
                onHit: function(creature, creatureManager) {
                    // Move creature to random hole instantly
                    const newHole = creatureManager.holeManager.getRandomHole();
                    if (newHole && newHole !== creature.hole) {
                        // Free old hole
                        creature.hole.occupied = false;
                        
                        // Move to new hole
                        creature.hole = newHole;
                        newHole.occupied = true;
                        
                        // Update position
                        creature.mesh.position.x = newHole.position.x;
                        creature.mesh.position.z = newHole.position.z;
                        creature.holeMesh.position.set(newHole.position.x, -0.05, newHole.position.z);
                        creature.rimMesh.position.set(newHole.position.x, 0.01, newHole.position.z);
                        
                        // Reset walk offset
                        creature.walkOffset.set(0, 0, 0);
                        
                        debug.log('Creature teleported to new hole!');
                        return true; // Ability triggered
                    }
                    return false;
                }
            },
            shield: {
                probability: 0.10,
                name: 'shield',
                color: 0x4169E1, // Blue indicator
                health: 2
            },
            speed: {
                probability: 0.15,
                name: 'speed',
                color: 0xFFFF00, // Yellow indicator
                speedMultiplier: 2.0
            },
            split: {
                probability: 0.10,
                name: 'split',
                color: 0x00FF00, // Green indicator
                onDefeat: function(creature, creatureManager) {
                    // Spawn 2 smaller creatures at adjacent holes
                    const adjacentHoles = creatureManager.holeManager.getAdjacentHoles(creature.hole, 2);
                    
                    adjacentHoles.forEach(hole => {
                        if (!hole.occupied) {
                            creatureManager.spawnSplitCreature(hole, creature.animalType, 0.7);
                        }
                    });
                    
                    debug.log('Creature split into 2 smaller creatures!');
                }
            }
        };

        class AbilitySystem {
            constructor(audioManager) {
                this.audioManager = audioManager;
            }

            assignAbility(creature) {
                // Don't assign abilities to bombs, golden, or boss creatures
                if (creature.type === 'bomb' || creature.type === 'golden' || creature.type === 'boss') {
                    return null;
                }

                const rand = Math.random();
                let cumulativeProbability = 0;

                for (const abilityKey in CREATURE_ABILITIES) {
                    const ability = CREATURE_ABILITIES[abilityKey];
                    cumulativeProbability += ability.probability;
                    
                    if (rand < cumulativeProbability) {
                        creature.ability = ability.name;
                        creature.abilityActive = true;
                        
                        // Set health for shield ability
                        if (ability.name === 'shield') {
                            creature.health = ability.health;
                            creature.maxHealth = ability.health;
                        } else {
                            creature.health = 1;
                            creature.maxHealth = 1;
                        }
                        
                        debug.log('Assigned ability:', ability.name, 'to', creature.animalType);
                        return ability;
                    }
                }

                // No ability assigned
                creature.ability = null;
                creature.abilityActive = false;
                creature.health = 1;
                creature.maxHealth = 1;
                return null;
            }

            addVisualIndicator(creature, ability) {
                if (!ability) return;

                // Create glowing sphere indicator
                const indicatorGeo = new THREE.SphereGeometry(0.15, 16, 16);
                let indicatorMat;
                
                if (ability.name === 'shield') {
                    // Shield gets a solid blue glow sphere
                    indicatorMat = new THREE.MeshBasicMaterial({
                        color: ability.color,
                        transparent: true,
                        opacity: 0.4
                    });
                } else {
                    // Other abilities get wireframe
                    indicatorMat = new THREE.MeshBasicMaterial({
                        color: ability.color,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                }
                
                const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
                indicator.position.y = 0.15;
                indicator.name = 'abilityIndicator';
                creature.mesh.add(indicator);

                // Animate indicator (pulsing)
                creature.indicatorPhase = 0;
            }

            updateIndicators(creatures, deltaTime) {
                creatures.forEach(creature => {
                    if (creature.ability && creature.abilityActive) {
                        const indicator = creature.mesh.getObjectByName('abilityIndicator');
                        if (indicator) {
                            creature.indicatorPhase = (creature.indicatorPhase || 0) + deltaTime * 3;
                            const scale = 1 + Math.sin(creature.indicatorPhase) * 0.2;
                            indicator.scale.set(scale, scale, scale);
                            indicator.rotation.y += deltaTime * 2;
                        }
                    }
                });
            }

            triggerAbility(creature, creatureManager, abilityType) {
                const ability = CREATURE_ABILITIES[abilityType];
                if (!ability) return false;

                try {
                    // Play ability sound
                    this.playAbilitySound(abilityType);

                    // Execute ability-specific logic
                    if (abilityType === 'teleport' && ability.onHit) {
                        return ability.onHit(creature, creatureManager);
                    }

                    return false;
                } catch (e) {
                    debug.error('Failed to trigger ability:', abilityType, e);
                    // Continue without ability - don't crash the game
                    return false;
                }
            }

            handleDefeat(creature, creatureManager) {
                if (creature.ability === 'split') {
                    const ability = CREATURE_ABILITIES.split;
                    if (ability.onDefeat) {
                        ability.onDefeat(creature, creatureManager);
                    }
                }
            }

            playAbilitySound(abilityType) {
                if (!this.audioManager || !this.audioManager.enabled || !this.audioManager.audioContext) return;

                const ctx = this.audioManager.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                // Different sounds for different abilities
                if (abilityType === 'teleport') {
                    // Whoosh sound - descending pitch
                    osc.frequency.setValueAtTime(800, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.25, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.2);
                } else if (abilityType === 'shield') {
                    // Shield break sound - metallic
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.15);
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.15);
                } else if (abilityType === 'speed') {
                    // Speed sound - rapid ascending
                    osc.frequency.setValueAtTime(300, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(900, ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.1);
                } else if (abilityType === 'split') {
                    // Split sound - two quick beeps
                    [0, 0.1].forEach(delay => {
                        const osc2 = ctx.createOscillator();
                        const gain2 = ctx.createGain();
                        osc2.connect(gain2);
                        gain2.connect(ctx.destination);
                        osc2.frequency.value = 600;
                        gain2.gain.setValueAtTime(0.15, ctx.currentTime + delay);
                        gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + delay + 0.08);
                        osc2.start(ctx.currentTime + delay);
                        osc2.stop(ctx.currentTime + delay + 0.08);
                    });
                }
            }
        }

        // Special Creature Type Classes
        
        // Speed Boost Creature - 50% faster emergence/retreat
        class SpeedBoostCreature {
            constructor(baseCreature) {
                this.creature = baseCreature;
                this.type = 'speed';
                this.scoreValue = 150;
                this.speedMultiplier = 1.5; // 50% faster
                
                // Apply speed modifications
                if (this.creature) {
                    this.creature.emergeTime = this.creature.emergeTime / this.speedMultiplier;
                    this.creature.retreatTime = this.creature.retreatTime / this.speedMultiplier;
                    this.creature.specialType = 'speed';
                }
            }
            
            update(deltaTime, scene) {
                // Add motion blur visual effect
                if (this.creature && this.creature.mesh && this.creature.state === 'visible') {
                    // Create subtle motion blur trail
                    if (!this.creature.motionBlurTrail) {
                        this.creature.motionBlurTrail = [];
                    }
                    
                    const now = Date.now();
                    this.creature.motionBlurTrail.push({
                        position: this.creature.mesh.position.clone(),
                        time: now
                    });
                    
                    // Keep only recent trail positions (100ms)
                    this.creature.motionBlurTrail = this.creature.motionBlurTrail.filter(t => now - t.time < 100);
                }
            }
        }
        
        // Teleporting Creature - changes holes every 0.5 seconds
        class TeleportingCreature {
            constructor(baseCreature, holeManager) {
                this.creature = baseCreature;
                this.holeManager = holeManager;
                this.type = 'teleport';
                this.scoreValue = 200;
                this.teleportInterval = 500; // 0.5 seconds
                this.lastTeleport = Date.now();
                this.particleTrail = [];
                
                if (this.creature) {
                    this.creature.specialType = 'teleport';
                }
            }
            
            update(deltaTime, scene, visualEffectsManager) {
                if (!this.creature || this.creature.state !== 'visible') {
                    return;
                }
                
                const now = Date.now();
                
                // Teleport to new hole every 0.5 seconds
                if (now - this.lastTeleport > this.teleportInterval) {
                    const currentHole = this.creature.hole;
                    const newHole = this.holeManager.getRandomHole();
                    
                    if (newHole && newHole !== currentHole) {
                        // Spawn particle trail effect
                        if (visualEffectsManager) {
                            this.spawnTeleportTrail(scene, this.creature.mesh.position, newHole.position);
                        }
                        
                        // Free old hole
                        currentHole.occupied = false;
                        
                        // Move to new hole
                        newHole.occupied = true;
                        this.creature.hole = newHole;
                        this.creature.mesh.position.set(newHole.position.x, this.creature.targetY, newHole.position.z);
                        
                        // Reset walk offset
                        this.creature.walkOffset.set(0, 0, 0);
                        
                        this.lastTeleport = now;
                    }
                }
            }
            
            spawnTeleportTrail(scene, fromPos, toPos) {
                // Create particle trail between positions
                const particleCount = 8;
                for (let i = 0; i < particleCount; i++) {
                    const t = i / particleCount;
                    const pos = new THREE.Vector3().lerpVectors(fromPos, toPos, t);
                    
                    const geo = new THREE.SphereGeometry(0.02, 8, 8);
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: 0x9370DB, // Purple for teleport
                        transparent: true,
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(geo, mat);
                    particle.position.copy(pos);
                    scene.add(particle);
                    
                    this.particleTrail.push({
                        mesh: particle,
                        life: 0.5,
                        maxLife: 0.5
                    });
                }
            }
            
            updateParticles(deltaTime, scene) {
                // Update and remove old particles
                for (let i = this.particleTrail.length - 1; i >= 0; i--) {
                    const p = this.particleTrail[i];
                    p.life -= deltaTime;
                    
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        this.particleTrail.splice(i, 1);
                    } else {
                        p.mesh.material.opacity = p.life / p.maxLife;
                    }
                }
            }
        }
        
        // Shield Creature - requires 2 hits (first cracks shield, second scores)
        class ShieldCreature {
            constructor(baseCreature, scene) {
                this.creature = baseCreature;
                this.type = 'shield';
                this.scoreValue = 250;
                this.health = 2;
                this.maxHealth = 2;
                this.shieldMesh = null;
                
                if (this.creature) {
                    this.creature.specialType = 'shield';
                    this.creature.shieldHealth = 2;
                }
                
                // Create shield visual overlay
                this.createShieldOverlay(scene);
            }
            
            createShieldOverlay(scene) {
                if (!this.creature || !this.creature.mesh) return;
                
                // Create glowing shield sphere around creature
                const shieldGeo = new THREE.SphereGeometry(0.18, 16, 16);
                const shieldMat = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF, // Cyan shield
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });
                this.shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
                this.creature.mesh.add(this.shieldMesh);
            }
            
            hit(scene, visualEffectsManager) {
                this.health--;
                
                if (this.health === 1) {
                    // First hit - crack shield
                    if (this.shieldMesh) {
                        this.shieldMesh.material.color.setHex(0xFF6347); // Red for damaged
                        this.shieldMesh.material.opacity = 0.5;
                        
                        // Add crack effect
                        this.shieldMesh.scale.set(1.2, 1.2, 1.2);
                    }
                    
                    // Spawn crack particles
                    if (visualEffectsManager && this.creature) {
                        visualEffectsManager.spawnHitEffect(this.creature.mesh.position, 'shield', 0.5);
                    }
                    
                    return false; // Not defeated yet
                } else {
                    // Second hit - destroy shield and score
                    if (this.shieldMesh) {
                        this.creature.mesh.remove(this.shieldMesh);
                        this.shieldMesh.geometry.dispose();
                        this.shieldMesh.material.dispose();
                        this.shieldMesh = null;
                    }
                    
                    return true; // Defeated
                }
            }
            
            update(deltaTime) {
                // Animate shield pulsing
                if (this.shieldMesh) {
                    const pulse = Math.sin(Date.now() * 0.005) * 0.05 + 1;
                    this.shieldMesh.scale.set(pulse, pulse, pulse);
                    this.shieldMesh.rotation.y += deltaTime * 2;
                }
            }
        }
        
        // Mimic Creature - splits into 2 smaller creatures on hit
        class MimicCreature {
            constructor(baseCreature) {
                this.creature = baseCreature;
                this.type = 'mimic';
                this.scoreValue = 0; // Original gives no points
                this.splitScoreValue = 100; // Each split gives 100 points
                this.hasSplit = false;
                
                if (this.creature) {
                    this.creature.specialType = 'mimic';
                }
            }
            
            split(scene, holeManager, creatureManager, visualEffectsManager) {
                if (this.hasSplit || !this.creature) return [];
                
                this.hasSplit = true;
                const splitCreatures = [];
                
                // Get two nearby holes
                const holes = [
                    holeManager.getRandomHole(),
                    holeManager.getRandomHole()
                ];
                
                // Spawn split animation particles
                if (visualEffectsManager) {
                    visualEffectsManager.spawnHitEffect(this.creature.mesh.position, 'mimic', 1.5);
                }
                
                // Create 2 smaller creatures
                for (let i = 0; i < 2; i++) {
                    const hole = holes[i];
                    if (!hole) continue;
                    
                    hole.occupied = true;
                    
                    // Create smaller version of the creature
                    const smallCreatureMesh = this.creature.mesh.clone();
                    smallCreatureMesh.scale.set(0.6, 0.6, 0.6); // 60% size
                    smallCreatureMesh.position.copy(hole.position);
                    smallCreatureMesh.position.y = hole.position.y + 0.3;
                    scene.add(smallCreatureMesh);
                    
                    // Create hole visuals
                    const holeGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
                    const holeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                    const holeMesh = new THREE.Mesh(holeGeo, holeMat);
                    holeMesh.position.set(hole.position.x, -0.05, hole.position.z);
                    holeMesh.receiveShadow = true;
                    scene.add(holeMesh);

                    const rimGeo = new THREE.TorusGeometry(0.15, 0.03, 8, 16);
                    const rimMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                    const rimMesh = new THREE.Mesh(rimGeo, rimMat);
                    rimMesh.rotation.x = Math.PI / 2;
                    rimMesh.position.set(hole.position.x, 0.01, hole.position.z);
                    rimMesh.castShadow = true;
                    scene.add(rimMesh);
                    
                    const splitCreature = {
                        mesh: smallCreatureMesh,
                        hole: hole,
                        holeMesh: holeMesh,
                        rimMesh: rimMesh,
                        type: 'standard',
                        animalType: this.creature.animalType,
                        state: 'visible',
                        startY: hole.position.y,
                        targetY: hole.position.y + 0.3,
                        progress: 1,
                        emergeTime: 0.3,
                        retreatTime: 0.3,
                        visibleTime: Date.now(),
                        visibleDuration: 1500, // 1.5 seconds visible
                        walkOffset: new THREE.Vector3(0, 0, 0),
                        walkAngle: Math.random() * Math.PI * 2,
                        bobPhase: Math.random() * Math.PI * 2,
                        baseRotation: Math.random() * Math.PI * 2,
                        emergenceRotation: 0,
                        idlePhase: Math.random() * Math.PI * 2,
                        personality: 'aggressive',
                        isMimicSplit: true,
                        mimicSplitValue: this.splitScoreValue
                    };
                    
                    splitCreatures.push(splitCreature);
                }
                
                return splitCreatures;
            }
        }

        // Boss Creature class
        class BossCreature {
            constructor(baseCreature, scale, health) {
                this.creature = baseCreature;
                this.health = health;
                this.maxHealth = health;
                this.scale = scale;
                this.scoreValue = 500;
                this.healthBarUI = null;
                this.spawnScore = 0;
                this.isRoaring = false;
                this.roarTime = 0;
                this.projectiles = [];
                this.lastProjectileTime = 0;
                this.projectileInterval = 3000; // Shoot every 3 seconds
                
                // Apply scale to creature mesh
                if (this.creature && this.creature.mesh) {
                    this.creature.mesh.scale.set(scale, scale, scale);
                }
            }

            takeDamage() {
                this.health--;
                this.updateHealthBar();
                debug.log('Boss health:', this.health);
                return this.health <= 0;
            }

            createHealthBar() {
                // Create health bar DOM element
                const healthBar = document.createElement('div');
                healthBar.style.position = 'fixed';
                healthBar.style.width = '200px';
                healthBar.style.height = '20px';
                healthBar.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                healthBar.style.border = '2px solid #fff';
                healthBar.style.borderRadius = '10px';
                healthBar.style.overflow = 'hidden';
                healthBar.style.zIndex = '1500';
                healthBar.style.pointerEvents = 'none';
                
                const healthFill = document.createElement('div');
                healthFill.style.width = '100%';
                healthFill.style.height = '100%';
                healthFill.style.backgroundColor = '#ff0000';
                healthFill.style.transition = 'width 0.3s ease';
                healthFill.id = 'boss-health-fill';
                
                healthBar.appendChild(healthFill);
                document.body.appendChild(healthBar);
                
                this.healthBarUI = healthBar;
                debug.log('Boss health bar created');
            }

            updateHealthBar() {
                if (!this.healthBarUI) return;
                
                const healthFill = document.getElementById('boss-health-fill');
                if (healthFill) {
                    const percentage = (this.health / this.maxHealth) * 100;
                    healthFill.style.width = percentage + '%';
                }
            }

            updateHealthBarPosition(camera, renderer) {
                if (!this.healthBarUI || !this.creature || !this.creature.mesh) return;
                
                // Project 3D position to screen coordinates
                const position = this.creature.mesh.position.clone();
                position.y += 0.8; // Position above boss
                
                const vector = position.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                const y = (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight;
                
                this.healthBarUI.style.left = (x - 100) + 'px'; // Center the 200px bar
                this.healthBarUI.style.top = (y - 30) + 'px';
            }

            removeHealthBar() {
                if (this.healthBarUI) {
                    document.body.removeChild(this.healthBarUI);
                    this.healthBarUI = null;
                    debug.log('Boss health bar removed');
                }
            }

            startRoar() {
                this.isRoaring = true;
                this.roarTime = Date.now();
                debug.log('Boss roaring!');
            }

            updateRoar(now) {
                if (!this.isRoaring) return;
                
                const elapsed = now - this.roarTime;
                if (elapsed > 1000) { // Roar lasts 1 second
                    this.isRoaring = false;
                    // Restore normal scale and rotation
                    if (this.creature && this.creature.mesh) {
                        this.creature.mesh.scale.set(this.scale, this.scale, this.scale);
                        this.creature.mesh.rotation.z = 0;
                    }
                    return;
                }
                
                // Roar animation - scale up and shake
                const progress = elapsed / 1000;
                const roarScale = 1 + Math.sin(progress * Math.PI) * 0.3;
                const shake = Math.sin(progress * Math.PI * 10) * 0.05;
                
                if (this.creature && this.creature.mesh) {
                    this.creature.mesh.scale.set(
                        this.scale * roarScale,
                        this.scale * roarScale,
                        this.scale * roarScale
                    );
                    this.creature.mesh.rotation.z = shake;
                }
            }

            shootProjectile(scene, targetPosition) {
                if (!this.creature || !this.creature.mesh) return null;
                
                const now = Date.now();
                if (now - this.lastProjectileTime < this.projectileInterval) return null;
                
                this.lastProjectileTime = now;
                
                // Create projectile
                const projectileGeo = new THREE.SphereGeometry(0.08, 8, 8);
                const projectileMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff4444,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                const projectileMesh = new THREE.Mesh(projectileGeo, projectileMat);
                
                // Start at boss position
                projectileMesh.position.copy(this.creature.mesh.position);
                projectileMesh.position.y += 0.2;
                scene.add(projectileMesh);
                
                // Calculate direction to target
                const direction = new THREE.Vector3()
                    .subVectors(targetPosition, projectileMesh.position)
                    .normalize();
                
                const projectile = {
                    mesh: projectileMesh,
                    direction: direction,
                    speed: 0.8, // Slow enough to dodge
                    lifetime: 5000, // 5 seconds
                    spawnTime: now
                };
                
                this.projectiles.push(projectile);
                debug.log('Boss fired projectile!');
                
                return projectile;
            }

            updateProjectiles(now, scene) {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    
                    // Check lifetime
                    if (now - proj.spawnTime > proj.lifetime) {
                        scene.remove(proj.mesh);
                        proj.mesh.geometry.dispose();
                        proj.mesh.material.dispose();
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Move projectile
                    const delta = 0.016; // Approximate frame time
                    proj.mesh.position.add(proj.direction.clone().multiplyScalar(proj.speed * delta * 60));
                    
                    // Add glow effect
                    proj.mesh.rotation.x += 0.1;
                    proj.mesh.rotation.y += 0.1;
                }
            }

            cleanupProjectiles(scene) {
                this.projectiles.forEach(proj => {
                    scene.remove(proj.mesh);
                    proj.mesh.geometry.dispose();
                    proj.mesh.material.dispose();
                });
                this.projectiles = [];
            }

            faceDirection(targetPosition) {
                if (!this.creature || !this.creature.mesh) return;
                
                const direction = new THREE.Vector3()
                    .subVectors(targetPosition, this.creature.mesh.position);
                const angle = Math.atan2(direction.x, direction.z);
                this.creature.mesh.rotation.y = angle;
            }
        }

        // Enhanced CreatureManager with better visuals
        class CreatureManager {
            constructor(scene, holeManager) {
                this.scene = scene;
                this.holeManager = holeManager;
                this.creatures = [];
                this.spawnInterval = 1400;
                this.visibleTime = 1200;
                this.emergeTime = 0.3;
                this.maxSimultaneous = 2;
                this.lastSpawn = 0;
                this.particleEffect = new ParticleEffect(scene);
                this.scorePopup = new ScorePopup(scene);
                this.freezeMultiplier = 1.0;
                
                // Boss creature system
                this.bossCreature = null;
                this.bossSpawnThreshold = 500; // Reduced from 1000 for more frequent bosses
                this.bossSpawned = false;
                
                // Ability system
                this.abilitySystem = new AbilitySystem(gameState.audioManager);
                
                // Variety tracking for Requirements 7.2, 7.4, 7.5
                this.lastSpawnedType = null; // Track last spawned type for color variation
                this.spawnHistory = []; // Track recent spawns for diversity enforcement
                
                // Chaos event flags
                this.gravityFlipped = false;
                this.sizeChaosActive = false;
                this.colorMadnessActive = false;
                this.cloneStormActive = false;
                this.cloneMultiplier = 1;
            }

            createMoleModel() {
                const group = new THREE.Group();
                
                // Body - improved material with better shading
                const bodyGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.2, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Head - improved material
                const headGeo = new THREE.SphereGeometry(0.09, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0x654321,
                    roughness: 0.7,
                    metalness: 0.1
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.13;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                // Nose
                const noseGeo = new THREE.SphereGeometry(0.03, 8, 8);
                const noseMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffb6c1,
                    roughness: 0.5,
                    metalness: 0.2
                });
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.position.set(0, 0.13, 0.09);
                nose.castShadow = true;
                group.add(nose);
                
                // Eyes
                const eyeGeo = new THREE.SphereGeometry(0.015, 8, 8);
                const eyeMat = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.04, 0.15, 0.07);
                leftEye.castShadow = true;
                group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.04, 0.15, 0.07);
                rightEye.castShadow = true;
                group.add(rightEye);
                
                // Add animated legs
                this.addAnimatedLegs(group, 0x654321);
                
                return group;
            }

            createRabbitModel() {
                const group = new THREE.Group();
                
                // Body (white/gray) - improved material
                const bodyGeo = new THREE.SphereGeometry(0.09, 16, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0xE0E0E0,
                    roughness: 0.9,
                    metalness: 0.05
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 1.2, 1);
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Head - improved material
                const headGeo = new THREE.SphereGeometry(0.07, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0xF0F0F0,
                    roughness: 0.85,
                    metalness: 0.05
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.12;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                // Long ears - improved material
                const earGeo = new THREE.CylinderGeometry(0.015, 0.02, 0.12, 8);
                const earMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFB6C1,
                    roughness: 0.7,
                    metalness: 0.1
                });
                const leftEar = new THREE.Mesh(earGeo, earMat);
                leftEar.position.set(-0.03, 0.2, 0);
                leftEar.rotation.z = 0.2;
                leftEar.castShadow = true;
                group.add(leftEar);
                const rightEar = new THREE.Mesh(earGeo, earMat);
                rightEar.position.set(0.03, 0.2, 0);
                rightEar.rotation.z = -0.2;
                rightEar.castShadow = true;
                group.add(rightEar);
                
                // Pink nose
                const noseGeo = new THREE.SphereGeometry(0.015, 8, 8);
                const noseMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFF69B4,
                    roughness: 0.5,
                    metalness: 0.2
                });
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.position.set(0, 0.12, 0.07);
                nose.castShadow = true;
                group.add(nose);
                
                // Add animated legs
                this.addAnimatedLegs(group, 0xC0C0C0);
                
                return group;
            }

            createSquirrelModel() {
                const group = new THREE.Group();
                
                // Body (orange/brown) - improved material
                const bodyGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.18, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0xD2691E,
                    roughness: 0.85,
                    metalness: 0.08
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Head - improved material
                const headGeo = new THREE.SphereGeometry(0.07, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0xCD853F,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.13;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                // Bushy tail - improved material
                const tailGeo = new THREE.SphereGeometry(0.08, 16, 16);
                const tailMat = new THREE.MeshStandardMaterial({ 
                    color: 0xD2691E,
                    roughness: 0.9,
                    metalness: 0.05
                });
                const tail = new THREE.Mesh(tailGeo, tailMat);
                tail.position.set(0, 0.1, -0.1);
                tail.scale.set(0.7, 1.2, 0.7);
                tail.castShadow = true;
                tail.receiveShadow = true;
                group.add(tail);
                
                // Add animated legs
                this.addAnimatedLegs(group, 0xA0522D);
                
                return group;
            }

            createBadgerModel() {
                const group = new THREE.Group();
                
                // Body (gray with black/white stripes) - improved material
                const bodyGeo = new THREE.CylinderGeometry(0.09, 0.11, 0.2, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    roughness: 0.85,
                    metalness: 0.08
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Head (white with black stripes) - improved material
                const headGeo = new THREE.SphereGeometry(0.08, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0xF0F0F0,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.13;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                // Black stripe 1 (left side of face) - improved material
                const stripeGeo1 = new THREE.BoxGeometry(0.03, 0.08, 0.09);
                const stripeMat = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    roughness: 0.9,
                    metalness: 0.05
                });
                const stripe1 = new THREE.Mesh(stripeGeo1, stripeMat);
                stripe1.position.set(-0.04, 0.13, 0.04);
                stripe1.castShadow = true;
                group.add(stripe1);
                
                // Black stripe 2 (right side of face)
                const stripe2 = new THREE.Mesh(stripeGeo1, stripeMat);
                stripe2.position.set(0.04, 0.13, 0.04);
                stripe2.castShadow = true;
                group.add(stripe2);
                
                // Small ears - improved material
                const earGeo = new THREE.ConeGeometry(0.02, 0.04, 8);
                const earMat = new THREE.MeshStandardMaterial({ 
                    color: 0x404040,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const leftEar = new THREE.Mesh(earGeo, earMat);
                leftEar.position.set(-0.05, 0.19, 0);
                leftEar.rotation.z = 0.3;
                leftEar.castShadow = true;
                group.add(leftEar);
                const rightEar = new THREE.Mesh(earGeo, earMat);
                rightEar.position.set(0.05, 0.19, 0);
                rightEar.rotation.z = -0.3;
                rightEar.castShadow = true;
                group.add(rightEar);
                
                // Nose
                const noseGeo = new THREE.SphereGeometry(0.02, 8, 8);
                const noseMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    roughness: 0.6,
                    metalness: 0.3
                });
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.position.set(0, 0.12, 0.08);
                nose.castShadow = true;
                group.add(nose);
                
                // Add animated legs
                this.addAnimatedLegs(group, 0x505050);
                
                return group;
            }

            createFoxModel() {
                const group = new THREE.Group();
                
                // Body (orange-red) - improved material
                const bodyGeo = new THREE.CylinderGeometry(0.07, 0.09, 0.19, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFF6347,
                    roughness: 0.85,
                    metalness: 0.08
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Head (orange-red) - improved material
                const headGeo = new THREE.SphereGeometry(0.075, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFF7F50,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.14;
                head.scale.set(1, 0.9, 1.1); // Slightly elongated snout
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                // Pointed ears - improved material
                const earGeo = new THREE.ConeGeometry(0.025, 0.08, 8);
                const earMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFF6347,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const leftEar = new THREE.Mesh(earGeo, earMat);
                leftEar.position.set(-0.04, 0.21, 0);
                leftEar.rotation.z = 0.2;
                leftEar.castShadow = true;
                group.add(leftEar);
                const rightEar = new THREE.Mesh(earGeo, earMat);
                rightEar.position.set(0.04, 0.21, 0);
                rightEar.rotation.z = -0.2;
                rightEar.castShadow = true;
                group.add(rightEar);
                
                // White chest patch
                const chestGeo = new THREE.SphereGeometry(0.04, 12, 12);
                const chestMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.9,
                    metalness: 0.05
                });
                const chest = new THREE.Mesh(chestGeo, chestMat);
                chest.position.set(0, 0, 0.08);
                chest.scale.set(1, 1.2, 0.8);
                chest.castShadow = true;
                group.add(chest);
                
                // Bushy tail (larger and fluffier than squirrel) - improved material
                const tailGeo = new THREE.SphereGeometry(0.09, 16, 16);
                const tailMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFF6347,
                    roughness: 0.9,
                    metalness: 0.05
                });
                const tail = new THREE.Mesh(tailGeo, tailMat);
                tail.position.set(0, 0.08, -0.12);
                tail.scale.set(0.8, 1.4, 0.8);
                tail.castShadow = true;
                tail.receiveShadow = true;
                group.add(tail);
                
                // White tail tip
                const tailTipGeo = new THREE.SphereGeometry(0.04, 12, 12);
                const tailTipMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.9,
                    metalness: 0.05
                });
                const tailTip = new THREE.Mesh(tailTipGeo, tailTipMat);
                tailTip.position.set(0, 0.15, -0.12);
                tailTip.castShadow = true;
                group.add(tailTip);
                
                // Black nose
                const noseGeo = new THREE.SphereGeometry(0.02, 8, 8);
                const noseMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    roughness: 0.6,
                    metalness: 0.3
                });
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.position.set(0, 0.13, 0.09);
                nose.castShadow = true;
                group.add(nose);
                
                // Add animated legs
                this.addAnimatedLegs(group, 0xCC5500);
                
                return group;
            }

            // Fallback creature model - simple geometry for error recovery
            createFallbackCreatureModel() {
                const group = new THREE.Group();
                
                // Simple body - improved material
                const bodyGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.2, 8);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Simple head - improved material
                const headGeo = new THREE.SphereGeometry(0.08, 8, 8);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0x654321,
                    roughness: 0.7,
                    metalness: 0.1
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.15;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                debug.log('Created fallback creature model');
                return group;
            }

            // Add animated legs to creature models
            addAnimatedLegs(group, color = 0x654321) {
                const legGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.08, 8);
                const legMat = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.8,
                    metalness: 0.1
                });
                
                // Create 4 legs
                const legs = [];
                const legPositions = [
                    { x: -0.05, z: 0.04 },  // Front left
                    { x: 0.05, z: 0.04 },   // Front right
                    { x: -0.05, z: -0.04 }, // Back left
                    { x: 0.05, z: -0.04 }   // Back right
                ];
                
                legPositions.forEach((pos, index) => {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set(pos.x, -0.06, pos.z);
                    leg.castShadow = true;
                    leg.userData.isLeg = true;
                    leg.userData.legIndex = index;
                    leg.userData.baseY = -0.06;
                    legs.push(leg);
                    group.add(leg);
                });
                
                return legs;
            }

            // Animate creature legs for running/walking
            animateCreatureLegs(creature, deltaTime, speedMultiplier = 1.0) {
                // SIMPLIFIED: Reduced complexity to prevent performance issues
                if (!creature || !creature.mesh || !creature.mesh.children) return;
                
                // Skip animation if speed is too low
                if (speedMultiplier < 0.1) return;
                
                try {
                    // Initialize leg animation phase if not exists
                    if (creature.legPhase === undefined) {
                        creature.legPhase = 0;
                    }
                    
                    // Update leg animation phase based on speed
                    creature.legPhase += deltaTime * 8 * speedMultiplier;
                    
                    // Find and animate legs (cache leg references for performance)
                    if (!creature.legCache) {
                        creature.legCache = [];
                        for (let i = 0; i < creature.mesh.children.length; i++) {
                            const child = creature.mesh.children[i];
                            if (child && child.userData && child.userData.isLeg) {
                                creature.legCache.push(child);
                            }
                        }
                    }
                    
                    // Animate cached legs
                    for (let i = 0; i < creature.legCache.length; i++) {
                        const leg = creature.legCache[i];
                        if (!leg || !leg.userData) continue;
                        
                        const legIndex = leg.userData.legIndex;
                        const baseY = leg.userData.baseY;
                        
                        // Alternate leg movement (front legs move together, back legs move together)
                        const phase = creature.legPhase + (legIndex < 2 ? 0 : Math.PI);
                        const legLift = Math.max(0, Math.sin(phase)) * 0.03 * speedMultiplier;
                        
                        leg.position.y = baseY + legLift;
                        
                        // Add slight forward/backward swing
                        const swingAmount = Math.sin(phase) * 0.02 * speedMultiplier;
                        if (legIndex < 2) {
                            // Front legs
                            leg.position.z = 0.04 + swingAmount;
                        } else {
                            // Back legs
                            leg.position.z = -0.04 - swingAmount;
                        }
                    }
                } catch (error) {
                    debug.error('Error animating legs:', error);
                    // Disable leg animation for this creature if it errors
                    creature.legCache = [];
                }
            }

            // Select animal type based on active biome
            selectAnimalTypeByBiome() {
                // Get current biome from environment manager
                const currentBiome = gameState.environmentManager ? 
                    gameState.environmentManager.getCurrentBiome() : null;
                
                // Base probabilities (equal distribution)
                let probabilities = {
                    mole: 0.20,
                    rabbit: 0.20,
                    squirrel: 0.20,
                    badger: 0.20,
                    fox: 0.20
                };
                
                // Adjust probabilities based on biome
                if (currentBiome === 'forest') {
                    // Increase rabbit/squirrel spawn rate by 50% in forest
                    probabilities.rabbit *= 1.5;
                    probabilities.squirrel *= 1.5;
                } else if (currentBiome === 'desert') {
                    // Increase mole/badger spawn rate by 50% in desert
                    probabilities.mole *= 1.5;
                    probabilities.badger *= 1.5;
                }
                
                // Normalize probabilities to sum to 1.0
                const total = Object.values(probabilities).reduce((sum, p) => sum + p, 0);
                Object.keys(probabilities).forEach(key => {
                    probabilities[key] /= total;
                });
                
                // Select animal type based on adjusted probabilities
                const rand = Math.random();
                let cumulative = 0;
                
                for (const [animalType, probability] of Object.entries(probabilities)) {
                    cumulative += probability;
                    if (rand < cumulative) {
                        return animalType;
                    }
                }
                
                // Fallback (should never reach here)
                return 'mole';
            }

            // Apply biome-based appearance modifications to a creature
            applyBiomeTint(creature) {
                // Get current biome from environment manager
                const currentBiome = gameState.environmentManager ? 
                    gameState.environmentManager.getCurrentBiome() : null;
                
                if (!currentBiome || !creature.mesh) {
                    return;
                }
                
                // Store original colors if not already stored
                if (!creature.originalColors) {
                    creature.originalColors = [];
                    creature.mesh.traverse((child) => {
                        if (child.isMesh && child.material) {
                            creature.originalColors.push({
                                mesh: child,
                                color: child.material.color.clone(),
                                emissive: child.material.emissive ? child.material.emissive.clone() : null,
                                emissiveIntensity: child.material.emissiveIntensity || 0
                            });
                        }
                    });
                }
                
                // Apply biome-specific tints
                if (currentBiome === 'arctic') {
                    // Apply white tint to creatures in arctic biome
                    creature.mesh.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // Blend current color with white (0xFFFFFF)
                            const whiteTint = new THREE.Color(0xFFFFFF);
                            child.material.color.lerp(whiteTint, 0.5); // 50% white tint
                        }
                    });
                    creature.biomeTint = 0xFFFFFF;
                } else if (currentBiome === 'volcanic') {
                    // Apply red-orange emissive glow to creatures in volcanic biome
                    creature.mesh.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // Add emissive glow
                            if (!child.material.emissive) {
                                child.material.emissive = new THREE.Color(0xFF6633);
                            } else {
                                child.material.emissive.setHex(0xFF6633);
                            }
                            child.material.emissiveIntensity = 0.4;
                        }
                    });
                    creature.biomeTint = 0xFF6633;
                } else {
                    // No tint for forest or desert biomes
                    creature.biomeTint = null;
                }
            }

            // Update all existing creatures when biome changes
            updateCreatureBiomeTints() {
                this.creatures.forEach(creature => {
                    // Reset to original colors first
                    if (creature.originalColors) {
                        creature.originalColors.forEach(original => {
                            if (original.mesh.material) {
                                original.mesh.material.color.copy(original.color);
                                if (original.emissive) {
                                    original.mesh.material.emissive.copy(original.emissive);
                                }
                                original.mesh.material.emissiveIntensity = original.emissiveIntensity;
                            }
                        });
                    }
                    
                    // Apply new biome tint
                    this.applyBiomeTint(creature);
                });
                
                // Update boss creature if it exists
                if (this.bossCreature && this.bossCreature.creature) {
                    const bossCreatureObj = this.bossCreature.creature;
                    if (bossCreatureObj.originalColors) {
                        bossCreatureObj.originalColors.forEach(original => {
                            if (original.mesh.material) {
                                original.mesh.material.color.copy(original.color);
                                if (original.emissive) {
                                    original.mesh.material.emissive.copy(original.emissive);
                                }
                                original.mesh.material.emissiveIntensity = original.emissiveIntensity;
                            }
                        });
                    }
                    this.applyBiomeTint(bossCreatureObj);
                }
            }

            // Apply color tint variation for consecutive same-type spawns (Requirement 7.4)
            applyColorVariation(creature, animalType) {
                if (!creature.mesh || !animalType) return;
                
                // Only apply variation if this is the same type as the last spawn
                if (this.lastSpawnedType === animalType) {
                    // Generate a random color tint variation
                    const tintVariations = [
                        0.9,  // Slightly darker
                        1.1,  // Slightly brighter
                        0.85, // More darker
                        1.15  // More brighter
                    ];
                    
                    const tintFactor = tintVariations[Math.floor(Math.random() * tintVariations.length)];
                    
                    // Apply tint to all meshes in the creature
                    creature.mesh.traverse((child) => {
                        if (child.isMesh && child.material && child.material.color) {
                            const originalColor = child.material.color.clone();
                            child.material.color.multiplyScalar(tintFactor);
                            
                            // Store the variation for tracking
                            if (!creature.colorVariation) {
                                creature.colorVariation = tintFactor;
                            }
                        }
                    });
                    
                    debug.log(`Applied color variation (${tintFactor.toFixed(2)}x) to consecutive ${animalType}`);
                }
                
                // Update last spawned type
                this.lastSpawnedType = animalType;
            }

            // Check if spawning this type would violate diversity rules (Requirement 7.5)
            // Returns true if spawn is allowed, false if it would exceed 40% threshold
            checkTypeDiversity(proposedType) {
                if (this.creatures.length === 0) return true;
                
                // Count visible creatures by type
                const typeCounts = {};
                let totalVisible = 0;
                
                this.creatures.forEach(creature => {
                    if (creature.state === 'visible' || creature.state === 'emerging') {
                        const type = creature.animalType || 'unknown';
                        typeCounts[type] = (typeCounts[type] || 0) + 1;
                        totalVisible++;
                    }
                });
                
                // Check if adding this type would exceed 40% threshold
                const proposedCount = (typeCounts[proposedType] || 0) + 1;
                const proposedTotal = totalVisible + 1;
                const proposedPercentage = proposedCount / proposedTotal;
                
                // Allow if under 40% threshold
                const allowed = proposedPercentage <= 0.40;
                
                if (!allowed) {
                    debug.log(`Type diversity check: ${proposedType} would be ${(proposedPercentage * 100).toFixed(1)}% (max 40%)`);
                }
                
                return allowed;
            }

            // Select animal type with diversity enforcement (Requirements 7.1, 7.5)
            selectAnimalTypeWithDiversity() {
                const maxAttempts = 10;
                let attempts = 0;
                let selectedType = null;
                
                while (attempts < maxAttempts) {
                    // Use existing biome-based selection
                    selectedType = this.selectAnimalTypeByBiome();
                    
                    // Check if this type passes diversity check
                    if (this.checkTypeDiversity(selectedType)) {
                        return selectedType;
                    }
                    
                    attempts++;
                }
                
                // If we couldn't find a diverse type after max attempts,
                // find the least common type among visible creatures
                const typeCounts = {};
                this.creatures.forEach(creature => {
                    if (creature.state === 'visible' || creature.state === 'emerging') {
                        const type = creature.animalType || 'unknown';
                        typeCounts[type] = (typeCounts[type] || 0) + 1;
                    }
                });
                
                // Get all available types
                const allTypes = ['mole', 'rabbit', 'squirrel', 'badger', 'fox'];
                
                // Find type with lowest count
                let minCount = Infinity;
                let leastCommonType = allTypes[0];
                
                allTypes.forEach(type => {
                    const count = typeCounts[type] || 0;
                    if (count < minCount) {
                        minCount = count;
                        leastCommonType = type;
                    }
                });
                
                debug.log(`Diversity enforcement: selected least common type ${leastCommonType}`);
                return leastCommonType;
            }

            createGoldenMoleModel() {
                const group = new THREE.Group();
                
                // Body (golden)
                const bodyGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.2, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    metalness: 0.6,
                    roughness: 0.3,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                group.add(body);
                
                // Head (golden)
                const headGeo = new THREE.SphereGeometry(0.09, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFA500,
                    metalness: 0.6,
                    roughness: 0.3,
                    emissive: 0xFFA500,
                    emissiveIntensity: 0.2
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.13;
                head.castShadow = true;
                group.add(head);
                
                // Sparkle effect
                const sparkleGeo = new THREE.SphereGeometry(0.12, 8, 8);
                const sparkleMat = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFF00,
                    transparent: true,
                    opacity: 0.3
                });
                const sparkle = new THREE.Mesh(sparkleGeo, sparkleMat);
                sparkle.position.y = 0.13;
                group.add(sparkle);
                
                return group;
            }

            createBombMoleModel() {
                const group = new THREE.Group();
                
                // Body (black)
                const bodyGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.2, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                group.add(body);
                
                // Head (black with red glow)
                const headGeo = new THREE.SphereGeometry(0.09, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.4
                });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.13;
                head.castShadow = true;
                group.add(head);
                
                // Warning symbol (red X)
                const symbolGeo = new THREE.BoxGeometry(0.08, 0.02, 0.02);
                const symbolMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const symbol1 = new THREE.Mesh(symbolGeo, symbolMat);
                symbol1.position.set(0, 0.13, 0.1);
                symbol1.rotation.z = Math.PI / 4;
                group.add(symbol1);
                
                const symbol2 = new THREE.Mesh(symbolGeo, symbolMat);
                symbol2.position.set(0, 0.13, 0.1);
                symbol2.rotation.z = -Math.PI / 4;
                group.add(symbol2);
                
                return group;
            }

            update(deltaTime) {
                const now = Date.now();
                
                // Check for boss spawn at score milestone
                if (!this.bossSpawned && 
                    gameState.scoreManager && 
                    gameState.scoreManager.score >= this.bossSpawnThreshold) {
                    this.spawnBoss();
                    this.bossSpawned = true;
                }
                
                // Spawn if interval passed and under simultaneous limit
                if (now - this.lastSpawn > this.spawnInterval && 
                    !gameState.paused && 
                    this.creatures.length < this.maxSimultaneous) {
                    this.spawnCreature();
                    this.lastSpawn = now;
                }

                // Update creatures with smooth easing
                // Use for loop instead of forEach to avoid issues if array is modified
                for (let i = 0; i < this.creatures.length; i++) {
                    const creature = this.creatures[i];
                    if (!creature || !creature.mesh) continue; // Safety check
                    
                    const effectiveDelta = deltaTime * this.freezeMultiplier;
                    
                    // Update special creature wrappers
                    if (creature.specialCreatureWrapper) {
                        if (creature.specialCreatureWrapper.type === 'speed') {
                            creature.specialCreatureWrapper.update(effectiveDelta, this.scene);
                        } else if (creature.specialCreatureWrapper.type === 'teleport') {
                            creature.specialCreatureWrapper.update(effectiveDelta, this.scene, gameState.visualEffectsManager);
                            creature.specialCreatureWrapper.updateParticles(effectiveDelta, this.scene);
                        } else if (creature.specialCreatureWrapper.type === 'shield') {
                            creature.specialCreatureWrapper.update(effectiveDelta);
                        }
                    }
                    
                    if (creature.state === 'emerging') {
                        creature.progress += effectiveDelta / creature.emergeTime;
                        if (creature.progress >= 1) {
                            creature.progress = 1;
                            creature.state = 'visible';
                            creature.visibleTime = now;
                        }
                        const eased = easeOutCubic(creature.progress);
                        
                        // Apply gravity flip if active
                        if (this.gravityFlipped) {
                            // Emerge from above instead of below
                            const flippedStartY = creature.startY + 0.6; // Start above
                            const flippedTargetY = creature.targetY;
                            creature.mesh.position.y = flippedStartY - (flippedStartY - flippedTargetY) * eased;
                        } else {
                            // Normal emergence from below
                            creature.mesh.position.y = creature.startY + (creature.targetY - creature.startY) * eased;
                        }
                        
                        // Smooth scale animation during emergence
                        const scaleProgress = easeOutCubic(creature.progress);
                        const emergenceScale = 0.3 + (0.7 * scaleProgress); // Scale from 30% to 100%
                        
                        // Preserve chaos event scale modifications
                        if (this.sizeChaosActive) {
                            // Keep the random scale from chaos event
                            const currentScale = creature.mesh.scale.x;
                            creature.mesh.scale.set(currentScale, currentScale, currentScale);
                        } else {
                            creature.mesh.scale.set(emergenceScale, emergenceScale, emergenceScale);
                        }
                        
                        // Smooth rotation animation during emergence
                        const rotationAmount = creature.emergenceRotation || 0;
                        const currentRotation = rotationAmount * (1 - scaleProgress);
                        creature.mesh.rotation.y = creature.baseRotation + currentRotation;
                    } else if (creature.state === 'visible') {
                        // Ensure scale is at 100% when visible (but preserve boss scale)
                        if (creature.type !== 'boss' && (!creature.personality || creature.personality !== 'sleepy')) {
                            creature.mesh.scale.set(1, 1, 1);
                        }
                        
                        // Idle animations - bobbing and swaying
                        creature.idlePhase = (creature.idlePhase || 0) + effectiveDelta * 2;
                        
                        // Gentle bobbing motion
                        const bobAmount = 0.015;
                        const bobOffset = Math.sin(creature.idlePhase) * bobAmount;
                        
                        // Gentle swaying rotation
                        const swayAmount = 0.08; // radians
                        const swayOffset = Math.sin(creature.idlePhase * 0.7) * swayAmount;
                        
                        // Personality-based behavior
                        let speedMultiplier = 1.0;
                        
                        if (creature.personality === 'taunting') {
                            // Occasionally stop and jump (more frequent)
                            if (!creature.isTaunting && Math.random() < 0.03) { // 3% chance per frame
                                creature.isTaunting = true;
                                creature.tauntTime = now;
                                debug.log('Creature taunting!');
                            }
                            
                            if (creature.isTaunting) {
                                if (now - creature.tauntTime < 800) {
                                    // Jump animation - much higher
                                    const jumpProgress = (now - creature.tauntTime) / 800;
                                    const jumpHeight = Math.sin(jumpProgress * Math.PI) * 0.25;
                                    creature.mesh.position.y = creature.targetY + jumpHeight;
                                    speedMultiplier = 0; // Stop walking
                                } else {
                                    creature.isTaunting = false;
                                }
                            }
                        } else if (creature.personality === 'sleepy') {
                            speedMultiplier = 0.4; // Move slower
                            // Occasional yawn (scale animation)
                            const yawnPhase = Math.sin(now * 0.001) * 0.5 + 0.5;
                            if (yawnPhase > 0.95) {
                                creature.mesh.scale.set(1, 1 + (yawnPhase - 0.95) * 2, 1);
                            } else {
                                creature.mesh.scale.set(1, 1, 1);
                            }
                        } else if (creature.personality === 'aggressive') {
                            speedMultiplier = 1.8; // Move faster
                        }
                        
                        // Apply speed ability multiplier
                        if (creature.ability === 'speed' && creature.abilityActive) {
                            speedMultiplier *= CREATURE_ABILITIES.speed.speedMultiplier;
                        }
                        
                        if (creature.personality === 'scared' && creature.isScared) {
                            // Run away from scare point
                            speedMultiplier = 2.5;
                            creature.walkAngle = Math.atan2(creature.scaredDirection.z, creature.scaredDirection.x);
                            if (now - creature.scaredTime > 1000) {
                                creature.isScared = false;
                            }
                        }
                        
                        // Walking animation with personality speed
                        if (!creature.isTaunting) {
                            creature.walkAngle += effectiveDelta * 2 * speedMultiplier;
                        }
                        const walkRadius = 0.08;
                        creature.walkOffset.x = Math.cos(creature.walkAngle) * walkRadius;
                        creature.walkOffset.z = Math.sin(creature.walkAngle) * walkRadius;
                        
                        // Make creature run around on ground if visible for too long (70% of visible duration)
                        const timeVisible = now - creature.visibleTime;
                        const runThreshold = creature.visibleDuration * 0.7;
                        const maxRunning = 3; // Allow up to 3 creatures running at once
                        if (timeVisible > runThreshold && !creature.isRunning && creature.type !== 'boss') {
                            const runningCount = this.creatures.filter(c => c && c.isRunning).length;
                            if (runningCount < maxRunning) {
                                creature.isRunning = true;
                                creature.runStartTime = now;
                                creature.runDirection = new THREE.Vector3(
                                    (Math.random() - 0.5) * 2,
                                    0,
                                    (Math.random() - 0.5) * 2
                                ).normalize();
                                debug.log('Creature started running!');
                            }
                        }
                        
                        // Bobbing animation
                        if (!creature.isTaunting) {
                            creature.bobPhase += effectiveDelta * 4;
                            const walkBobAmount = 0.02;
                            const walkBobOffset = Math.sin(creature.bobPhase) * walkBobAmount;
                            
                            if (creature.isRunning) {
                                // Run around on the ground
                                const runSpeed = 0.5 * speedMultiplier; // Increased speed for more visible movement
                                const runDelta = effectiveDelta * runSpeed;
                                
                                creature.mesh.position.x += creature.runDirection.x * runDelta;
                                creature.mesh.position.z += creature.runDirection.z * runDelta;
                                // Keep creature at ground level when running (not elevated)
                                creature.mesh.position.y = 0.15 + walkBobOffset; // Ground level with bobbing
                                
                                // Keep within bounds (2 units from center)
                                const distFromCenter = Math.sqrt(
                                    creature.mesh.position.x * creature.mesh.position.x +
                                    creature.mesh.position.z * creature.mesh.position.z
                                );
                                
                                if (distFromCenter > 1.8) {
                                    // Bounce back toward center
                                    creature.runDirection.x = -creature.mesh.position.x * 0.5;
                                    creature.runDirection.z = -creature.mesh.position.z * 0.5;
                                    creature.runDirection.normalize();
                                }
                                
                                // Occasionally change direction
                                if (Math.random() < 0.02) {
                                    creature.runDirection.x += (Math.random() - 0.5) * 0.5;
                                    creature.runDirection.z += (Math.random() - 0.5) * 0.5;
                                    creature.runDirection.normalize();
                                }
                                
                                // Face running direction
                                creature.mesh.rotation.y = Math.atan2(creature.runDirection.z, creature.runDirection.x) + Math.PI / 2;
                            } else {
                                // Normal walking around hole
                                creature.mesh.position.x = creature.hole.position.x + creature.walkOffset.x;
                                creature.mesh.position.z = creature.hole.position.z + creature.walkOffset.z;
                                if (!creature.isTaunting) {
                                    creature.mesh.position.y = creature.targetY + walkBobOffset + bobOffset;
                                }
                                
                                // Rotate to face movement direction with idle swaying
                                creature.mesh.rotation.y = creature.walkAngle + Math.PI / 2 + swayOffset;
                            }
                        }
                        
                        // Animate legs for running/walking
                        this.animateCreatureLegs(creature, effectiveDelta, speedMultiplier);
                        
                        // Speed ability visual effect (motion blur trail)
                        if (creature.ability === 'speed' && creature.abilityActive) {
                            if (!creature.speedTrail) {
                                creature.speedTrail = [];
                            }
                            
                            // Add trail position
                            creature.speedTrail.push({
                                position: creature.mesh.position.clone(),
                                time: now
                            });
                            
                            // Remove old trail positions (older than 200ms)
                            creature.speedTrail = creature.speedTrail.filter(t => now - t.time < 200);
                            
                            // Render trail (simple afterimage effect)
                            if (creature.speedTrail.length > 1 && !creature.trailMeshes) {
                                creature.trailMeshes = [];
                            }
                        }
                        
                        if (now - creature.visibleTime > creature.visibleDuration) {
                            // If creature is running, let it run off the map instead of retreating
                            if (creature.isRunning) {
                                creature.state = 'escaping';
                                creature.progress = 0;
                            } else {
                                creature.state = 'retreating';
                                creature.progress = 0;
                            }
                        }
                    } else if (creature.state === 'escaping') {
                        // Running creatures escape by running off the map
                        creature.progress += effectiveDelta / 2.0; // 2 second escape time
                        if (creature.progress >= 1) {
                            this.removeCreatureEscaped(creature);
                        } else {
                            // Continue running in the same direction, faster
                            const escapeSpeed = 1.5;
                            const runDelta = effectiveDelta * escapeSpeed;
                            creature.mesh.position.x += creature.runDirection.x * runDelta;
                            creature.mesh.position.z += creature.runDirection.z * runDelta;
                            
                            // Fade out as they escape
                            const fadeProgress = creature.progress;
                            const opacity = 1 - fadeProgress;
                            
                            creature.mesh.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    if (!child.material.transparent) {
                                        child.material.transparent = true;
                                        child.material.needsUpdate = true;
                                    }
                                    child.material.opacity = opacity;
                                }
                            });
                        }
                    } else if (creature.state === 'retreating') {
                        creature.progress += effectiveDelta / creature.retreatTime;
                        if (creature.progress >= 1) {
                            this.removeCreatureEscaped(creature);
                        } else {
                            const eased = easeInCubic(creature.progress);
                            // Return to hole position while retreating
                            creature.mesh.position.x = creature.hole.position.x + creature.walkOffset.x * (1 - eased);
                            creature.mesh.position.z = creature.hole.position.z + creature.walkOffset.z * (1 - eased);
                            creature.mesh.position.y = creature.targetY - (creature.targetY - creature.startY) * eased;
                            
                            // Fade-out animation over 0.3 seconds
                            const fadeProgress = creature.progress;
                            const opacity = 1 - fadeProgress;
                            
                            // Apply fade to all meshes in the creature
                            creature.mesh.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    // Enable transparency if not already enabled
                                    if (!child.material.transparent) {
                                        child.material.transparent = true;
                                        child.material.needsUpdate = true;
                                    }
                                    child.material.opacity = opacity;
                                }
                            });
                        }
                    }
                }

                this.particleEffect.update(deltaTime);
                this.scorePopup.update(deltaTime);
                
                // Update ability indicators
                if (this.abilitySystem) {
                    this.abilitySystem.updateIndicators(this.creatures, deltaTime);
                }
                
                // Update boss health bar position and behaviors
                if (this.bossCreature && gameState.camera && gameState.renderer) {
                    this.bossCreature.updateHealthBarPosition(gameState.camera, gameState.renderer);
                    
                    // Update roar animation
                    this.bossCreature.updateRoar(now);
                    
                    // Face the player
                    if (!this.bossCreature.isRoaring) {
                        this.bossCreature.faceDirection(gameState.camera.position);
                    }
                    
                    // Shoot projectiles at player
                    if (this.bossCreature.creature.state === 'visible') {
                        const projectile = this.bossCreature.shootProjectile(this.scene, gameState.camera.position);
                        if (projectile && gameState.audioManager) {
                            gameState.audioManager.playExplosion();
                        }
                    }
                    
                    // Update projectiles
                    this.bossCreature.updateProjectiles(now, this.scene);
                    
                    // Check if projectiles hit player (simple distance check)
                    this.bossCreature.projectiles.forEach((proj, index) => {
                        const distToCamera = proj.mesh.position.distanceTo(gameState.camera.position);
                        if (distToCamera < 0.3) {
                            // Projectile hit player
                            debug.log('Player hit by boss projectile!');
                            
                            // Remove projectile
                            this.scene.remove(proj.mesh);
                            proj.mesh.geometry.dispose();
                            proj.mesh.material.dispose();
                            this.bossCreature.projectiles.splice(index, 1);
                            
                            // Lose a life or take damage
                            if (gameState.livesManager) {
                                gameState.livesManager.loseLife();
                            }
                            
                            // Camera shake effect
                            if (gameState.cameraEffectsManager) {
                                gameState.cameraEffectsManager.shake(0.04, 0.3);
                            }
                            
                            // Play hit sound
                            if (gameState.audioManager) {
                                gameState.audioManager.playMiss();
                            }
                        }
                    });
                }
            }

            spawnCreature() {
                const hole = this.holeManager.getRandomHole();
                if (!hole) return;

                hole.occupied = true;

                // Determine creature type and animal
                const rand = Math.random();
                let creatureType, creatureMesh, visibleTimeMultiplier, emergeTimeMultiplier, animalType;
                
                if (rand < 0.05) {
                    // 5% Bomb
                    creatureType = 'bomb';
                    creatureMesh = this.createBombMoleModel();
                    visibleTimeMultiplier = 1.3;
                    emergeTimeMultiplier = 0.9;
                    animalType = 'bomb';
                } else if (rand < 0.15) {
                    // 10% Golden
                    creatureType = 'golden';
                    creatureMesh = this.createGoldenMoleModel();
                    visibleTimeMultiplier = 0.7;
                    emergeTimeMultiplier = 0.7;
                    animalType = 'golden';
                } else {
                    // 85% Standard - varied animals with biome-specific spawn rates and diversity enforcement
                    creatureType = 'standard';
                    animalType = this.selectAnimalTypeWithDiversity(); // Use diversity-aware selection
                    
                    // Create the appropriate model with error handling
                    try {
                        if (animalType === 'mole') {
                            creatureMesh = this.createMoleModel();
                        } else if (animalType === 'rabbit') {
                            creatureMesh = this.createRabbitModel();
                        } else if (animalType === 'squirrel') {
                            creatureMesh = this.createSquirrelModel();
                        } else if (animalType === 'badger') {
                            creatureMesh = this.createBadgerModel();
                        } else {
                            creatureMesh = this.createFoxModel();
                        }
                    } catch (e) {
                        debug.error('Failed to create creature model:', animalType, e);
                        // Fallback to simple mole geometry
                        debug.log('Using fallback simple geometry');
                        creatureMesh = this.createFallbackCreatureModel();
                        animalType = 'mole'; // Default to mole type
                    }
                    visibleTimeMultiplier = 1.0;
                    emergeTimeMultiplier = 1.0;
                }

                // Create hole visuals
                const holeGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
                const holeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const holeMesh = new THREE.Mesh(holeGeo, holeMat);
                holeMesh.position.set(hole.position.x, -0.05, hole.position.z);
                holeMesh.receiveShadow = true;
                this.scene.add(holeMesh);

                const rimGeo = new THREE.TorusGeometry(0.15, 0.03, 8, 16);
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const rimMesh = new THREE.Mesh(rimGeo, rimMat);
                rimMesh.rotation.x = Math.PI / 2;
                rimMesh.position.set(hole.position.x, 0.01, hole.position.z);
                rimMesh.castShadow = true;
                this.scene.add(rimMesh);

                creatureMesh.position.copy(hole.position);
                this.scene.add(creatureMesh);

                // Random rotation for emergence animation (-15¬∞ to +15¬∞)
                const baseRotation = Math.random() * Math.PI * 2;
                const emergenceRotation = (Math.random() - 0.5) * (Math.PI / 6); // -15¬∞ to +15¬∞ (œÄ/6 = 30¬∞, so ¬±15¬∞)
                
                const creature = {
                    mesh: creatureMesh,
                    hole: hole,
                    holeMesh: holeMesh,
                    rimMesh: rimMesh,
                    type: creatureType,
                    animalType: animalType,
                    state: 'emerging',
                    startY: hole.position.y,
                    targetY: hole.position.y + 0.3,
                    progress: 0,
                    emergeTime: this.emergeTime * emergeTimeMultiplier,
                    retreatTime: 0.3,
                    visibleTime: 0,
                    visibleDuration: this.visibleTime * visibleTimeMultiplier,
                    walkOffset: new THREE.Vector3(0, 0, 0),
                    walkAngle: Math.random() * Math.PI * 2,
                    bobPhase: Math.random() * Math.PI * 2,
                    baseRotation: baseRotation,
                    emergenceRotation: emergenceRotation,
                    idlePhase: Math.random() * Math.PI * 2,
                    // Personality traits
                    personality: this.assignPersonality(),
                    tauntTime: 0,
                    isTaunting: false,
                    scaredDirection: new THREE.Vector3(0, 0, 0),
                    isScared: false,
                    // Ability system
                    ability: null,
                    abilityActive: false,
                    health: 1,
                    maxHealth: 1
                };

                // Assign ability (only for standard creatures)
                if (creatureType === 'standard' && this.abilitySystem) {
                    const ability = this.abilitySystem.assignAbility(creature);
                    if (ability) {
                        this.abilitySystem.addVisualIndicator(creature, ability);
                    }
                }

                // Check if we should spawn a special creature type (if unlocked via ProgressionManager)
                let specialCreatureWrapper = null;
                if (creatureType === 'standard' && gameState.progressionManager) {
                    const specialRoll = Math.random();
                    
                    // 15% chance for special creatures if unlocked
                    if (specialRoll < 0.15) {
                        const availableSpecialTypes = [];
                        
                        if (gameState.progressionManager.isUnlocked('speed')) {
                            availableSpecialTypes.push('speed');
                        }
                        if (gameState.progressionManager.isUnlocked('teleport')) {
                            availableSpecialTypes.push('teleport');
                        }
                        if (gameState.progressionManager.isUnlocked('shield')) {
                            availableSpecialTypes.push('shield');
                        }
                        if (gameState.progressionManager.isUnlocked('mimic')) {
                            availableSpecialTypes.push('mimic');
                        }
                        
                        if (availableSpecialTypes.length > 0) {
                            const specialType = availableSpecialTypes[Math.floor(Math.random() * availableSpecialTypes.length)];
                            
                            if (specialType === 'speed') {
                                specialCreatureWrapper = new SpeedBoostCreature(creature);
                                creature.specialCreatureWrapper = specialCreatureWrapper;
                                debug.log('Spawned Speed Boost Creature!');
                            } else if (specialType === 'teleport') {
                                specialCreatureWrapper = new TeleportingCreature(creature, this.holeManager);
                                creature.specialCreatureWrapper = specialCreatureWrapper;
                                debug.log('Spawned Teleporting Creature!');
                            } else if (specialType === 'shield') {
                                specialCreatureWrapper = new ShieldCreature(creature, this.scene);
                                creature.specialCreatureWrapper = specialCreatureWrapper;
                                debug.log('Spawned Shield Creature!');
                            } else if (specialType === 'mimic') {
                                specialCreatureWrapper = new MimicCreature(creature);
                                creature.specialCreatureWrapper = specialCreatureWrapper;
                                debug.log('Spawned Mimic Creature!');
                            }
                        }
                    }
                }

                this.creatures.push(creature);
                this.applyPersonalityVisuals(creature);
                
                // Apply color variation for consecutive same-type spawns (Requirement 7.4)
                if (creatureType === 'standard') {
                    this.applyColorVariation(creature, animalType);
                }
                
                // Apply biome-based appearance modifications
                this.applyBiomeTint(creature);
                
                // Apply chaos event modifications if active
                if (this.sizeChaosActive && creatureMesh) {
                    // Apply random scale between 0.5x and 2x
                    const randomScale = 0.5 + Math.random() * 1.5;
                    creatureMesh.scale.set(randomScale, randomScale, randomScale);
                }
                
                if (this.colorMadnessActive && creatureMesh && creatureMesh.material) {
                    // Apply random vibrant color
                    const vibrantColors = [
                        0xFF00FF, // Magenta
                        0x00FFFF, // Cyan
                        0xFFFF00, // Yellow
                        0xFF0000, // Red
                        0x00FF00, // Green
                        0x0000FF, // Blue
                        0xFF6600, // Orange
                        0xFF00AA  // Pink
                    ];
                    const randomColor = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];
                    creatureMesh.material.color.setHex(randomColor);
                }
                
                // Clone Storm: spawn additional creatures at the same hole
                if (this.cloneStormActive && this.cloneMultiplier > 1) {
                    for (let i = 1; i < this.cloneMultiplier; i++) {
                        // Spawn clones with slight offset
                        setTimeout(() => {
                            const offset = 0.15 * i;
                            const cloneHole = {
                                position: new THREE.Vector3(
                                    hole.position.x + (Math.random() - 0.5) * offset,
                                    hole.position.y,
                                    hole.position.z + (Math.random() - 0.5) * offset
                                ),
                                occupied: false
                            };
                            
                            // Create a clone creature (simplified version)
                            const cloneMesh = creatureMesh.clone();
                            cloneMesh.position.copy(cloneHole.position);
                            this.scene.add(cloneMesh);
                            
                            const cloneCreature = {
                                mesh: cloneMesh,
                                hole: cloneHole,
                                holeMesh: null,
                                rimMesh: null,
                                type: creatureType,
                                animalType: animalType,
                                state: 'emerging',
                                startY: cloneHole.position.y,
                                targetY: cloneHole.position.y + 0.3,
                                progress: 0,
                                emergeTime: creature.emergeTime,
                                retreatTime: 0.3,
                                visibleTime: 0,
                                visibleDuration: creature.visibleDuration,
                                walkOffset: new THREE.Vector3(0, 0, 0),
                                walkAngle: Math.random() * Math.PI * 2,
                                bobPhase: Math.random() * Math.PI * 2,
                                baseRotation: Math.random() * Math.PI * 2,
                                emergenceRotation: (Math.random() - 0.5) * (Math.PI / 6),
                                idlePhase: Math.random() * Math.PI * 2,
                                personality: this.assignPersonality(),
                                tauntTime: 0,
                                isTaunting: false,
                                scaredDirection: new THREE.Vector3(0, 0, 0),
                                isScared: false,
                                ability: null,
                                abilityActive: false,
                                health: 1,
                                maxHealth: 1,
                                isClone: true
                            };
                            
                            this.creatures.push(cloneCreature);
                        }, i * 100);
                    }
                }
                
                debug.log('Spawned:', animalType, creatureType, 'personality:', creature.personality, 'ability:', creature.ability || 'none');
            }

            spawnBoss() {
                debug.log('üî• BOSS SPAWNING! üî•');
                
                const hole = this.holeManager.getRandomHole();
                if (!hole) {
                    debug.log('No available hole for boss, retrying in 5 seconds');
                    setTimeout(() => {
                        if (!this.bossCreature) {
                            this.spawnBoss();
                        }
                    }, 5000);
                    return;
                }

                hole.occupied = true;

                // Create a random boss creature type with error handling
                const animalRand = Math.random();
                let creatureMesh, animalType;
                
                try {
                    if (animalRand < 0.2) {
                        creatureMesh = this.createMoleModel();
                        animalType = 'mole';
                    } else if (animalRand < 0.4) {
                        creatureMesh = this.createRabbitModel();
                        animalType = 'rabbit';
                    } else if (animalRand < 0.6) {
                        creatureMesh = this.createSquirrelModel();
                        animalType = 'squirrel';
                    } else if (animalRand < 0.8) {
                        creatureMesh = this.createBadgerModel();
                        animalType = 'badger';
                    } else {
                        creatureMesh = this.createFoxModel();
                        animalType = 'fox';
                    }
                } catch (e) {
                    debug.error('Failed to create boss creature model:', e);
                    // Use fallback model
                    creatureMesh = this.createFallbackCreatureModel();
                    animalType = 'mole';
                }

                // Create hole visuals
                const holeGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
                const holeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const holeMesh = new THREE.Mesh(holeGeo, holeMat);
                holeMesh.position.set(hole.position.x, -0.05, hole.position.z);
                holeMesh.receiveShadow = true;
                this.scene.add(holeMesh);

                const rimGeo = new THREE.TorusGeometry(0.15, 0.03, 8, 16);
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const rimMesh = new THREE.Mesh(rimGeo, rimMat);
                rimMesh.rotation.x = Math.PI / 2;
                rimMesh.position.set(hole.position.x, 0.01, hole.position.z);
                rimMesh.castShadow = true;
                this.scene.add(rimMesh);

                creatureMesh.position.copy(hole.position);
                this.scene.add(creatureMesh);

                const creature = {
                    mesh: creatureMesh,
                    hole: hole,
                    holeMesh: holeMesh,
                    rimMesh: rimMesh,
                    type: 'boss',
                    animalType: animalType,
                    state: 'emerging',
                    startY: hole.position.y,
                    targetY: hole.position.y + 0.3,
                    progress: 0,
                    emergeTime: this.emergeTime * 1.5, // Slower emergence
                    retreatTime: 0.3,
                    visibleTime: 0,
                    visibleDuration: this.visibleTime * 3, // Stays longer
                    walkOffset: new THREE.Vector3(0, 0, 0),
                    walkAngle: Math.random() * Math.PI * 2,
                    bobPhase: Math.random() * Math.PI * 2,
                    personality: 'aggressive',
                    tauntTime: 0,
                    isTaunting: false,
                    scaredDirection: new THREE.Vector3(0, 0, 0),
                    isScared: false
                };

                // Create boss with 5x scale and 3 health (larger and more menacing)
                this.bossCreature = new BossCreature(creature, 5.0, 3);
                this.bossCreature.spawnScore = gameState.scoreManager.score;
                
                // Add glowing effect to boss
                creature.mesh.children.forEach(child => {
                    if (child.material) {
                        child.material.emissive = new THREE.Color(0xff0000);
                        child.material.emissiveIntensity = 0.5;
                    }
                });

                this.creatures.push(creature);
                
                // Apply biome-based appearance modifications
                this.applyBiomeTint(creature);
                
                // Create health bar
                this.bossCreature.createHealthBar();
                
                // Face the camera/player
                if (gameState.camera) {
                    this.bossCreature.faceDirection(gameState.camera.position);
                }
                
                // Start roar animation
                this.bossCreature.startRoar();
                
                // Play boss spawn audio
                if (gameState.audioManager) {
                    gameState.audioManager.playBossSpawn();
                }
                
                // Trigger camera effects for boss spawn (Requirement 9.3)
                if (gameState.cameraEffectsManager) {
                    gameState.cameraEffectsManager.shake(0.05, 0.8);
                    gameState.cameraEffectsManager.zoom(gameState.camera.fov - 5, 2.0);
                    debug.log('Camera effects triggered for boss spawn');
                }
                
                debug.log('Boss spawned:', animalType, 'at score', this.bossCreature.spawnScore);
            }

            spawnSplitCreature(hole, animalType, scale) {
                if (!hole || hole.occupied) return;

                hole.occupied = true;

                // Create creature mesh based on animal type
                let creatureMesh;
                if (animalType === 'mole') {
                    creatureMesh = this.createMoleModel();
                } else if (animalType === 'rabbit') {
                    creatureMesh = this.createRabbitModel();
                } else if (animalType === 'squirrel') {
                    creatureMesh = this.createSquirrelModel();
                } else if (animalType === 'badger') {
                    creatureMesh = this.createBadgerModel();
                } else if (animalType === 'fox') {
                    creatureMesh = this.createFoxModel();
                } else {
                    creatureMesh = this.createMoleModel();
                }

                // Create hole visuals
                const holeGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
                const holeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const holeMesh = new THREE.Mesh(holeGeo, holeMat);
                holeMesh.position.set(hole.position.x, -0.05, hole.position.z);
                holeMesh.receiveShadow = true;
                this.scene.add(holeMesh);

                const rimGeo = new THREE.TorusGeometry(0.15, 0.03, 8, 16);
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const rimMesh = new THREE.Mesh(rimGeo, rimMat);
                rimMesh.rotation.x = Math.PI / 2;
                rimMesh.position.set(hole.position.x, 0.01, hole.position.z);
                rimMesh.castShadow = true;
                this.scene.add(rimMesh);

                creatureMesh.position.copy(hole.position);
                creatureMesh.scale.set(scale, scale, scale); // Apply split scale
                this.scene.add(creatureMesh);

                const creature = {
                    mesh: creatureMesh,
                    hole: hole,
                    holeMesh: holeMesh,
                    rimMesh: rimMesh,
                    type: 'standard',
                    animalType: animalType,
                    state: 'emerging',
                    startY: hole.position.y,
                    targetY: hole.position.y + 0.3,
                    progress: 0,
                    emergeTime: this.emergeTime,
                    retreatTime: 0.3,
                    visibleTime: 0,
                    visibleDuration: this.visibleTime * 0.8, // Slightly shorter
                    walkOffset: new THREE.Vector3(0, 0, 0),
                    walkAngle: Math.random() * Math.PI * 2,
                    bobPhase: Math.random() * Math.PI * 2,
                    personality: 'normal',
                    tauntTime: 0,
                    isTaunting: false,
                    scaredDirection: new THREE.Vector3(0, 0, 0),
                    isScared: false,
                    ability: null,
                    abilityActive: false,
                    health: 1,
                    maxHealth: 1,
                    isSplit: true // Mark as split creature
                };

                this.creatures.push(creature);
                debug.log('Spawned split creature:', animalType, 'at scale', scale);
            }

            assignPersonality() {
                const rand = Math.random();
                if (rand < 0.20) return 'taunting';      // 20% - stops and jumps
                if (rand < 0.40) return 'scared';        // 20% - runs from near clicks
                if (rand < 0.60) return 'sleepy';        // 20% - moves slower
                if (rand < 0.75) return 'aggressive';    // 15% - moves faster
                return 'normal';                          // 25% - standard behavior
            }

            applyPersonalityVisuals(creature) {
                // Add visual indicators for personalities
                if (creature.personality === 'taunting') {
                    // Add exclamation mark above head
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', 32, 48);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(material);
                    sprite.scale.set(0.15, 0.15, 1);
                    sprite.position.y = 0.4;
                    creature.mesh.add(sprite);
                } else if (creature.personality === 'scared') {
                    // Slightly blue tint
                    creature.mesh.children.forEach(child => {
                        if (child.material && child.material.color) {
                            const color = child.material.color;
                            child.material.color.setRGB(
                                color.r * 0.8,
                                color.g * 0.8,
                                color.b * 1.2
                            );
                        }
                    });
                } else if (creature.personality === 'sleepy') {
                    // Add "Zzz" above head
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Zzz', 32, 40);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(material);
                    sprite.scale.set(0.15, 0.15, 1);
                    sprite.position.y = 0.4;
                    creature.mesh.add(sprite);
                } else if (creature.personality === 'aggressive') {
                    // Red tint
                    creature.mesh.children.forEach(child => {
                        if (child.material && child.material.color) {
                            const color = child.material.color;
                            child.material.color.setRGB(
                                Math.min(color.r * 1.3, 1),
                                color.g * 0.7,
                                color.b * 0.7
                            );
                        }
                    });
                }
            }

            removeCreature(creature) {
                this.scene.remove(creature.mesh);
                
                // Remove hole visuals
                if (creature.holeMesh) {
                    this.scene.remove(creature.holeMesh);
                }
                if (creature.rimMesh) {
                    this.scene.remove(creature.rimMesh);
                }
                
                // Clean up running state
                if (creature.isRunning) {
                    creature.isRunning = false;
                    creature.runDirection = null;
                }
                
                // Clean up mesh children (legs, etc.)
                if (creature.mesh && creature.mesh.children) {
                    creature.mesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
                
                // Dispose of creature mesh geometry and material
                if (creature.mesh) {
                    if (creature.mesh.geometry) creature.mesh.geometry.dispose();
                    if (creature.mesh.material) creature.mesh.material.dispose();
                }
                
                creature.hole.occupied = false;
                const index = this.creatures.indexOf(creature);
                if (index > -1) this.creatures.splice(index, 1);
            }

            removeCreatureEscaped(creature) {
                // Creature escaped - lose points and record miss
                if (creature.type !== 'bomb') {
                    // Only lose points for missing good targets
                    gameState.scoreManager.addScore(-50);
                }
                if (gameState.difficultyManager) {
                    gameState.difficultyManager.recordMiss();
                }
                
                // Reset streak on miss
                if (gameState.streakManager && creature.type !== 'bomb') {
                    gameState.streakManager.resetStreak();
                }
                
                this.removeCreature(creature);
            }

            hitCreature(creature) {
                if (creature.state === 'visible' || creature.state === 'emerging') {
                    
                    // Handle special creature types
                    if (creature.specialCreatureWrapper) {
                        const wrapper = creature.specialCreatureWrapper;
                        
                        // Shield Creature - requires 2 hits
                        if (wrapper.type === 'shield') {
                            const defeated = wrapper.hit(this.scene, gameState.visualEffectsManager);
                            
                            if (!defeated) {
                                // First hit - shield cracked but not defeated
                                if (gameState.audioManager) {
                                    gameState.audioManager.playHit();
                                }
                                debug.log('Shield cracked! One more hit needed.');
                                return true;
                            } else {
                                // Second hit - shield destroyed, score points
                                if (gameState.audioManager) {
                                    gameState.audioManager.playHit();
                                }
                                
                                gameState.comboManager.addHit();
                                
                                // Add to streak for multiplier tracking
                                if (gameState.streakManager) {
                                    gameState.streakManager.addHit();
                                }
                                
                                const comboMultiplier = gameState.comboManager.getMultiplier();
                                const streakMultiplier = gameState.streakManager ? gameState.streakManager.getMultiplier() : 1.0;
                                const powerUpMultiplier = gameState.powerUpManager ? gameState.powerUpManager.getPointsMultiplier() : 1;
                                const score = Math.floor(wrapper.scoreValue * comboMultiplier * streakMultiplier * powerUpMultiplier);
                                
                                gameState.scoreManager.addScore(score);
                                
                                if (gameState.visualEffectsManager) {
                                    gameState.visualEffectsManager.spawnHitEffect(creature.mesh.position, creature.animalType, comboMultiplier);
                                }
                                this.scorePopup.create(creature.mesh.position, score, comboMultiplier);
                                
                                if (gameState.progressionManager) {
                                    gameState.progressionManager.recordHit();
                                }
                                
                                this.removeCreature(creature);
                                return true;
                            }
                        }
                        
                        // Mimic Creature - splits into 2 smaller creatures
                        if (wrapper.type === 'mimic') {
                            if (gameState.audioManager) {
                                gameState.audioManager.playHit();
                            }
                            
                            debug.log('Mimic hit! Splitting into 2 creatures...');
                            
                            // Spawn split creatures
                            const splitCreatures = wrapper.split(this.scene, this.holeManager, this, gameState.visualEffectsManager);
                            
                            // Add split creatures to the creatures array
                            splitCreatures.forEach(splitCreature => {
                                this.creatures.push(splitCreature);
                            });
                            
                            // Remove original mimic (gives 0 points)
                            this.removeCreature(creature);
                            return true;
                        }
                        
                        // Speed Boost and Teleporting creatures - normal hit but with special score
                        if (wrapper.type === 'speed' || wrapper.type === 'teleport') {
                            if (gameState.audioManager) {
                                gameState.audioManager.playHit();
                            }
                            
                            gameState.comboManager.addHit();
                            
                            // Add to streak for multiplier tracking
                            if (gameState.streakManager) {
                                gameState.streakManager.addHit();
                            }
                            
                            const comboMultiplier = gameState.comboManager.getMultiplier();
                            const streakMultiplier = gameState.streakManager ? gameState.streakManager.getMultiplier() : 1.0;
                            const powerUpMultiplier = gameState.powerUpManager ? gameState.powerUpManager.getPointsMultiplier() : 1;
                            const score = Math.floor(wrapper.scoreValue * comboMultiplier * streakMultiplier * powerUpMultiplier);
                            
                            gameState.scoreManager.addScore(score);
                            
                            if (gameState.visualEffectsManager) {
                                gameState.visualEffectsManager.spawnHitEffect(creature.mesh.position, creature.animalType, comboMultiplier);
                            }
                            this.scorePopup.create(creature.mesh.position, score, comboMultiplier);
                            
                            if (gameState.progressionManager) {
                                gameState.progressionManager.recordHit();
                            }
                            
                            this.removeCreature(creature);
                            return true;
                        }
                    }
                    
                    // Handle mimic split creatures (smaller ones worth 100 each)
                    if (creature.isMimicSplit) {
                        if (gameState.audioManager) {
                            gameState.audioManager.playHit();
                        }
                        
                        gameState.comboManager.addHit();
                        
                        // Add to streak for multiplier tracking
                        if (gameState.streakManager) {
                            gameState.streakManager.addHit();
                        }
                        
                        const comboMultiplier = gameState.comboManager.getMultiplier();
                        const streakMultiplier = gameState.streakManager ? gameState.streakManager.getMultiplier() : 1.0;
                        const powerUpMultiplier = gameState.powerUpManager ? gameState.powerUpManager.getPointsMultiplier() : 1;
                        const score = Math.floor(creature.mimicSplitValue * comboMultiplier * streakMultiplier * powerUpMultiplier);
                        
                        gameState.scoreManager.addScore(score);
                        
                        if (gameState.visualEffectsManager) {
                            gameState.visualEffectsManager.spawnHitEffect(creature.mesh.position, creature.animalType, comboMultiplier);
                        }
                        this.scorePopup.create(creature.mesh.position, score, comboMultiplier);
                        
                        if (gameState.progressionManager) {
                            gameState.progressionManager.recordHit();
                        }
                        
                        this.removeCreature(creature);
                        return true;
                    }
                    
                    // Handle boss creature
                    if (creature.type === 'boss' && this.bossCreature) {
                        // Play hit sound
                        if (gameState.audioManager) {
                            gameState.audioManager.playHit();
                        }
                        
                        // Decrement boss health
                        const defeated = this.bossCreature.takeDamage();
                        
                        // Flash effect
                        creature.mesh.children.forEach(child => {
                            if (child.material) {
                                const originalColor = child.material.color.clone();
                                child.material.color.setHex(0xffffff);
                                setTimeout(() => {
                                    child.material.color.copy(originalColor);
                                }, 100);
                            }
                        });
                        
                        if (defeated) {
                            debug.log('Boss defeated! +500 points');
                            
                            // Award 500 points
                            gameState.scoreManager.addScore(this.bossCreature.scoreValue);
                            
                            // Create hit effects
                            this.particleEffect.createHitEffect(creature.mesh.position);
                            this.scorePopup.create(creature.mesh.position, this.bossCreature.scoreValue);
                            
                            // Clean up projectiles
                            this.bossCreature.cleanupProjectiles(this.scene);
                            
                            // Remove boss health bar
                            this.bossCreature.removeHealthBar();
                            
                            // Remove boss creature
                            this.removeCreature(creature);
                            this.bossCreature = null;
                        } else {
                            // Boss still alive, create smaller hit effect
                            this.particleEffect.createHitEffect(creature.mesh.position);
                        }
                        
                        return true;
                    }
                    
                    // Handle teleport ability
                    if (creature.ability === 'teleport' && creature.abilityActive && this.abilitySystem) {
                        const teleported = this.abilitySystem.triggerAbility(creature, this, 'teleport');
                        if (teleported) {
                            // Flash effect
                            creature.mesh.children.forEach(child => {
                                if (child.material) {
                                    const originalColor = child.material.color.clone();
                                    child.material.color.setHex(0x9370DB);
                                    setTimeout(() => {
                                        child.material.color.copy(originalColor);
                                    }, 100);
                                }
                            });
                            return true; // Hit registered but creature teleported
                        }
                    }
                    
                    // Handle shield ability
                    if (creature.ability === 'shield' && creature.health > 1) {
                        creature.health--;
                        debug.log('Shield hit! Health remaining:', creature.health);
                        
                        // Play shield sound
                        if (this.abilitySystem) {
                            this.abilitySystem.playAbilitySound('shield');
                        }
                        
                        // Flash shield indicator
                        const indicator = creature.mesh.getObjectByName('abilityIndicator');
                        if (indicator) {
                            indicator.material.opacity = 0.8;
                            setTimeout(() => {
                                indicator.material.opacity = 0.3;
                            }, 100);
                        }
                        
                        // Create small hit effect
                        this.particleEffect.createHitEffect(creature.mesh.position);
                        
                        // If shield broken, remove indicator
                        if (creature.health <= 1) {
                            if (indicator) {
                                creature.mesh.remove(indicator);
                            }
                        }
                        
                        return true;
                    }
                    
                    // Handle bomb mole - LOSE POINTS (unless reverse mode!)
                    if (creature.type === 'bomb') {
                        const isReverseMode = gameState.specialEventsManager && gameState.specialEventsManager.isReverseMode();
                        
                        if (isReverseMode) {
                            // Reverse mode - bombs give points!
                            debug.log('Hit bomb in reverse mode! +300 points!');
                            gameState.scoreManager.addScore(300);
                            gameState.comboManager.addHit();
                            
                            // Add to streak in reverse mode
                            if (gameState.streakManager) {
                                gameState.streakManager.addHit();
                            }
                            
                            this.particleEffect.createHitEffect(creature.mesh.position);
                            this.scorePopup.create(creature.mesh.position, 300);
                        } else {
                            // Normal mode - bombs lose points
                            debug.log('Hit bomb! Lose 200 points!');
                            
                            if (gameState.audioManager) {
                                gameState.audioManager.playExplosion();
                            }
                            
                            gameState.scoreManager.addScore(-200);
                            
                            if (gameState.comboManager) {
                                gameState.comboManager.resetCombo();
                            }
                            
                            // Reset streak on bomb hit
                            if (gameState.streakManager) {
                                gameState.streakManager.resetStreak();
                            }
                            
                            this.particleEffect.createExplosionEffect(creature.mesh.position);
                            this.scorePopup.create(creature.mesh.position, -200);
                        }
                        
                        this.removeCreature(creature);
                        return true;
                    }
                    
                    // Play hit sound
                    if (gameState.audioManager) {
                        gameState.audioManager.playHit();
                    }
                    
                    // Record hit for difficulty adjustment
                    if (gameState.difficultyManager) {
                        gameState.difficultyManager.recordHit();
                    }
                    
                    // Add to combo
                    gameState.comboManager.addHit();
                    
                    // Add to streak for multiplier tracking
                    if (gameState.streakManager) {
                        gameState.streakManager.addHit();
                    }
                    
                    // Calculate score based on creature type
                    let baseScore;
                    if (creature.type === 'golden') {
                        baseScore = 300;
                    } else {
                        baseScore = 100;
                    }
                    
                    const comboMultiplier = gameState.comboManager.getMultiplier();
                    const streakMultiplier = gameState.streakManager ? gameState.streakManager.getMultiplier() : 1.0;
                    const powerUpMultiplier = gameState.powerUpManager ? gameState.powerUpManager.getPointsMultiplier() : 1;
                    const score = Math.floor(baseScore * comboMultiplier * streakMultiplier * powerUpMultiplier);
                    
                    gameState.scoreManager.addScore(score);
                    
                    // Create hit effects
                    this.particleEffect.createHitEffect(creature.mesh.position);
                    this.scorePopup.create(creature.mesh.position, score, comboMultiplier);
                    
                    // Flash effect
                    creature.mesh.children.forEach(child => {
                        if (child.material) {
                            const originalColor = child.material.color.clone();
                            child.material.color.setHex(0xffffff);
                            setTimeout(() => {
                                child.material.color.copy(originalColor);
                            }, 100);
                        }
                    });
                    
                    // Handle split ability before removing creature
                    if (creature.ability === 'split' && creature.abilityActive && this.abilitySystem) {
                        this.abilitySystem.handleDefeat(creature, this);
                        if (this.abilitySystem) {
                            this.abilitySystem.playAbilitySound('split');
                        }
                    }
                    
                    this.removeCreature(creature);
                    return true;
                }
                return false;
            }

            setSpawnRateMultiplier(multiplier) {
                this.spawnInterval = 1400 / multiplier;
                debug.log('Spawn rate multiplier set to:', multiplier, 'New interval:', this.spawnInterval);
            }

            getSpawnRateMultiplier() {
                return 1400 / this.spawnInterval;
            }
        }

        // ProgressionManager for milestone tracking
        class ProgressionManager {
            constructor() {
                this.hitCount = 0;
                this.score = 0;
                this.unlockedTypes = new Set(['mole', 'rabbit', 'squirrel', 'badger']);
                
                // Hit-based milestones
                this.hitMilestones = [
                    { threshold: 10, type: 'speed', unlocked: false, name: 'Speed Boost Creatures' },
                    { threshold: 25, type: 'teleport', unlocked: false, name: 'Teleporting Creatures' },
                    { threshold: 40, type: 'shield', unlocked: false, name: 'Shield Creatures' },
                    { threshold: 60, type: 'mimic', unlocked: false, name: 'Mimic Creatures' }
                ];
                
                // Score-based thresholds
                this.scoreThresholds = [
                    { threshold: 1000, type: 'maxCreatures', applied: false, name: 'Max Creatures +1' },
                    { threshold: 2500, type: 'visibleTime', applied: false, name: 'Visible Time -15%' }
                ];
                
                this.creatureManager = null;
                this.notificationCallback = null;
            }

            setCreatureManager(creatureManager) {
                this.creatureManager = creatureManager;
            }

            setNotificationCallback(callback) {
                this.notificationCallback = callback;
            }

            recordHit() {
                this.hitCount++;
                this.checkMilestones();
            }

            updateScore(newScore) {
                this.score = newScore;
                this.checkScoreThresholds();
            }

            checkMilestones() {
                for (const milestone of this.hitMilestones) {
                    if (!milestone.unlocked && this.hitCount >= milestone.threshold) {
                        this.unlockCreatureType(milestone.type, milestone.name);
                        milestone.unlocked = true;
                    }
                }
            }

            checkScoreThresholds() {
                for (const threshold of this.scoreThresholds) {
                    if (!threshold.applied && this.score >= threshold.threshold) {
                        this.adjustDifficulty(threshold.type, threshold.name);
                        threshold.applied = true;
                    }
                }
            }

            unlockCreatureType(type, name) {
                this.unlockedTypes.add(type);
                this.showUnlockNotification(name);
            }

            adjustDifficulty(type, name) {
                if (type === 'maxCreatures' && this.creatureManager) {
                    this.creatureManager.maxSimultaneous++;
                    debug.log('Max simultaneous creatures increased to:', this.creatureManager.maxSimultaneous);
                } else if (type === 'visibleTime' && this.creatureManager) {
                    this.creatureManager.visibleTime *= 0.85;
                    debug.log('Visible time reduced to:', this.creatureManager.visibleTime);
                }
                
                this.showUnlockNotification(name);
            }

            showUnlockNotification(name) {
                debug.log('üéâ UNLOCKED:', name);
                
                if (this.notificationCallback) {
                    this.notificationCallback(name);
                }
                
                // Remove any existing unlock banners first
                const existingBanners = document.querySelectorAll('.unlock-notification-banner');
                existingBanners.forEach(b => {
                    if (b.parentNode) {
                        b.parentNode.removeChild(b);
                    }
                });
                
                // Show banner notification in UI
                const banner = document.createElement('div');
                banner.className = 'unlock-notification-banner';
                banner.style.position = 'fixed';
                banner.style.top = '20%';
                banner.style.left = '50%';
                banner.style.transform = 'translateX(-50%)';
                banner.style.backgroundColor = 'rgba(255, 215, 0, 0.9)';
                banner.style.color = '#000';
                banner.style.padding = '20px 40px';
                banner.style.borderRadius = '10px';
                banner.style.fontSize = '24px';
                banner.style.fontWeight = 'bold';
                banner.style.zIndex = '10000';
                banner.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
                banner.style.pointerEvents = 'none';
                banner.textContent = `üéâ ${name} Unlocked!`;
                document.body.appendChild(banner);
                
                setTimeout(() => {
                    banner.style.transition = 'opacity 0.5s';
                    banner.style.opacity = '0';
                    setTimeout(() => {
                        if (banner.parentNode) {
                            banner.parentNode.removeChild(banner);
                        }
                    }, 500);
                }, 3000);
            }

            isUnlocked(creatureType) {
                return this.unlockedTypes.has(creatureType);
            }

            getAvailableCreatureTypes() {
                return Array.from(this.unlockedTypes);
            }

            getHitCount() {
                return this.hitCount;
            }

            getScore() {
                return this.score;
            }
        }

        // Minimal ScoreManager
        class ScoreManager {
            constructor() {
                this.score = 0;
                this.startTime = Date.now();
                this.gracePeriod = 10000; // 10 seconds grace period at start
            }

            addScore(points) {
                this.score += points;
                
                // Game over if score reaches 0 (but only after grace period)
                const timeSinceStart = Date.now() - this.startTime;
                if (this.score <= 0 && timeSinceStart > this.gracePeriod) {
                    this.score = 0;
                    this.gameOver();
                } else if (this.score < 0) {
                    // During grace period, don't let score go below 0
                    this.score = 0;
                }
                
                this.updateDisplay();
                
                // Check high score
                if (gameState.highScoreManager) {
                    gameState.highScoreManager.checkAndSave(this.score);
                }
                
                // Update progression manager with new score
                if (gameState.progressionManager) {
                    gameState.progressionManager.updateScore(this.score);
                }
            }

            gameOver() {
                debug.log('Game Over - Score reached 0');
                
                const screen = document.getElementById('game-over-screen');
                screen.classList.add('lost');
                screen.querySelector('h2').textContent = 'üíÄ Game Over üíÄ';
                
                document.getElementById('final-score').textContent = this.score;
                
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('final-time').textContent = `${mins}:${secs}`;
                
                screen.style.display = 'flex';
                gameState.paused = true;
            }

            updateDisplay() {
                document.getElementById('total-score').textContent = this.score;
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${mins}:${secs}`;
            }
        }

        // Minimal InputManager
        class InputManager {
            constructor(scene, camera, renderer, creatureManager) {
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.creatureManager = creatureManager;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.lastClickTime = 0;
                this.clickCooldown = 100; // 100ms cooldown (reduced for better responsiveness)
                this.controllers = [];
                this.controllerGrips = [];
            }

            initialize() {
                this.renderer.domElement.addEventListener('click', (e) => this.onClick(e));
                
                // Setup VR controllers if in VR mode
                if (gameState.webXRSupported && this.renderer.xr.enabled) {
                    this.setupVRControllers();
                }
                
                debug.log('Input manager initialized');
            }

            setupVRControllers() {
                // Setup controller 0 (right hand typically)
                const controller0 = this.renderer.xr.getController(0);
                controller0.addEventListener('select', () => this.onVRSelect(controller0));
                this.scene.add(controller0);
                this.controllers.push(controller0);

                // Setup controller 1 (left hand typically)
                const controller1 = this.renderer.xr.getController(1);
                controller1.addEventListener('select', () => this.onVRSelect(controller1));
                this.scene.add(controller1);
                this.controllers.push(controller1);

                // Add visual ray for controllers
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -1)
                ]);
                const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
                
                this.controllers.forEach(controller => {
                    const line = new THREE.Line(geometry, material);
                    line.name = 'line';
                    line.scale.z = 5;
                    controller.add(line);
                });

                debug.log('VR controllers initialized');
            }

            onVRSelect(controller) {
                // Don't process if game is paused
                if (gameState.paused) return;

                // Cooldown check
                const now = Date.now();
                if (now - this.lastClickTime < this.clickCooldown) return;
                this.lastClickTime = now;

                // Use controller's world position and direction for raycasting
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);

                this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                // Check power-ups first
                if (gameState.powerUpManager) {
                    const powerUpMeshes = gameState.powerUpManager.powerUps.map(p => p.mesh);
                    const powerUpIntersects = this.raycaster.intersectObjects(powerUpMeshes, true);
                    
                    if (powerUpIntersects.length > 0) {
                        const powerUp = gameState.powerUpManager.powerUps.find(p => 
                            p.mesh === powerUpIntersects[0].object || 
                            p.mesh.children.includes(powerUpIntersects[0].object)
                        );
                        if (powerUp) {
                            gameState.powerUpManager.collectPowerUp(powerUp);
                            return;
                        }
                    }
                }

                // Check creatures
                const creatures = this.creatureManager.creatures
                    .filter(c => c && c.mesh && (c.state === 'visible' || c.state === 'emerging'))
                    .map(c => c.mesh);

                const intersects = this.raycaster.intersectObjects(creatures, true);

                if (intersects.length > 0) {
                    const hitMesh = intersects[0].object;
                    let hitCreature = null;

                    for (const creature of this.creatureManager.creatures) {
                        if (creature.mesh === hitMesh || creature.mesh.children.includes(hitMesh)) {
                            hitCreature = creature;
                            break;
                        }
                    }

                    if (hitCreature) {
                        this.creatureManager.hitCreature(hitCreature);
                    }
                }
            }

            onClick(event) {
                // Don't process clicks if game is paused
                if (gameState.paused) {
                    return;
                }
                
                // Check cooldown
                const now = Date.now();
                if (now - this.lastClickTime < this.clickCooldown) {
                    debug.log('Click ignored - cooldown active');
                    return;
                }
                this.lastClickTime = now;

                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Check power-ups first
                if (gameState.powerUpManager) {
                    const powerUpMeshes = gameState.powerUpManager.powerUps.map(p => p.mesh);
                    const powerUpIntersects = this.raycaster.intersectObjects(powerUpMeshes, true);
                    
                    if (powerUpIntersects.length > 0) {
                        let hitObject = powerUpIntersects[0].object;
                        while (hitObject.parent && !powerUpMeshes.includes(hitObject)) {
                            hitObject = hitObject.parent;
                        }
                        
                        const powerUp = gameState.powerUpManager.powerUps.find(p => p.mesh === hitObject);
                        if (powerUp) {
                            gameState.powerUpManager.collectPowerUp(powerUp);
                            return;
                        }
                    }
                }
                
                // Check creatures
                const creatures = this.creatureManager.creatures.map(c => c.mesh);
                
                // Update world matrices to account for walking animation
                creatures.forEach(mesh => {
                    mesh.updateMatrixWorld(true);
                });
                
                const intersects = this.raycaster.intersectObjects(creatures, true);

                if (intersects.length > 0) {
                    // Find which creature was hit by checking parent groups
                    let hitObject = intersects[0].object;
                    while (hitObject.parent && !creatures.includes(hitObject)) {
                        hitObject = hitObject.parent;
                    }
                    
                    const creature = this.creatureManager.creatures.find(c => c.mesh === hitObject);
                    if (creature) {
                        this.creatureManager.hitCreature(creature);
                    }
                } else {
                    // Missed - clicked on grass
                    this.handleMiss(event);
                }
            }

            handleMiss(event) {
                debug.log('Miss!');
                
                // Check if we scared any nearby creatures
                const rect = this.renderer.domElement.getBoundingClientRect();
                const clickX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const clickY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(new THREE.Vector2(clickX, clickY), this.camera);
                const clickPoint = new THREE.Vector3();
                this.raycaster.ray.intersectPlane(
                    new THREE.Plane(new THREE.Vector3(0, 1, 0), 0),
                    clickPoint
                );
                
                // Scare nearby creatures with 'scared' personality
                this.creatureManager.creatures.forEach(creature => {
                    if (creature.personality === 'scared' && creature.state === 'visible') {
                        const distance = creature.mesh.position.distanceTo(clickPoint);
                        if (distance < 0.3) {
                            creature.isScared = true;
                            creature.scaredTime = Date.now();
                            // Run away from click point
                            creature.scaredDirection.subVectors(creature.mesh.position, clickPoint).normalize();
                        }
                    }
                });
                
                // Break combo
                if (gameState.comboManager) {
                    gameState.comboManager.resetCombo();
                }
                
                // NO score penalty for misses (requirement 6.3)
                
                // Play miss sound
                if (gameState.audioManager) {
                    gameState.audioManager.playMiss();
                }
                
                // Show subtle miss indicator using VisualEffectsManager
                if (gameState.visualEffectsManager) {
                    gameState.visualEffectsManager.spawnMissEffect(clickPoint);
                }
                
                // Show miss indicator at click position
                this.showMissIndicator(event);
            }

            showMissIndicator(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Create DOM element for miss indicator
                const indicator = document.createElement('div');
                indicator.textContent = '‚úó';
                indicator.style.position = 'absolute';
                indicator.style.left = x + 'px';
                indicator.style.top = y + 'px';
                indicator.style.color = '#ff4444';
                indicator.style.fontSize = '3em';
                indicator.style.fontWeight = 'bold';
                indicator.style.pointerEvents = 'none';
                indicator.style.zIndex = '9999';
                indicator.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                indicator.style.transform = 'translate(-50%, -50%)';
                indicator.style.animation = 'missAnim 0.5s ease-out';
                
                document.body.appendChild(indicator);
                
                setTimeout(() => {
                    document.body.removeChild(indicator);
                }, 500);
            }
        }

        // Initialize Three.js
        async function initializeThreeJS() {
            debug.log('Initializing Three.js...');

            gameState.scene = new THREE.Scene();
            gameState.scene.background = new THREE.Color(0x87CEEB);

            gameState.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            gameState.renderer = new THREE.WebGLRenderer({ antialias: true });
            gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            gameState.renderer.shadowMap.enabled = true;
            gameState.renderer.xr.enabled = true;
            document.getElementById('canvas-container').appendChild(gameState.renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            gameState.scene.add(ambientLight);
            gameState.ambientLight = ambientLight; // Store reference

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(3, 6, 2);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 20;
            gameState.scene.add(dirLight);
            gameState.directionalLight = dirLight; // Store reference

            // Add subtle fill light
            const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
            fillLight.position.set(-2, 3, -2);
            gameState.scene.add(fillLight);

            // Ground with texture
            const groundGeo = new THREE.PlaneGeometry(5, 5);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x2d4a2b,
                roughness: 0.95,
                metalness: 0
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = 'ground'; // Name it for easy reference
            gameState.scene.add(ground);
            gameState.groundMesh = ground; // Store reference

            // Add dense grass patches for visual interest
            for (let i = 0; i < 80; i++) {
                const size = 0.05 + Math.random() * 0.12;
                const patchGeo = new THREE.CircleGeometry(size, 8);
                const greenShade = Math.random();
                let color;
                if (greenShade < 0.33) {
                    color = 0x3a5f38;
                } else if (greenShade < 0.66) {
                    color = 0x4a7c47;
                } else {
                    color = 0x2d5a2b;
                }
                const patchMat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.4 + Math.random() * 0.3
                });
                const patch = new THREE.Mesh(patchGeo, patchMat);
                patch.rotation.x = -Math.PI / 2;
                patch.position.set(
                    (Math.random() - 0.5) * 4.8,
                    0.01,
                    (Math.random() - 0.5) * 4.8
                );
                gameState.scene.add(patch);
            }

            debug.log('Three.js initialized');
        }

        // Initialize WebXR
        async function initializeWebXR() {
            debug.log('Initializing WebXR...');
            
            if (!navigator.xr) {
                throw new Error('WebXR not available');
            }

            const supported = await navigator.xr.isSessionSupported('immersive-ar');
            if (!supported) {
                throw new Error('AR not supported');
            }

            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.getElementById('ui-overlay') }
            });

            await gameState.renderer.xr.setSession(session);
            debug.log('WebXR initialized');
        }

        // Initialize game managers
        async function initializeGameManagers() {
            debug.log('Initializing game managers...');

            gameState.highScoreManager = new HighScoreManager();

            gameState.audioManager = new AudioManager();
            gameState.audioManager.init();

            gameState.comboManager = new ComboManager();
            gameState.difficultyManager = new DifficultyManager();
            gameState.difficultyManager.updateUI();

            gameState.holeManager = new HoleManager(gameState.scene);
            gameState.holeManager.createHoleGrid();

            gameState.creatureManager = new CreatureManager(gameState.scene, gameState.holeManager);
            gameState.scoreManager = new ScoreManager();
            gameState.powerUpManager = new PowerUpManager(gameState.scene);
            gameState.specialEventsManager = new SpecialEventsManager(gameState.scene);
            
            // Initialize ChaosEventManager for wacky gameplay events
            gameState.chaosEventManager = new ChaosEventManager(gameState.scene);
            debug.log('ChaosEventManager initialized');
            
            // Initialize ProgressionManager
            gameState.progressionManager = new ProgressionManager();
            gameState.progressionManager.setCreatureManager(gameState.creatureManager);
            
            // Initialize VisualEffectsManager if not already initialized
            if (!gameState.visualEffectsManager) {
                gameState.visualEffectsManager = new VisualEffectsManager(gameState.scene);
            }

            // Initialize PerformanceMonitor
            gameState.performanceMonitor = new PerformanceMonitor();

            // Initialize EnvironmentManager
            gameState.environmentManager = new EnvironmentManager(
                gameState.scene,
                gameState.audioManager,
                gameState.performanceMonitor
            );
            gameState.environmentManager.setSceneReferences(
                gameState.groundMesh,
                gameState.ambientLight,
                gameState.directionalLight
            );

            // Load saved preferences or use defaults (Requirements 11.1, 11.2, 11.3, 11.4, 11.5)
            const preferences = gameState.environmentManager.loadPreferences();
            
            // Set biome (use saved preference or random selection)
            const biomeTypes = ['forest', 'desert', 'arctic', 'volcanic'];
            const selectedBiome = preferences.biome || biomeTypes[Math.floor(Math.random() * biomeTypes.length)];
            gameState.environmentManager.setActiveBiome(selectedBiome);
            debug.log('Initial biome set to:', selectedBiome);
            
            // Set weather (use saved preference or default to clear)
            if (preferences.weatherEnabled && preferences.weatherType) {
                gameState.environmentManager.setWeather(preferences.weatherType);
                debug.log('Initial weather set to:', preferences.weatherType);
            }
            
            // Set day-night cycle (use saved preference or default to disabled)
            if (preferences.dayNightEnabled) {
                gameState.environmentManager.enableDayNightCycle(true);
                debug.log('Day-night cycle enabled from preferences');
            }
            
            // Update UI elements to reflect loaded preferences
            updateSettingsUI(preferences, selectedBiome);

            // Initialize VisualEffectsManager for particle systems and animations
            gameState.visualEffectsManager = new VisualEffectsManager(gameState.scene);
            debug.log('VisualEffectsManager initialized');

            // Initialize EnvironmentCycleManager for automatic biome transitions
            gameState.environmentCycleManager = new EnvironmentCycleManager(gameState.environmentManager);
            debug.log('EnvironmentCycleManager initialized');

            // Initialize StreakManager for combo multipliers
            gameState.streakManager = new StreakManager();
            debug.log('StreakManager initialized');

            // Initialize CameraEffectsManager for dynamic camera movements
            gameState.cameraEffectsManager = new CameraEffectsManager(gameState.camera);
            debug.log('CameraEffectsManager initialized');

            // Initialize IntensityManager for progressive difficulty
            gameState.intensityManager = new IntensityManager();
            gameState.intensityManager.setCreatureManager(gameState.creatureManager);
            gameState.intensityManager.setChaosEventManager(gameState.chaosEventManager);
            gameState.intensityManager.setStreakManager(gameState.streakManager);
            debug.log('IntensityManager initialized');

            // Wire up event listeners between managers
            // Connect StreakManager celebration to CameraEffectsManager zoom effect
            gameState.streakManager.setCelebrationCallback(() => {
                if (gameState.cameraEffectsManager) {
                    gameState.cameraEffectsManager.zoom(gameState.camera.fov - 5, 1.0);
                    debug.log('20-hit streak celebration: camera zoom triggered');
                }
            });
            debug.log('Event listeners wired between managers');

            gameState.inputManager = new InputManager(
                gameState.scene,
                gameState.camera,
                gameState.renderer,
                gameState.creatureManager
            );
            gameState.inputManager.initialize();

            debug.log('Game managers initialized');
        }

        // Desktop render loop
        function startDesktopRenderLoop() {
            let lastTime = performance.now();
            let frameCount = 0;
            let fpsTime = performance.now();
            
            function animate() {
                requestAnimationFrame(animate);
                
                try {
                    const currentTime = performance.now();
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;
                    
                    // FPS monitoring (log every 5 seconds)
                    frameCount++;
                    if (currentTime - fpsTime > 5000) {
                        const fps = frameCount / 5;
                        debug.log(`FPS: ${fps.toFixed(1)}, Creatures: ${gameState.creatureManager ? gameState.creatureManager.creatures.length : 0}`);
                        frameCount = 0;
                        fpsTime = currentTime;
                    }

                    if (!gameState.paused) {
                        if (gameState.performanceMonitor) {
                            gameState.performanceMonitor.update(deltaTime);
                        }

                        if (gameState.environmentCycleManager) {
                            gameState.environmentCycleManager.update(deltaTime);
                        }

                        if (gameState.environmentManager) {
                            gameState.environmentManager.update(deltaTime);
                        }

                        if (gameState.visualEffectsManager) {
                            gameState.visualEffectsManager.update(deltaTime);
                        }

                        if (gameState.cameraEffectsManager) {
                            gameState.cameraEffectsManager.update(deltaTime);
                        }

                        if (gameState.intensityManager) {
                            gameState.intensityManager.update(deltaTime);
                        }

                        if (gameState.creatureManager) {
                            gameState.creatureManager.update(deltaTime);
                        }

                        if (gameState.powerUpManager) {
                            gameState.powerUpManager.update(deltaTime);
                        }

                    if (gameState.specialEventsManager) {
                        gameState.specialEventsManager.update(deltaTime);
                    }

                        if (gameState.chaosEventManager) {
                            gameState.chaosEventManager.update(deltaTime);
                        }

                        if (gameState.scoreManager) {
                            gameState.scoreManager.updateDisplay();
                        }
                    }

                    gameState.renderer.render(gameState.scene, gameState.camera);
                } catch (e) {
                    debug.error('Rendering error in desktop loop:', e);
                    // Continue rendering despite errors
                }
            }
            animate();
            debug.log('Desktop render loop started');
        }

        // AR render loop
        function startARRenderLoop() {
            gameState.renderer.setAnimationLoop((timestamp, frame) => {
                try {
                    const deltaTime = 0.016;

                    if (!gameState.paused) {
                        if (gameState.performanceMonitor) {
                            gameState.performanceMonitor.update(deltaTime);
                        }

                        if (gameState.environmentCycleManager) {
                            gameState.environmentCycleManager.update(deltaTime);
                        }

                        if (gameState.environmentManager) {
                            gameState.environmentManager.update(deltaTime);
                        }

                        if (gameState.visualEffectsManager) {
                            gameState.visualEffectsManager.update(deltaTime);
                        }

                        if (gameState.cameraEffectsManager) {
                            gameState.cameraEffectsManager.update(deltaTime);
                        }

                        if (gameState.intensityManager) {
                            gameState.intensityManager.update(deltaTime);
                        }

                        if (gameState.creatureManager) {
                            gameState.creatureManager.update(deltaTime);
                        }

                        if (gameState.powerUpManager) {
                            gameState.powerUpManager.update(deltaTime);
                        }

                        if (gameState.specialEventsManager) {
                            gameState.specialEventsManager.update(deltaTime);
                        }

                        if (gameState.scoreManager) {
                            gameState.scoreManager.updateDisplay();
                        }
                    }

                    gameState.renderer.render(gameState.scene, gameState.camera);
                } catch (e) {
                    debug.error('Rendering error in AR loop:', e);
                    // Continue rendering despite errors
                }
            });
            debug.log('AR render loop started');
        }

        // Start game
        async function startGame() {
            debug.log('Starting game...');
            
            try {
                await initializeThreeJS();

                // Check WebXR support
                gameState.webXRSupported = navigator.xr && await navigator.xr.isSessionSupported('immersive-ar');

                if (!gameState.webXRSupported) {
                    // Desktop mode
                    debug.log('‚ö†Ô∏è Starting in Desktop Mode');
                    
                    gameState.camera.position.set(0, 2, 3);
                    gameState.camera.lookAt(0, 0, 0);

                    await initializeGameManagers();
                    startDesktopRenderLoop();
                } else {
                    // AR mode
                    debug.log('‚úì Starting in AR Mode');
                    
                    await initializeWebXR();
                    await initializeGameManagers();
                    startARRenderLoop();
                }

                document.getElementById('start-screen').style.display = 'none';
                gameState.gameStarted = true;
                
                // Start automatic environment cycling
                if (gameState.environmentCycleManager) {
                    gameState.environmentCycleManager.startCycling();
                }
                
                // Start intensity progression
                if (gameState.intensityManager) {
                    gameState.intensityManager.start();
                }
                
                debug.log('Game started successfully');

            } catch (error) {
                console.error('Failed to start game:', error);
                showError('Failed to start game: ' + error.message);
            }
        }

        // Setup event listeners
        // Update settings UI to reflect current preferences
        function updateSettingsUI(preferences, currentBiome) {
            // Update biome dropdown
            const biomeSelect = document.getElementById('biome-select');
            if (preferences.biome) {
                biomeSelect.value = preferences.biome;
            } else {
                biomeSelect.value = 'random';
            }
            
            // Update weather checkbox
            const weatherToggle = document.getElementById('weather-toggle');
            weatherToggle.checked = preferences.weatherEnabled;
            
            // Update day-night checkbox
            const dayNightToggle = document.getElementById('daynight-toggle');
            dayNightToggle.checked = preferences.dayNightEnabled;
            
            debug.log('Settings UI updated with preferences');
        }

        function setupEventListeners() {
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', () => {
                location.reload();
            });
            
            // Settings button - open modal
            document.getElementById('settings-button').addEventListener('click', () => {
                document.getElementById('settings-modal').style.display = 'flex';
            });
            
            // Close settings button
            document.getElementById('close-settings-button').addEventListener('click', () => {
                document.getElementById('settings-modal').style.display = 'none';
            });
            
            // Biome selection dropdown
            document.getElementById('biome-select').addEventListener('change', (e) => {
                const biomeType = e.target.value;
                
                if (gameState.environmentManager) {
                    if (biomeType === 'random') {
                        // Select random biome
                        const biomes = ['forest', 'desert', 'arctic', 'volcanic'];
                        const randomBiome = biomes[Math.floor(Math.random() * biomes.length)];
                        gameState.environmentManager.setActiveBiome(randomBiome);
                        debug.log('Random biome selected:', randomBiome);
                    } else {
                        // Set specific biome
                        gameState.environmentManager.setActiveBiome(biomeType);
                    }
                }
            });
            
            // Weather toggle checkbox
            document.getElementById('weather-toggle').addEventListener('change', (e) => {
                const enabled = e.target.checked;
                
                if (gameState.environmentManager) {
                    if (enabled) {
                        // Enable weather with a default type (rain)
                        gameState.environmentManager.setWeather('rain');
                        debug.log('Weather enabled');
                    } else {
                        // Disable weather
                        gameState.environmentManager.setWeather('clear');
                        debug.log('Weather disabled');
                    }
                }
            });
            
            // Day-night cycle toggle checkbox
            document.getElementById('daynight-toggle').addEventListener('change', (e) => {
                const enabled = e.target.checked;
                
                if (gameState.environmentManager) {
                    gameState.environmentManager.enableDayNightCycle(enabled);
                    debug.log('Day-night cycle:', enabled ? 'enabled' : 'disabled');
                }
            });
            
            window.addEventListener('resize', () => {
                if (gameState.camera && gameState.renderer) {
                    gameState.camera.aspect = window.innerWidth / window.innerHeight;
                    gameState.camera.updateProjectionMatrix();
                    gameState.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }

        // Initialize app
        window.addEventListener('load', () => {
            debug.log('App loaded');
            setupEventListeners();
        });
    </script>
</body>
</html>
