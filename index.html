<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack-a-Mole AR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }

        #total-score {
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 5px;
        }

        #timer {
            font-size: 1.2em;
            opacity: 0.9;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        #level-info {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }

        #current-level {
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #level-progress {
            font-size: 1em;
            opacity: 0.8;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2000;
        }

        #start-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        #start-screen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.5;
        }

        #start-button {
            padding: 15px 30px;
            font-size: 1.3em;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        #start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
            z-index: 3000;
            display: none;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2500;
            display: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #level-completion-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2100;
        }

        #level-completion-screen h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #4CAF50;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .completion-stats {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            margin: 20px;
            min-width: 400px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            font-size: 1.3em;
        }

        .stat-label {
            font-weight: bold;
        }

        .stat-value {
            color: #4CAF50;
        }

        #next-level-button {
            padding: 15px 40px;
            font-size: 1.4em;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
        }

        #next-level-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #game-complete-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2200;
        }

        #game-complete-screen h2 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        #restart-button {
            padding: 15px 40px;
            font-size: 1.4em;
            background: linear-gradient(45deg, #FF6B6B, #FF5252);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
        }

        #restart-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <!-- Canvas container for Three.js -->
        <div id="canvas-container"></div>

        <!-- UI Overlay -->
        <div id="ui-overlay">
            <div id="score-display">
                <div id="total-score">0</div>
                <div id="timer">00:00</div>
            </div>

            <div id="level-info">
                <div id="current-level">Level 1</div>
                <div id="level-progress">0 / 10</div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1>ðŸŽ¯ Whack-a-Mole AR</h1>
            <p>
                Welcome to the ultimate AR whack-a-mole experience!<br>
                Hit creatures as they emerge from holes to score points.<br>
                Miss them and lose points. Progress through 4 challenging levels!
            </p>
            <button id="start-button">Start AR Game</button>
        </div>

        <!-- Loading Screen -->
        <div id="loading-screen">
            <div class="loading-spinner"></div>
            <p>Initializing AR session...</p>
        </div>

        <!-- Error Message -->
        <div id="error-message">
            <h3>Error</h3>
            <p id="error-text"></p>
            <button onclick="location.reload()">Retry</button>
        </div>

        <!-- Level Completion Screen -->
        <div id="level-completion-screen">
            <h2>Level Complete!</h2>
            <div class="completion-stats">
                <div class="stat-row">
                    <span class="stat-label">Level:</span>
                    <span class="stat-value" id="completed-level">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Level Score:</span>
                    <span class="stat-value" id="completed-level-score">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Score:</span>
                    <span class="stat-value" id="completed-total-score">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time:</span>
                    <span class="stat-value" id="completed-time">00:00</span>
                </div>
            </div>
            <button id="next-level-button">Next Level</button>
        </div>

        <!-- Game Complete Screen -->
        <div id="game-complete-screen">
            <h2>ðŸŽ‰ Game Complete! ðŸŽ‰</h2>
            <div class="completion-stats">
                <div class="stat-row">
                    <span class="stat-label">Final Score:</span>
                    <span class="stat-value" id="final-total-score">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Time:</span>
                    <span class="stat-value" id="final-time">00:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Levels Completed:</span>
                    <span class="stat-value">4</span>
                </div>
            </div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>

    <script>
        // Global game state
        let gameState = {
            initialized: false,
            webXRSupported: false,
            arSession: null,
            scene: null,
            camera: null,
            renderer: null,
            gameStarted: false,
            arManager: null,
            sceneManager: null,
            performanceMonitor: null,
            holeManager: null,
            particleSystem: null,
            scoreManager: null,
            gameManager: null,
            audioManager: null
        };

        // ARManager class for WebXR session management and AR initialization
        class ARManager {
            constructor(scene, renderer) {
                this.scene = scene;
                this.renderer = renderer;
                this.xrSession = null;
                this.hitTestSource = null;
                this.reticle = null;
                this.gameSpace = null;
                this.controller = null;
                this.surfaceDetected = false;
                this.isInitialized = false;

                // Bind methods to maintain context
                this.onSessionStart = this.onSessionStart.bind(this);
                this.onSessionEnd = this.onSessionEnd.bind(this);
                this.onControllerConnected = this.onControllerConnected.bind(this);
                this.onControllerDisconnected = this.onControllerDisconnected.bind(this);
            }

            // Check WebXR compatibility
            static async checkWebXRSupport() {
                console.log('Checking WebXR support...');

                if (!navigator.xr) {
                    console.warn('WebXR not available');
                    return false;
                }

                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    console.log('AR sessions supported:', supported);
                    return supported;
                } catch (error) {
                    console.error('Error checking AR support:', error);
                    return false;
                }
            }

            // Request and initialize AR session
            async requestARSession() {
                console.log('Requesting AR session...');

                try {
                    // Check for required features
                    const sessionInit = {
                        requiredFeatures: ['hit-test'],
                        optionalFeatures: ['dom-overlay', 'local-floor']
                    };

                    // Add DOM overlay if UI overlay exists
                    const uiOverlay = document.getElementById('ui-overlay');
                    if (uiOverlay) {
                        sessionInit.domOverlay = { root: uiOverlay };
                    }

                    // Request the session
                    this.xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);

                    // Set up session event listeners
                    this.xrSession.addEventListener('end', this.onSessionEnd);

                    // Set up the renderer with the session
                    await this.renderer.xr.setSession(this.xrSession);

                    console.log('AR session established successfully');
                    return this.xrSession;

                } catch (error) {
                    console.error('Failed to request AR session:', error);
                    throw new Error(`AR session request failed: ${error.message}`);
                }
            }

            // Initialize hit testing for surface detection
            async initializeHitTesting() {
                console.log('Initializing hit testing...');

                if (!this.xrSession) {
                    throw new Error('No active XR session for hit testing');
                }

                try {
                    // Request hit test source
                    this.hitTestSource = await this.xrSession.requestHitTestSource({
                        space: this.xrSession.viewerSpace
                    });

                    console.log('Hit test source created successfully');

                    // Create reticle for surface indication
                    this.createReticle();

                } catch (error) {
                    console.error('Failed to initialize hit testing:', error);
                    throw new Error(`Hit testing initialization failed: ${error.message}`);
                }
            }

            // Create visual reticle for surface detection
            createReticle() {
                const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });

                this.reticle = new THREE.Mesh(geometry, material);
                this.reticle.matrixAutoUpdate = false;
                this.reticle.visible = false;
                this.scene.add(this.reticle);

                console.log('Reticle created for surface detection');
            }

            // Detect and validate playing surface
            detectPlayingSurface(frame) {
                if (!this.hitTestSource || !frame) return false;

                try {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);

                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(this.xrSession.viewerSpace);

                        if (pose) {
                            // Update reticle position
                            this.reticle.matrix.fromArray(pose.transform.matrix);
                            this.reticle.visible = true;

                            // Check if surface is suitable (relatively flat and stable)
                            if (this.validateSurface(pose)) {
                                if (!this.surfaceDetected) {
                                    console.log('Suitable playing surface detected');
                                    this.surfaceDetected = true;
                                    this.setupGameSpace(pose);
                                }
                                return true;
                            }
                        }
                    } else {
                        this.reticle.visible = false;
                        this.surfaceDetected = false;
                    }
                } catch (error) {
                    console.error('Error during surface detection:', error);
                }

                return false;
            }

            // Validate if detected surface is suitable for gameplay
            validateSurface(pose) {
                // Check if surface is reasonably horizontal (normal vector pointing up)
                const matrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
                const normal = new THREE.Vector3(0, 1, 0).applyMatrix4(matrix).normalize();
                const upVector = new THREE.Vector3(0, 1, 0);

                // Surface should be relatively flat (within 30 degrees of horizontal)
                const angle = normal.angleTo(upVector);
                const maxAngle = Math.PI / 6; // 30 degrees

                return angle < maxAngle;
            }

            // Set up game space on detected surface
            setupGameSpace(pose) {
                console.log('Setting up game space...');

                // Create game space group
                this.gameSpace = new THREE.Group();
                this.gameSpace.matrix.fromArray(pose.transform.matrix);
                this.gameSpace.matrixAutoUpdate = false;
                this.scene.add(this.gameSpace);

                // Hide reticle once game space is established
                this.reticle.visible = false;

                console.log('Game space established on detected surface');
            }

            // Set up controller input handling
            setupControllerInput() {
                console.log('Setting up controller input...');

                // Get controller
                this.controller = this.renderer.xr.getController(0);
                this.controller.addEventListener('connected', this.onControllerConnected);
                this.controller.addEventListener('disconnected', this.onControllerDisconnected);
                this.scene.add(this.controller);

                // Add controller ray for visual feedback
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -1)
                ]);
                const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
                const line = new THREE.Line(geometry, material);
                line.name = 'controller-ray';
                line.scale.z = 5;
                this.controller.add(line);

                console.log('Controller input setup complete');
            }

            // Handle controller connection
            onControllerConnected(event) {
                console.log('Controller connected:', event.data);

                // Set up input source event listeners
                if (event.data.gamepad) {
                    console.log('Gamepad detected with', event.data.gamepad.buttons.length, 'buttons');
                }
            }

            // Handle controller disconnection
            onControllerDisconnected(event) {
                console.log('Controller disconnected');
            }

            // Perform raycast from controller for hit detection
            performRaycast(controller) {
                if (!controller) return null;

                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);

                const raycaster = new THREE.Raycaster();
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                return raycaster;
            }

            // Handle session start
            onSessionStart() {
                console.log('XR session started');
            }

            // Handle session end
            onSessionEnd() {
                console.log('XR session ended');
                this.cleanup();

                // Attempt session recovery if game was active
                if (gameState.gameStarted) {
                    this.attemptSessionRecovery();
                }
            }

            // Attempt to recover from session loss
            async attemptSessionRecovery() {
                console.log('Attempting AR session recovery...');

                // Pause the game during recovery
                if (gameState.gameManager) {
                    gameState.gameManager.pauseGame();
                }

                try {
                    // Show recovery message with countdown
                    showRecoveryMessage('AR session lost. Attempting to reconnect in 5 seconds...');

                    // Wait 5 seconds before attempting recovery as per requirements
                    await new Promise(resolve => setTimeout(resolve, 5000));

                    // Update recovery message
                    updateRecoveryMessage('Reconnecting to AR session...');

                    // Try to reinitialize AR
                    await this.initialize();

                    // Hide recovery message if successful
                    hideRecoveryMessage();

                    // Resume the game
                    if (gameState.gameManager) {
                        gameState.gameManager.resumeGame();
                    }

                    console.log('AR session recovery successful');

                } catch (error) {
                    console.error('AR session recovery failed:', error);
                    showPersistentError('AR session recovery failed. Please restart the game.', 'restart');
                }
            }

            // Initialize complete AR system
            async initialize() {
                console.log('Initializing AR system...');

                try {
                    // Request AR session
                    await this.requestARSession();

                    // Initialize hit testing
                    await this.initializeHitTesting();

                    // Set up controller input
                    this.setupControllerInput();

                    this.isInitialized = true;
                    console.log('AR system initialized successfully');

                } catch (error) {
                    console.error('AR system initialization failed:', error);
                    throw error;
                }
            }

            // Clean up AR resources
            cleanup() {
                console.log('Cleaning up AR resources...');

                if (this.hitTestSource) {
                    this.hitTestSource.cancel();
                    this.hitTestSource = null;
                }

                if (this.reticle) {
                    this.scene.remove(this.reticle);
                    this.reticle = null;
                }

                if (this.gameSpace) {
                    this.scene.remove(this.gameSpace);
                    this.gameSpace = null;
                }

                if (this.controller) {
                    this.scene.remove(this.controller);
                    this.controller = null;
                }

                this.xrSession = null;
                this.surfaceDetected = false;
                this.isInitialized = false;

                console.log('AR cleanup complete');
            }

            // Get current game space for placing game objects
            getGameSpace() {
                return this.gameSpace;
            }

            // Check if surface is detected and ready for gameplay
            isReady() {
                return this.isInitialized && this.surfaceDetected && this.gameSpace;
            }
        }

        // WebXR Compatibility Check (static method wrapper)
        async function checkWebXRSupport() {
            return await ARManager.checkWebXRSupport();
        }

        // Initialize the application
        async function initializeApp() {
            console.log('Initializing Whack-a-Mole AR...');

            // Check WebXR support
            gameState.webXRSupported = await checkWebXRSupport();

            if (!gameState.webXRSupported) {
                showFallbackMessage();
                return;
            }

            // Set up event listeners
            setupEventListeners();

            console.log('App initialized successfully');
            gameState.initialized = true;
        }

        // Show fallback message for non-AR devices
        function showFallbackMessage() {
            // Detect device type for better fallback messaging
            const isDesktop = !(/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            // Hide start screen and show appropriate compatibility error
            hideStartScreen();

            if (isDesktop) {
                showCompatibilityError('desktop', 'none');
            } else if (isMobile) {
                showCompatibilityError('mobile', 'limited');
            } else {
                showCompatibilityError('unknown', 'none');
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            const startButton = document.getElementById('start-button');
            startButton.addEventListener('click', startGame);

            // Handle page visibility changes
            document.addEventListener('visibilitychange', handleVisibilityChange);

            // Handle window resize
            window.addEventListener('resize', handleResize);

            // Handle browser focus/blur events for additional session management
            window.addEventListener('focus', handleWindowFocus);
            window.addEventListener('blur', handleWindowBlur);

            // Handle beforeunload for cleanup
            window.addEventListener('beforeunload', handleBeforeUnload);
        }

        // Start the game
        async function startGame() {
            if (!gameState.webXRSupported) {
                showError('WebXR AR is not supported on this device');
                return;
            }

            console.log('Starting game...');
            showLoadingScreen();

            try {
                // Resume audio context on user interaction (required by browsers)
                if (gameState.audioManager) {
                    await gameState.audioManager.resumeAudioContext();
                }

                // Initialize Three.js and WebXR
                await initializeThreeJS();
                await initializeWebXR();

                // Hide start screen and show game
                hideStartScreen();
                hideLoadingScreen();

                gameState.gameStarted = true;
                console.log('Game started successfully');

            } catch (error) {
                console.error('Failed to start game:', error);
                showError('Failed to initialize AR session: ' + error.message);
                hideLoadingScreen();
            }
        }

        // Performance monitoring system with optimization features
        class PerformanceMonitor {
            constructor() {
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 0;
                this.frameTime = 0;
                this.targetFPS = 72; // Meta Quest target FPS
                this.performanceWarningThreshold = 60; // Warn if below 60 FPS
                this.performanceHistory = [];
                this.maxHistoryLength = 60; // Keep 1 second of history at 60fps

                // Performance metrics
                this.metrics = {
                    averageFPS: 0,
                    minFPS: Infinity,
                    maxFPS: 0,
                    frameTimeVariance: 0,
                    droppedFrames: 0,
                    memoryUsage: 0,
                    renderCalls: 0,
                    triangleCount: 0
                };

                // Quality adjustment system
                this.qualityLevel = 1.0; // 1.0 = full quality, 0.5 = half quality, etc.
                this.qualityAdjustmentEnabled = true;
                this.lastQualityAdjustment = 0;
                this.qualityAdjustmentCooldown = 5000; // 5 seconds between adjustments

                // Performance thresholds for quality adjustment
                this.qualityThresholds = {
                    excellent: 72, // Above 72 FPS - can increase quality
                    good: 60,      // 60-72 FPS - maintain quality
                    poor: 45,      // 45-60 FPS - reduce quality slightly
                    critical: 30   // Below 30 FPS - aggressive quality reduction
                };

                // Benchmarking system
                this.benchmarkData = {
                    enabled: false,
                    startTime: 0,
                    samples: [],
                    maxSamples: 1000
                };

                console.log('Performance monitor initialized with target FPS:', this.targetFPS);
            }

            // Update performance metrics each frame
            update() {
                const currentTime = performance.now();
                this.frameTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                // Calculate FPS
                this.fps = 1000 / this.frameTime;
                this.frameCount++;

                // Update performance history
                this.performanceHistory.push({
                    fps: this.fps,
                    frameTime: this.frameTime,
                    timestamp: currentTime,
                    memoryUsage: this.getMemoryUsage()
                });

                // Limit history length
                if (this.performanceHistory.length > this.maxHistoryLength) {
                    this.performanceHistory.shift();
                }

                // Update metrics every 60 frames
                if (this.frameCount % 60 === 0) {
                    this.updateMetrics();
                }

                // Check for performance issues and log if below target
                if (this.fps < this.targetFPS) {
                    console.warn(`Performance: FPS ${this.fps.toFixed(1)} below target ${this.targetFPS}`);
                }

                // Handle dynamic quality adjustment
                if (this.qualityAdjustmentEnabled) {
                    this.handleDynamicQualityAdjustment();
                }

                // Store benchmark data if enabled
                if (this.benchmarkData.enabled) {
                    this.recordBenchmarkSample();
                }
            }

            // Update comprehensive performance metrics
            updateMetrics() {
                if (this.performanceHistory.length === 0) return;

                const recentFrames = this.performanceHistory.slice(-60);
                const fpsList = recentFrames.map(frame => frame.fps);

                // Calculate average FPS
                this.metrics.averageFPS = fpsList.reduce((sum, fps) => sum + fps, 0) / fpsList.length;

                // Calculate min/max FPS
                this.metrics.minFPS = Math.min(...fpsList);
                this.metrics.maxFPS = Math.max(...fpsList);

                // Calculate frame time variance
                const frameTimeList = recentFrames.map(frame => frame.frameTime);
                const avgFrameTime = frameTimeList.reduce((sum, time) => sum + time, 0) / frameTimeList.length;
                const variance = frameTimeList.reduce((sum, time) => sum + Math.pow(time - avgFrameTime, 2), 0) / frameTimeList.length;
                this.metrics.frameTimeVariance = Math.sqrt(variance);

                // Count dropped frames (frames that took longer than target)
                const targetFrameTime = 1000 / this.targetFPS;
                this.metrics.droppedFrames = frameTimeList.filter(time => time > targetFrameTime * 1.5).length;
            }

            // Handle performance warnings
            handlePerformanceWarning() {
                if (this.frameCount % 120 === 0) { // Throttle warnings
                    console.warn(`Performance warning: FPS dropped to ${this.fps.toFixed(1)} (target: ${this.targetFPS})`);

                    // Could trigger quality adjustments in future tasks
                    this.suggestOptimizations();
                }
            }

            // Handle dynamic quality adjustment based on performance
            handleDynamicQualityAdjustment() {
                const currentTime = performance.now();

                // Only adjust quality if cooldown has passed
                if (currentTime - this.lastQualityAdjustment < this.qualityAdjustmentCooldown) {
                    return;
                }

                const avgFPS = this.metrics.averageFPS || this.fps;
                let targetQuality = this.qualityLevel;

                if (avgFPS >= this.qualityThresholds.excellent && this.qualityLevel < 1.0) {
                    // Performance is excellent, can increase quality
                    targetQuality = Math.min(1.0, this.qualityLevel + 0.1);
                    console.log('Performance excellent, increasing quality to', targetQuality);
                } else if (avgFPS < this.qualityThresholds.critical) {
                    // Critical performance, aggressive quality reduction
                    targetQuality = Math.max(0.3, this.qualityLevel - 0.3);
                    console.warn('Critical performance, reducing quality to', targetQuality);
                } else if (avgFPS < this.qualityThresholds.poor) {
                    // Poor performance, moderate quality reduction
                    targetQuality = Math.max(0.5, this.qualityLevel - 0.2);
                    console.warn('Poor performance, reducing quality to', targetQuality);
                } else if (avgFPS < this.qualityThresholds.good) {
                    // Below good threshold, slight quality reduction
                    targetQuality = Math.max(0.7, this.qualityLevel - 0.1);
                    console.warn('Below target performance, reducing quality to', targetQuality);
                }

                if (targetQuality !== this.qualityLevel) {
                    this.applyQualityAdjustment(targetQuality);
                    this.lastQualityAdjustment = currentTime;
                }
            }

            // Apply quality adjustment to game systems
            applyQualityAdjustment(newQualityLevel) {
                const oldQuality = this.qualityLevel;
                this.qualityLevel = newQualityLevel;

                console.log(`Quality adjustment: ${oldQuality.toFixed(2)} â†’ ${newQualityLevel.toFixed(2)}`);

                // Apply quality changes to particle system
                if (gameState.particleSystem) {
                    const particleCount = Math.floor(75 * this.qualityLevel); // Base 75 particles
                    gameState.particleSystem.adjustQuality(this.qualityLevel, particleCount);
                }

                // Apply quality changes to creature spawning
                if (gameState.gameManager) {
                    gameState.gameManager.adjustSpawnQuality(this.qualityLevel);
                }

                // Adjust renderer settings
                if (gameState.renderer) {
                    const pixelRatio = Math.min(window.devicePixelRatio, 1 + this.qualityLevel);
                    gameState.renderer.setPixelRatio(pixelRatio);
                }
            }

            // Get memory usage information
            getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: performance.memory.usedJSHeapSize,
                        total: performance.memory.totalJSHeapSize,
                        limit: performance.memory.jsHeapSizeLimit
                    };
                }
                return { used: 0, total: 0, limit: 0 };
            }

            // Record benchmark sample
            recordBenchmarkSample() {
                if (this.benchmarkData.samples.length >= this.benchmarkData.maxSamples) {
                    return; // Benchmark complete
                }

                this.benchmarkData.samples.push({
                    timestamp: performance.now() - this.benchmarkData.startTime,
                    fps: this.fps,
                    frameTime: this.frameTime,
                    memoryUsage: this.getMemoryUsage(),
                    qualityLevel: this.qualityLevel
                });
            }

            // Start performance benchmark
            startBenchmark(duration = 30000) { // 30 seconds default
                console.log('Starting performance benchmark for', duration / 1000, 'seconds');

                this.benchmarkData.enabled = true;
                this.benchmarkData.startTime = performance.now();
                this.benchmarkData.samples = [];

                // Stop benchmark after duration
                setTimeout(() => {
                    this.stopBenchmark();
                }, duration);
            }

            // Stop performance benchmark and generate report
            stopBenchmark() {
                if (!this.benchmarkData.enabled) return;

                this.benchmarkData.enabled = false;
                const report = this.generateBenchmarkReport();
                console.log('Benchmark Report:', report);
                return report;
            }

            // Generate comprehensive benchmark report
            generateBenchmarkReport() {
                const samples = this.benchmarkData.samples;
                if (samples.length === 0) return null;

                const fpsList = samples.map(s => s.fps);
                const frameTimeList = samples.map(s => s.frameTime);

                const report = {
                    duration: samples[samples.length - 1].timestamp / 1000,
                    totalFrames: samples.length,
                    averageFPS: fpsList.reduce((a, b) => a + b, 0) / fpsList.length,
                    minFPS: Math.min(...fpsList),
                    maxFPS: Math.max(...fpsList),
                    medianFPS: this.calculateMedian(fpsList),
                    fps95thPercentile: this.calculatePercentile(fpsList, 0.95),
                    fps99thPercentile: this.calculatePercentile(fpsList, 0.99),
                    averageFrameTime: frameTimeList.reduce((a, b) => a + b, 0) / frameTimeList.length,
                    frameTimeVariance: this.calculateVariance(frameTimeList),
                    droppedFramePercentage: (frameTimeList.filter(t => t > 1000 / 60).length / frameTimeList.length) * 100,
                    qualityAdjustments: samples.filter((s, i) => i > 0 && s.qualityLevel !== samples[i - 1].qualityLevel).length,
                    memoryStats: this.calculateMemoryStats(samples)
                };

                return report;
            }

            // Calculate median value
            calculateMedian(values) {
                const sorted = [...values].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
            }

            // Calculate percentile value
            calculatePercentile(values, percentile) {
                const sorted = [...values].sort((a, b) => a - b);
                const index = Math.floor(sorted.length * percentile);
                return sorted[Math.min(index, sorted.length - 1)];
            }

            // Calculate variance
            calculateVariance(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                return Math.sqrt(variance);
            }

            // Calculate memory statistics
            calculateMemoryStats(samples) {
                const memoryData = samples.map(s => s.memoryUsage.used).filter(m => m > 0);
                if (memoryData.length === 0) return null;

                return {
                    averageUsed: memoryData.reduce((a, b) => a + b, 0) / memoryData.length,
                    maxUsed: Math.max(...memoryData),
                    minUsed: Math.min(...memoryData),
                    memoryGrowth: memoryData[memoryData.length - 1] - memoryData[0]
                };
            }

            // Suggest performance optimizations
            suggestOptimizations() {
                const suggestions = [];

                if (this.metrics.averageFPS < 60) {
                    suggestions.push('Consider reducing particle effects');
                    suggestions.push('Implement object pooling for creatures');
                    suggestions.push('Reduce spawn frequency during low performance');
                }

                if (this.metrics.frameTimeVariance > 5) {
                    suggestions.push('Frame time inconsistent - check for blocking operations');
                }

                if (this.metrics.memoryUsage.used > this.metrics.memoryUsage.limit * 0.8) {
                    suggestions.push('High memory usage - increase garbage collection frequency');
                }

                if (suggestions.length > 0) {
                    console.log('Performance optimization suggestions:', suggestions);
                }

                return suggestions;
            }

            // Stress test with maximum spawns
            async runStressTest(duration = 10000) {
                console.log('Starting stress test with maximum spawns for', duration / 1000, 'seconds');

                const originalSpawnRate = gameState.gameManager?.spawnInterval || 1000;
                const stressSpawnRate = 200; // Very fast spawning

                // Start benchmark
                this.startBenchmark(duration);

                // Increase spawn rate for stress test
                if (gameState.gameManager) {
                    gameState.gameManager.setSpawnInterval(stressSpawnRate);
                }

                // Wait for test duration
                await new Promise(resolve => setTimeout(resolve, duration));

                // Restore original spawn rate
                if (gameState.gameManager) {
                    gameState.gameManager.setSpawnInterval(originalSpawnRate);
                }

                // Get benchmark results
                const results = this.stopBenchmark();
                console.log('Stress test completed:', results);

                return results;
            }

            // Get current performance metrics
            getMetrics() {
                return {
                    currentFPS: this.fps,
                    frameTime: this.frameTime,
                    ...this.metrics
                };
            }

            // Reset performance tracking
            reset() {
                this.frameCount = 0;
                this.performanceHistory = [];
                this.metrics = {
                    averageFPS: 0,
                    minFPS: Infinity,
                    maxFPS: 0,
                    frameTimeVariance: 0,
                    droppedFrames: 0
                };
                console.log('Performance monitor reset');
            }
        }

        // AudioManager class for Web Audio API and spatial sound effects
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = new Map();
                this.initialized = false;
                this.spatialNodes = new Map(); // Track spatial audio nodes for cleanup
                this.backgroundMusic = null;
                this.backgroundGain = null;
                this.masterGain = null;
                this.currentLevel = 1;

                // Sound configuration
                this.soundConfig = {
                    hit: {
                        frequency: 800,
                        duration: 0.2,
                        type: 'square',
                        volume: 0.3
                    },
                    miss: {
                        frequency: 200,
                        duration: 0.5,
                        type: 'sawtooth',
                        volume: 0.2
                    },
                    background: {
                        baseFrequency: 220,
                        volume: 0.1,
                        intensityMultiplier: 1.2
                    }
                };

                console.log('AudioManager initialized');
            }

            // Initialize Web Audio API context
            async initializeAudioContext() {
                console.log('Initializing Web Audio API context...');

                try {
                    // Create audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create master gain node for volume control
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.setValueAtTime(0.7, this.audioContext.currentTime);

                    // Handle browser autoplay policy - context might be suspended
                    if (this.audioContext.state === 'suspended') {
                        console.log('Audio context suspended, will resume on user interaction');
                        // Context will be resumed when user interacts with the game
                        return false;
                    }

                    // Pre-generate sound buffers
                    await this.loadSounds();

                    this.initialized = true;
                    console.log('Audio context initialized successfully');
                    return true;

                } catch (error) {
                    console.error('Failed to initialize audio context:', error);
                    console.warn('Audio will be disabled - continuing in silent mode');
                    return false;
                }
            }

            // Resume audio context on user interaction (required by browsers)
            async resumeAudioContext() {
                if (!this.audioContext) {
                    await this.initializeAudioContext();
                }

                if (this.audioContext && this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                        console.log('Audio context resumed successfully');

                        if (!this.initialized) {
                            await this.loadSounds();
                            this.initialized = true;
                        }

                        return true;
                    } catch (error) {
                        console.error('Failed to resume audio context:', error);
                        return false;
                    }
                }

                return this.initialized;
            }

            // Pre-generate and load sound effects
            async loadSounds() {
                console.log('Loading sound effects...');

                try {
                    // Generate hit sound buffer
                    this.sounds.set('hit', this.generateSoundBuffer(this.soundConfig.hit));

                    // Generate miss sound buffer
                    this.sounds.set('miss', this.generateSoundBuffer(this.soundConfig.miss));

                    console.log('Sound effects loaded successfully');
                } catch (error) {
                    console.error('Failed to load sounds:', error);
                    throw error;
                }
            }

            // Generate procedural sound buffer
            generateSoundBuffer(config) {
                if (!this.audioContext) return null;

                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * config.duration;
                const buffer = this.audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                // Generate waveform based on type
                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    const frequency = config.frequency;

                    let sample = 0;
                    switch (config.type) {
                        case 'sine':
                            sample = Math.sin(2 * Math.PI * frequency * t);
                            break;
                        case 'square':
                            sample = Math.sign(Math.sin(2 * Math.PI * frequency * t));
                            break;
                        case 'sawtooth':
                            sample = 2 * (t * frequency - Math.floor(t * frequency + 0.5));
                            break;
                        case 'triangle':
                            sample = 2 * Math.abs(2 * (t * frequency - Math.floor(t * frequency + 0.5))) - 1;
                            break;
                        default:
                            sample = Math.sin(2 * Math.PI * frequency * t);
                    }

                    // Apply envelope (fade in/out)
                    const envelope = this.calculateEnvelope(t, config.duration);
                    data[i] = sample * envelope * config.volume;
                }

                return buffer;
            }

            // Calculate audio envelope for natural sound fade
            calculateEnvelope(time, duration) {
                const attackTime = 0.01; // 10ms attack
                const releaseTime = 0.1;  // 100ms release

                if (time < attackTime) {
                    // Attack phase
                    return time / attackTime;
                } else if (time > duration - releaseTime) {
                    // Release phase
                    return (duration - time) / releaseTime;
                } else {
                    // Sustain phase
                    return 1.0;
                }
            }

            // Play sound effect with spatial positioning
            playSound(soundName, position = null, volume = 1.0) {
                if (!this.initialized || !this.audioContext || !this.sounds.has(soundName)) {
                    console.warn(`Cannot play sound '${soundName}' - audio not initialized or sound not found`);
                    return null;
                }

                try {
                    const buffer = this.sounds.get(soundName);
                    if (!buffer) return null;

                    // Create audio source
                    const source = this.audioContext.createBufferSource();
                    source.buffer = buffer;

                    // Create gain node for volume control
                    const gainNode = this.audioContext.createGain();
                    gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);

                    let finalNode = gainNode;

                    // Add spatial audio if position is provided
                    if (position && this.audioContext.listener) {
                        const pannerNode = this.audioContext.createPanner();

                        // Configure spatial audio properties
                        pannerNode.panningModel = 'HRTF';
                        pannerNode.distanceModel = 'inverse';
                        pannerNode.refDistance = 1;
                        pannerNode.maxDistance = 10;
                        pannerNode.rolloffFactor = 1;
                        pannerNode.coneInnerAngle = 360;
                        pannerNode.coneOuterAngle = 0;
                        pannerNode.coneOuterGain = 0;

                        // Set position
                        pannerNode.positionX.setValueAtTime(position.x, this.audioContext.currentTime);
                        pannerNode.positionY.setValueAtTime(position.y, this.audioContext.currentTime);
                        pannerNode.positionZ.setValueAtTime(position.z, this.audioContext.currentTime);

                        // Connect: source -> gain -> panner -> master
                        source.connect(gainNode);
                        gainNode.connect(pannerNode);
                        pannerNode.connect(this.masterGain);

                        // Store panner for cleanup
                        const nodeId = Date.now() + Math.random();
                        this.spatialNodes.set(nodeId, pannerNode);

                        // Clean up after sound finishes
                        source.onended = () => {
                            this.spatialNodes.delete(nodeId);
                        };

                        finalNode = pannerNode;
                    } else {
                        // Non-spatial audio: source -> gain -> master
                        source.connect(gainNode);
                        gainNode.connect(this.masterGain);
                    }

                    // Start playback
                    source.start(this.audioContext.currentTime);

                    console.log(`Playing sound '${soundName}'${position ? ' with spatial positioning' : ''}`);
                    return source;

                } catch (error) {
                    console.error(`Failed to play sound '${soundName}':`, error);
                    return null;
                }
            }

            // Update listener position for spatial audio
            setListenerPosition(position, orientation = null) {
                if (!this.initialized || !this.audioContext || !this.audioContext.listener) {
                    return;
                }

                try {
                    const listener = this.audioContext.listener;

                    // Set listener position
                    if (listener.positionX) {
                        // Modern API
                        listener.positionX.setValueAtTime(position.x, this.audioContext.currentTime);
                        listener.positionY.setValueAtTime(position.y, this.audioContext.currentTime);
                        listener.positionZ.setValueAtTime(position.z, this.audioContext.currentTime);
                    } else {
                        // Legacy API
                        listener.setPosition(position.x, position.y, position.z);
                    }

                    // Set listener orientation if provided
                    if (orientation) {
                        if (listener.forwardX) {
                            // Modern API
                            listener.forwardX.setValueAtTime(orientation.forward.x, this.audioContext.currentTime);
                            listener.forwardY.setValueAtTime(orientation.forward.y, this.audioContext.currentTime);
                            listener.forwardZ.setValueAtTime(orientation.forward.z, this.audioContext.currentTime);
                            listener.upX.setValueAtTime(orientation.up.x, this.audioContext.currentTime);
                            listener.upY.setValueAtTime(orientation.up.y, this.audioContext.currentTime);
                            listener.upZ.setValueAtTime(orientation.up.z, this.audioContext.currentTime);
                        } else {
                            // Legacy API
                            listener.setOrientation(
                                orientation.forward.x, orientation.forward.y, orientation.forward.z,
                                orientation.up.x, orientation.up.y, orientation.up.z
                            );
                        }
                    }

                } catch (error) {
                    console.error('Failed to update listener position:', error);
                }
            }

            // Start background music with level-based intensity
            playBackgroundMusic(level = 1) {
                if (!this.initialized || !this.audioContext) {
                    console.warn('Cannot play background music - audio not initialized');
                    return;
                }

                try {
                    // Stop existing background music
                    this.stopBackgroundMusic();

                    // Create oscillator for background music
                    this.backgroundMusic = this.audioContext.createOscillator();
                    this.backgroundGain = this.audioContext.createGain();

                    // Configure background music
                    const config = this.soundConfig.background;
                    const intensity = Math.pow(config.intensityMultiplier, level - 1);
                    const frequency = config.baseFrequency * intensity;
                    const volume = config.volume * Math.min(intensity, 2.0); // Cap volume increase

                    this.backgroundMusic.type = 'sine';
                    this.backgroundMusic.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

                    // Set volume with fade-in
                    this.backgroundGain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    this.backgroundGain.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 2.0);

                    // Connect and start
                    this.backgroundMusic.connect(this.backgroundGain);
                    this.backgroundGain.connect(this.masterGain);
                    this.backgroundMusic.start(this.audioContext.currentTime);

                    this.currentLevel = level;
                    console.log(`Background music started for level ${level} (frequency: ${frequency.toFixed(1)}Hz)`);

                } catch (error) {
                    console.error('Failed to start background music:', error);
                }
            }

            // Stop background music
            stopBackgroundMusic() {
                if (this.backgroundMusic) {
                    try {
                        // Fade out
                        if (this.backgroundGain) {
                            this.backgroundGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.5);
                        }

                        // Stop after fade
                        setTimeout(() => {
                            if (this.backgroundMusic) {
                                this.backgroundMusic.stop();
                                this.backgroundMusic = null;
                                this.backgroundGain = null;
                            }
                        }, 500);

                        console.log('Background music stopped');
                    } catch (error) {
                        console.error('Error stopping background music:', error);
                        this.backgroundMusic = null;
                        this.backgroundGain = null;
                    }
                }
            }

            // Set master volume
            setMasterVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.setValueAtTime(Math.max(0, Math.min(1, volume)), this.audioContext.currentTime);
                    console.log(`Master volume set to ${volume}`);
                }
            }

            // Check if audio is available and initialized
            isAvailable() {
                return this.initialized && this.audioContext && this.audioContext.state === 'running';
            }

            // Get audio context state for debugging
            getState() {
                return {
                    initialized: this.initialized,
                    contextState: this.audioContext ? this.audioContext.state : 'none',
                    soundsLoaded: this.sounds.size,
                    spatialNodesActive: this.spatialNodes.size,
                    backgroundMusicPlaying: !!this.backgroundMusic
                };
            }

            // Pause audio (for session interruptions)
            pauseAudio() {
                if (this.audioContext && this.audioContext.state === 'running') {
                    try {
                        this.audioContext.suspend();
                        console.log('Audio paused');
                    } catch (error) {
                        console.error('Failed to pause audio:', error);
                    }
                }
            }

            // Resume audio (after session interruptions)
            resumeAudio() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    try {
                        this.audioContext.resume();
                        console.log('Audio resumed');
                    } catch (error) {
                        console.error('Failed to resume audio:', error);
                    }
                }
            }

            // Clean up audio resources
            cleanup() {
                console.log('Cleaning up audio resources...');

                // Stop background music
                this.stopBackgroundMusic();

                // Clear spatial nodes
                this.spatialNodes.clear();

                // Close audio context
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    this.audioContext.close();
                }

                // Reset state
                this.audioContext = null;
                this.sounds.clear();
                this.initialized = false;
                this.masterGain = null;

                console.log('Audio cleanup complete');
            }
        }

        // GameManager class for level progression and difficulty scaling system
        class GameManager {
            constructor(scene, scoreManager, creatureManager, holeManager) {
                this.scene = scene;
                this.scoreManager = scoreManager;
                this.creatureManager = creatureManager;
                this.holeManager = holeManager;

                // Game state
                this.currentLevel = 1;
                this.gameState = 'MENU'; // 'MENU', 'PLAYING', 'PAUSED', 'LEVEL_COMPLETE', 'GAME_COMPLETE'
                this.maxLevel = 4;

                // Level progression thresholds (10/20/30/50 for levels 1-4)
                this.levelTargets = [10, 20, 30, 50];

                // Spawn frequency scaling (2000ms to 600ms linear decrease)
                this.spawnIntervals = [2000, 1500, 1000, 600]; // ms per level

                // Creature unlocking system based on current level
                this.availableCreatures = {
                    1: ['mole'],
                    2: ['mole', 'gopher'],
                    3: ['mole', 'gopher', 'rabbit'],
                    4: ['mole', 'gopher', 'rabbit', 'golden']
                };

                // Spawning control
                this.spawnTimer = null;
                this.maxActiveCreatures = 5;
                this.isSpawning = false;

                // UI elements
                this.levelCompletionScreen = document.getElementById('level-completion-screen');
                this.gameCompleteScreen = document.getElementById('game-complete-screen');
                this.nextLevelButton = document.getElementById('next-level-button');
                this.restartButton = document.getElementById('restart-button');

                // Bind event handlers
                this.handleNextLevel = this.handleNextLevel.bind(this);
                this.handleRestart = this.handleRestart.bind(this);

                // Set up event listeners
                if (this.nextLevelButton) {
                    this.nextLevelButton.addEventListener('click', this.handleNextLevel);
                }
                if (this.restartButton) {
                    this.restartButton.addEventListener('click', this.handleRestart);
                }

                console.log('GameManager initialized with level targets:', this.levelTargets);
                console.log('Spawn intervals per level:', this.spawnIntervals);
            }

            // Initialize game manager and start level 1
            initialize() {
                this.currentLevel = 1;
                this.gameState = 'PLAYING';
                this.isSpawning = false;

                // Initialize score manager
                if (this.scoreManager) {
                    this.scoreManager.initialize();
                    this.scoreManager.updateLevelDisplay(this.currentLevel);
                }

                console.log('GameManager initialized - starting level 1');
                this.startLevel(this.currentLevel);
            }

            // Start a specific level with appropriate difficulty
            startLevel(levelNumber) {
                if (levelNumber < 1 || levelNumber > this.maxLevel) {
                    console.error(`Invalid level number: ${levelNumber}`);
                    return;
                }

                this.currentLevel = levelNumber;
                this.gameState = 'PLAYING';

                // Reset level score but preserve total score
                if (this.scoreManager) {
                    this.scoreManager.resetLevelScore();
                    this.scoreManager.updateLevelDisplay(this.currentLevel);
                }

                // Update difficulty based on level
                this.updateDifficulty();

                // Start creature spawning
                this.startSpawning();

                // Start background music for this level
                if (gameState.audioManager && gameState.audioManager.isAvailable()) {
                    gameState.audioManager.playBackgroundMusic(levelNumber);
                }

                console.log(`Level ${levelNumber} started with difficulty:`, {
                    spawnInterval: this.spawnIntervals[levelNumber - 1],
                    availableCreatures: this.availableCreatures[levelNumber],
                    target: this.levelTargets[levelNumber - 1]
                });
            }

            // Update difficulty scaling based on current level
            updateDifficulty() {
                // Spawn frequency scaling (linear decrease from 2000ms to 600ms)
                const currentSpawnInterval = this.spawnIntervals[this.currentLevel - 1];

                // Stop current spawning
                this.stopSpawning();

                // Update spawn interval for new difficulty
                this.currentSpawnInterval = currentSpawnInterval;

                console.log(`Difficulty updated for level ${this.currentLevel}: spawn interval ${currentSpawnInterval}ms`);
            }

            // Start creature spawning with current difficulty and enhanced timing
            startSpawning() {
                if (this.isSpawning) {
                    console.warn('Spawning already active');
                    return;
                }

                this.isSpawning = true;
                const baseInterval = this.currentSpawnInterval || this.spawnIntervals[this.currentLevel - 1];

                // Initialize spawning state
                this.spawningState = {
                    baseInterval: baseInterval,
                    nextSpawnTime: performance.now() + baseInterval,
                    spawnCount: 0,
                    lastSpawnTime: 0,
                    intervalVariation: 0.2 // Â±20% variation for natural timing
                };

                // Use more precise timing with requestAnimationFrame instead of setInterval
                this.startPreciseSpawning();

                console.log(`Enhanced creature spawning started with ${baseInterval}ms base interval (Â±${this.spawningState.intervalVariation * 100}% variation)`);
            }

            // Start precise spawning using requestAnimationFrame for better timing accuracy
            startPreciseSpawning() {
                const spawnLoop = () => {
                    if (!this.isSpawning) {
                        return;
                    }

                    const currentTime = performance.now();

                    // Check if it's time to spawn
                    if (currentTime >= this.spawningState.nextSpawnTime) {
                        this.spawnCreature();

                        // Calculate next spawn time with variation
                        const variation = (Math.random() - 0.5) * 2 * this.spawningState.intervalVariation;
                        const nextInterval = this.spawningState.baseInterval * (1 + variation);

                        this.spawningState.nextSpawnTime = currentTime + nextInterval;
                        this.spawningState.spawnCount++;
                        this.spawningState.lastSpawnTime = currentTime;
                    }

                    // Continue the loop
                    this.spawnAnimationFrame = requestAnimationFrame(spawnLoop);
                };

                // Start the loop
                this.spawnAnimationFrame = requestAnimationFrame(spawnLoop);
            }

            // Stop creature spawning
            stopSpawning() {
                if (this.spawnTimer) {
                    clearInterval(this.spawnTimer);
                    this.spawnTimer = null;
                }

                if (this.spawnAnimationFrame) {
                    cancelAnimationFrame(this.spawnAnimationFrame);
                    this.spawnAnimationFrame = null;
                }

                this.isSpawning = false;

                // Log spawning statistics
                if (this.spawningStats) {
                    console.log('Creature spawning stopped. Stats:', {
                        totalSpawns: this.spawningStats.totalSpawns,
                        typeDistribution: this.spawningStats.typeSpawns,
                        holeUsage: this.spawningStats.holeUsage
                    });
                }
            }

            // Spawn a creature based on current level's available types with weighted selection
            spawnCreature() {
                if (!this.creatureManager || !this.holeManager) {
                    console.warn('CreatureManager or HoleManager not available for spawning');
                    return;
                }

                // Check if we've reached max active creatures
                if (this.creatureManager.activeCreatures.size >= this.maxActiveCreatures) {
                    console.log('Max active creatures reached, skipping spawn');
                    return;
                }

                // Get available creature types for current level with weighted selection
                const creatureType = this.selectWeightedCreatureType();
                if (!creatureType) {
                    console.warn('No creature type selected for spawning');
                    return;
                }

                // Get available holes with anti-clustering logic
                const holeIndex = this.selectOptimalHole();
                if (holeIndex === -1) {
                    console.log('No suitable holes available for spawning');
                    return;
                }

                // Create creature with enhanced timing
                const creature = this.creatureManager.createCreature(creatureType, holeIndex);
                if (creature) {
                    console.log(`Spawned ${creatureType} at hole ${holeIndex} (${this.creatureManager.activeCreatures.size}/${this.maxActiveCreatures} active)`);

                    // Track spawning statistics for balancing
                    this.updateSpawningStats(creatureType, holeIndex);
                }
            }

            // Select creature type with weighted probability based on level and game balance
            selectWeightedCreatureType() {
                const availableTypes = this.availableCreatures[this.currentLevel] || ['mole'];

                // Define weights for each creature type (higher = more likely to spawn)
                const creatureWeights = {
                    'mole': 40,     // Common, low value
                    'gopher': 30,   // Moderate frequency, medium value
                    'rabbit': 20,   // Less common, higher value
                    'golden': 10    // Rare, highest value
                };

                // Adjust weights based on current level and game state
                const adjustedWeights = this.adjustCreatureWeights(creatureWeights, availableTypes);

                // Calculate total weight
                let totalWeight = 0;
                const weightedTypes = [];

                availableTypes.forEach(type => {
                    const weight = adjustedWeights[type] || 0;
                    totalWeight += weight;
                    weightedTypes.push({ type, weight, cumulativeWeight: totalWeight });
                });

                if (totalWeight === 0) {
                    // Fallback to uniform random selection
                    return availableTypes[Math.floor(Math.random() * availableTypes.length)];
                }

                // Select based on weighted probability
                const randomValue = Math.random() * totalWeight;

                for (const weightedType of weightedTypes) {
                    if (randomValue <= weightedType.cumulativeWeight) {
                        return weightedType.type;
                    }
                }

                // Fallback (should not reach here)
                return availableTypes[0];
            }

            // Adjust creature weights based on game state and level
            adjustCreatureWeights(baseWeights, availableTypes) {
                const adjustedWeights = { ...baseWeights };

                // Increase rare creature spawn rate at higher levels
                if (this.currentLevel >= 3) {
                    adjustedWeights.rabbit = (adjustedWeights.rabbit || 0) * 1.5;
                }
                if (this.currentLevel >= 4) {
                    adjustedWeights.golden = (adjustedWeights.golden || 0) * 2.0;
                }

                // Balance based on current active creatures
                const activeTypes = {};
                for (const creature of this.creatureManager.activeCreatures.values()) {
                    activeTypes[creature.type] = (activeTypes[creature.type] || 0) + 1;
                }

                // Reduce weight for over-represented types
                Object.keys(activeTypes).forEach(type => {
                    if (activeTypes[type] >= 2) {
                        adjustedWeights[type] = (adjustedWeights[type] || 0) * 0.5;
                    }
                });

                // Filter to only available types
                const filteredWeights = {};
                availableTypes.forEach(type => {
                    filteredWeights[type] = adjustedWeights[type] || 0;
                });

                return filteredWeights;
            }

            // Select optimal hole to prevent clustering and ensure good distribution
            selectOptimalHole() {
                const availableHoles = this.holeManager.getAvailableHoles();
                if (availableHoles.length === 0) {
                    return -1;
                }

                // If only one hole available, use it
                if (availableHoles.length === 1) {
                    return availableHoles[0];
                }

                // Calculate scores for each available hole based on anti-clustering logic
                const holeScores = availableHoles.map(holeIndex => {
                    let score = 100; // Base score

                    // Reduce score based on nearby occupied holes (3x3 grid)
                    const holePosition = this.getHoleGridPosition(holeIndex);

                    for (const creature of this.creatureManager.activeCreatures.values()) {
                        const creatureHolePos = this.getHoleGridPosition(creature.holeIndex);
                        const distance = this.calculateGridDistance(holePosition, creatureHolePos);

                        // Penalize holes close to active creatures
                        if (distance === 1) {
                            score -= 30; // Adjacent holes
                        } else if (distance === Math.sqrt(2)) {
                            score -= 20; // Diagonal holes
                        } else if (distance === 2) {
                            score -= 10; // Two holes away
                        }
                    }

                    // Bonus for holes that haven't been used recently
                    const hole = this.holeManager.getHole(holeIndex);
                    const timeSinceLastUse = performance.now() - (hole.lastSpawnTime || 0);
                    if (timeSinceLastUse > 5000) { // 5 seconds
                        score += 20;
                    }

                    // Small random factor to prevent predictability
                    score += Math.random() * 10;

                    return { holeIndex, score };
                });

                // Sort by score (highest first) and select from top candidates
                holeScores.sort((a, b) => b.score - a.score);

                // Select from top 3 candidates to maintain some randomness
                const topCandidates = holeScores.slice(0, Math.min(3, holeScores.length));
                const selectedCandidate = topCandidates[Math.floor(Math.random() * topCandidates.length)];

                return selectedCandidate.holeIndex;
            }

            // Get hole position in 3x3 grid (0-8 -> {x, y})
            getHoleGridPosition(holeIndex) {
                return {
                    x: holeIndex % 3,
                    y: Math.floor(holeIndex / 3)
                };
            }

            // Calculate distance between two grid positions
            calculateGridDistance(pos1, pos2) {
                const dx = pos1.x - pos2.x;
                const dy = pos1.y - pos2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Update spawning statistics for balancing
            updateSpawningStats(creatureType, holeIndex) {
                if (!this.spawningStats) {
                    this.spawningStats = {
                        totalSpawns: 0,
                        typeSpawns: {},
                        holeUsage: {},
                        lastSpawnTime: performance.now()
                    };
                }

                this.spawningStats.totalSpawns++;
                this.spawningStats.typeSpawns[creatureType] = (this.spawningStats.typeSpawns[creatureType] || 0) + 1;
                this.spawningStats.holeUsage[holeIndex] = (this.spawningStats.holeUsage[holeIndex] || 0) + 1;
                this.spawningStats.lastSpawnTime = performance.now();
            }

            // Update game state each frame
            update() {
                if (this.gameState !== 'PLAYING') {
                    return;
                }

                // Check for level completion
                if (this.scoreManager && this.scoreManager.checkLevelCompletion(this.currentLevel)) {
                    this.completeLevel();
                }
            }

            // Handle level completion
            completeLevel() {
                console.log(`Level ${this.currentLevel} completed!`);

                // Stop spawning
                this.stopSpawning();

                // Update game state
                this.gameState = 'LEVEL_COMPLETE';

                // Check if this was the final level
                if (this.currentLevel >= this.maxLevel) {
                    this.completeGame();
                } else {
                    this.showLevelCompletionScreen();
                }
            }

            // Show level completion screen with statistics
            showLevelCompletionScreen() {
                if (!this.levelCompletionScreen || !this.scoreManager) {
                    console.error('Level completion screen or score manager not available');
                    return;
                }

                // Get completion data
                const completionData = this.scoreManager.createLevelCompletionData(this.currentLevel);

                // Update UI elements
                document.getElementById('completed-level').textContent = completionData.level;
                document.getElementById('completed-level-score').textContent = completionData.levelScore;
                document.getElementById('completed-total-score').textContent = completionData.totalScore;
                document.getElementById('completed-time').textContent = completionData.timeElapsed;

                // Show screen
                this.levelCompletionScreen.style.display = 'flex';

                console.log('Level completion screen displayed:', completionData);
            }

            // Handle next level button click
            handleNextLevel() {
                // Hide completion screen
                if (this.levelCompletionScreen) {
                    this.levelCompletionScreen.style.display = 'none';
                }

                // Advance to next level
                const nextLevel = this.currentLevel + 1;
                if (nextLevel <= this.maxLevel) {
                    this.startLevel(nextLevel);
                } else {
                    this.completeGame();
                }
            }

            // Complete the entire game
            completeGame() {
                console.log('Game completed!');

                // Stop spawning
                this.stopSpawning();

                // Update game state
                this.gameState = 'GAME_COMPLETE';

                // Show game completion screen
                this.showGameCompleteScreen();
            }

            // Show game complete screen with final statistics
            showGameCompleteScreen() {
                if (!this.gameCompleteScreen || !this.scoreManager) {
                    console.error('Game complete screen or score manager not available');
                    return;
                }

                // Hide level completion screen if visible
                if (this.levelCompletionScreen) {
                    this.levelCompletionScreen.style.display = 'none';
                }

                // Get final scores
                const scores = this.scoreManager.getScores();
                const minutes = Math.floor(scores.elapsedTime / 60000);
                const seconds = Math.floor((scores.elapsedTime % 60000) / 1000);
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                // Update UI elements
                document.getElementById('final-total-score').textContent = scores.totalScore;
                document.getElementById('final-time').textContent = timeString;

                // Show screen
                this.gameCompleteScreen.style.display = 'flex';

                console.log('Game complete screen displayed:', {
                    finalScore: scores.totalScore,
                    totalTime: timeString
                });
            }

            // Handle restart button click
            handleRestart() {
                console.log('Restarting game...');

                // Hide completion screens
                if (this.levelCompletionScreen) {
                    this.levelCompletionScreen.style.display = 'none';
                }
                if (this.gameCompleteScreen) {
                    this.gameCompleteScreen.style.display = 'none';
                }

                // Reset all game state
                this.reset();

                // Restart from level 1
                this.initialize();
            }

            // Pause the game
            pauseGame() {
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.stopSpawning();
                    console.log('Game paused');
                }
            }

            // Resume the game
            resumeGame() {
                if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.startSpawning();
                    console.log('Game resumed');
                }
            }

            // Get current level information
            getCurrentLevelInfo() {
                return {
                    level: this.currentLevel,
                    target: this.levelTargets[this.currentLevel - 1],
                    spawnInterval: this.spawnIntervals[this.currentLevel - 1],
                    availableCreatures: this.availableCreatures[this.currentLevel],
                    gameState: this.gameState
                };
            }

            // Get available creature types for current level
            getAvailableCreatureTypes() {
                return this.availableCreatures[this.currentLevel] || ['mole'];
            }

            // Check if a creature type is unlocked for current level
            isCreatureUnlocked(creatureType) {
                const available = this.availableCreatures[this.currentLevel] || [];
                return available.includes(creatureType);
            }

            // Reset game manager state
            reset() {
                this.stopSpawning();
                this.currentLevel = 1;
                this.gameState = 'MENU';

                // Reset score manager
                if (this.scoreManager) {
                    this.scoreManager.reset();
                }

                console.log('GameManager reset');
            }

            // Adjust spawn quality based on performance
            adjustSpawnQuality(qualityLevel) {
                console.log(`Adjusting spawn quality: level=${qualityLevel.toFixed(2)}`);

                // Adjust spawn interval based on quality
                const baseInterval = this.spawnIntervals[this.currentLevel - 1] || 1000;
                const qualityMultiplier = 1 + (1 - qualityLevel); // Lower quality = longer intervals
                this.currentSpawnInterval = Math.floor(baseInterval * qualityMultiplier);

                // Adjust max active creatures based on quality
                const baseMaxCreatures = 5;
                this.maxActiveCreatures = Math.max(1, Math.floor(baseMaxCreatures * qualityLevel));

                console.log(`Spawn interval adjusted to ${this.currentSpawnInterval}ms, max creatures: ${this.maxActiveCreatures}`);
            }

            // Set spawn interval directly (for testing)
            setSpawnInterval(interval) {
                this.currentSpawnInterval = interval;
                console.log(`Spawn interval set to ${interval}ms`);

                // Restart spawning with new interval if currently spawning
                if (this.isSpawning) {
                    this.stopSpawning();
                    this.startSpawning();
                }
            }

            // Clean up resources
            cleanup() {
                this.stopSpawning();

                // Remove event listeners
                if (this.nextLevelButton) {
                    this.nextLevelButton.removeEventListener('click', this.handleNextLevel);
                }
                if (this.restartButton) {
                    this.restartButton.removeEventListener('click', this.handleRestart);
                }

                console.log('GameManager cleanup complete');
            }
        }

        // Particle system for visual effects
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particleSystems = [];
                this.maxSystems = 5; // Pool size for performance
                this.particleCount = 75; // 50-100 particles as specified
                this.particleLifetime = 500; // 500ms as specified

                // Initialize particle system pool
                this.initializePool();

                console.log('ParticleSystem initialized with', this.maxSystems, 'pooled systems');
            }

            // Initialize particle system pool for performance optimization
            initializePool() {
                for (let i = 0; i < this.maxSystems; i++) {
                    const system = this.createParticleSystem();
                    system.inUse = false;
                    system.startTime = 0;
                    this.particleSystems.push(system);
                }
                console.log('Particle system pool initialized with', this.maxSystems, 'systems');
            }

            // Create a single particle system
            createParticleSystem() {
                const geometry = new THREE.BufferGeometry();

                // Create arrays for particle attributes
                const positions = new Float32Array(this.particleCount * 3);
                const velocities = new Float32Array(this.particleCount * 3);
                const colors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                const lifetimes = new Float32Array(this.particleCount);

                // Initialize particle data
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;

                    // Random positions (will be set when emitted)
                    positions[i3] = 0;
                    positions[i3 + 1] = 0;
                    positions[i3 + 2] = 0;

                    // Random velocities in all directions
                    const speed = 0.5 + Math.random() * 1.5; // Random speed
                    const theta = Math.random() * Math.PI * 2; // Random angle
                    const phi = Math.random() * Math.PI; // Random elevation

                    velocities[i3] = Math.sin(phi) * Math.cos(theta) * speed;
                    velocities[i3 + 1] = Math.cos(phi) * speed + 0.5; // Slight upward bias
                    velocities[i3 + 2] = Math.sin(phi) * Math.sin(theta) * speed;

                    // Multi-colored particles (red, green, blue, yellow, orange, purple)
                    const colorIndex = Math.floor(Math.random() * 6);
                    switch (colorIndex) {
                        case 0: // Red
                            colors[i3] = 1.0; colors[i3 + 1] = 0.2; colors[i3 + 2] = 0.2;
                            break;
                        case 1: // Green
                            colors[i3] = 0.2; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.2;
                            break;
                        case 2: // Blue
                            colors[i3] = 0.2; colors[i3 + 1] = 0.2; colors[i3 + 2] = 1.0;
                            break;
                        case 3: // Yellow
                            colors[i3] = 1.0; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.2;
                            break;
                        case 4: // Orange
                            colors[i3] = 1.0; colors[i3 + 1] = 0.5; colors[i3 + 2] = 0.0;
                            break;
                        case 5: // Purple
                            colors[i3] = 0.8; colors[i3 + 1] = 0.2; colors[i3 + 2] = 1.0;
                            break;
                    }

                    // Random sizes
                    sizes[i] = 0.02 + Math.random() * 0.03;

                    // Lifetime tracking
                    lifetimes[i] = 0;
                }

                // Set geometry attributes
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));

                // Create material
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending
                });

                // Create points mesh
                const points = new THREE.Points(geometry, material);
                points.visible = false; // Hidden by default

                return {
                    points: points,
                    geometry: geometry,
                    material: material,
                    positions: positions,
                    velocities: velocities,
                    colors: colors,
                    sizes: sizes,
                    lifetimes: lifetimes,
                    inUse: false,
                    startTime: 0
                };
            }

            // Emit explosion particles at specified position
            emitExplosion(position) {
                const system = this.getAvailableSystem();
                if (!system) {
                    console.warn('No available particle systems for explosion');
                    return null;
                }

                console.log('Emitting explosion particles at position:', position);

                // Set system as in use
                system.inUse = true;
                system.startTime = performance.now();

                // Reset all particles to the explosion position
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;

                    // Set initial position with slight random offset
                    system.positions[i3] = position.x + (Math.random() - 0.5) * 0.1;
                    system.positions[i3 + 1] = position.y + (Math.random() - 0.5) * 0.1;
                    system.positions[i3 + 2] = position.z + (Math.random() - 0.5) * 0.1;

                    // Reset lifetime
                    system.lifetimes[i] = 0;
                }

                // Update geometry
                system.geometry.attributes.position.needsUpdate = true;
                system.geometry.attributes.lifetime.needsUpdate = true;

                // Make visible and add to scene
                system.points.visible = true;
                if (!system.points.parent) {
                    this.scene.add(system.points);
                }

                return system;
            }

            // Get an available particle system from the pool
            getAvailableSystem() {
                for (let system of this.particleSystems) {
                    if (!system.inUse) {
                        return system;
                    }
                }
                return null; // All systems in use
            }

            // Update all active particle systems
            update(deltaTime) {
                const currentTime = performance.now();

                for (let system of this.particleSystems) {
                    if (!system.inUse) continue;

                    const elapsed = currentTime - system.startTime;
                    const progress = elapsed / this.particleLifetime;

                    if (progress >= 1.0) {
                        // System lifetime expired
                        this.stopSystem(system);
                        continue;
                    }

                    // Update particles
                    this.updateSystemParticles(system, deltaTime, progress);
                }
            }

            // Update particles in a system
            updateSystemParticles(system, deltaTime, progress) {
                let needsUpdate = false;

                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;

                    // Update position based on velocity
                    system.positions[i3] += system.velocities[i3] * deltaTime;
                    system.positions[i3 + 1] += system.velocities[i3 + 1] * deltaTime;
                    system.positions[i3 + 2] += system.velocities[i3 + 2] * deltaTime;

                    // Apply gravity
                    system.velocities[i3 + 1] -= 0.5 * deltaTime;

                    // Update lifetime
                    system.lifetimes[i] = progress;

                    needsUpdate = true;
                }

                // Update material opacity based on progress
                system.material.opacity = 1.0 - progress;

                if (needsUpdate) {
                    system.geometry.attributes.position.needsUpdate = true;
                    system.geometry.attributes.lifetime.needsUpdate = true;
                }
            }

            // Stop a particle system and return it to pool
            stopSystem(system) {
                system.inUse = false;
                system.startTime = 0;
                system.points.visible = false;

                // Reset material opacity
                system.material.opacity = 1.0;

                console.log('Particle system returned to pool');
            }

            // Clean up all particle systems
            cleanup() {
                for (let system of this.particleSystems) {
                    if (system.points.parent) {
                        this.scene.remove(system.points);
                    }
                    system.geometry.dispose();
                    system.material.dispose();
                }
                this.particleSystems = [];
                console.log('ParticleSystem cleanup complete');
            }

            // Adjust quality based on performance
            adjustQuality(qualityLevel, particleCount) {
                console.log(`Adjusting particle quality: level=${qualityLevel.toFixed(2)}, particles=${particleCount}`);

                // Update particle count for new systems
                this.particleCount = Math.max(10, particleCount); // Minimum 10 particles

                // Adjust existing systems
                this.particleSystems.forEach(system => {
                    if (system.material) {
                        // Adjust opacity based on quality
                        system.material.opacity = Math.max(0.3, qualityLevel);

                        // Adjust size based on quality
                        system.material.size = Math.max(0.02, 0.05 * qualityLevel);
                    }
                });

                // If quality is very low, reduce active systems
                if (qualityLevel < 0.5) {
                    const maxActiveSystems = Math.max(1, Math.floor(this.maxSystems * qualityLevel * 2));
                    let activeSystems = 0;

                    this.particleSystems.forEach(system => {
                        if (system.inUse && activeSystems >= maxActiveSystems) {
                            this.stopSystem(system);
                        }
                        if (system.inUse) activeSystems++;
                    });
                }
            }

            // Get system statistics for debugging
            getStats() {
                const inUse = this.particleSystems.filter(s => s.inUse).length;
                const available = this.particleSystems.length - inUse;

                return {
                    totalSystems: this.particleSystems.length,
                    inUse: inUse,
                    available: available,
                    particlesPerSystem: this.particleCount
                };
            }
        }

        // Scene management system
        class SceneManager {
            constructor(scene) {
                this.scene = scene;
                this.gameObjects = new Map();
                this.lightingSetup = null;
                this.coordinateSystem = null;

                console.log('Scene manager initialized');
            }

            // Set up comprehensive lighting for AR environment
            setupLighting() {
                console.log('Setting up AR-optimized lighting...');

                // Remove any existing lights
                if (this.lightingSetup) {
                    this.clearLighting();
                }

                this.lightingSetup = new THREE.Group();
                this.lightingSetup.name = 'lighting-setup';

                // Ambient light for overall scene illumination
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                ambientLight.name = 'ambient-light';
                this.lightingSetup.add(ambientLight);

                // Main directional light (simulating sun/room lighting)
                const mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainDirectionalLight.position.set(5, 10, 5);
                mainDirectionalLight.castShadow = false; // Disable shadows for performance
                mainDirectionalLight.name = 'main-directional-light';
                this.lightingSetup.add(mainDirectionalLight);

                // Secondary directional light for fill lighting
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight.position.set(-5, 5, -5);
                fillLight.name = 'fill-light';
                this.lightingSetup.add(fillLight);

                // Hemisphere light for natural ambient lighting
                const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.2);
                hemisphereLight.name = 'hemisphere-light';
                this.lightingSetup.add(hemisphereLight);

                this.scene.add(this.lightingSetup);
                console.log('AR lighting setup complete');
            }

            // Set up coordinate system for AR space
            setupCoordinateSystem() {
                console.log('Setting up AR coordinate system...');

                // Create coordinate system helper (for debugging)
                this.coordinateSystem = new THREE.Group();
                this.coordinateSystem.name = 'coordinate-system';

                // Create axis helpers (smaller scale for AR)
                const axisHelper = new THREE.AxesHelper(0.5);
                axisHelper.name = 'axis-helper';
                this.coordinateSystem.add(axisHelper);

                // Create grid helper for surface reference (optional, can be hidden)
                const gridHelper = new THREE.GridHelper(2, 10, 0x888888, 0x444444);
                gridHelper.name = 'grid-helper';
                gridHelper.visible = false; // Hidden by default in AR
                this.coordinateSystem.add(gridHelper);

                this.scene.add(this.coordinateSystem);
                console.log('AR coordinate system established');
            }

            // Add game object to scene with tracking
            addGameObject(id, object, category = 'general') {
                if (this.gameObjects.has(id)) {
                    console.warn(`Game object with id '${id}' already exists`);
                    return false;
                }

                object.userData = {
                    id: id,
                    category: category,
                    addedAt: Date.now()
                };

                this.gameObjects.set(id, object);
                this.scene.add(object);

                console.log(`Added game object '${id}' (category: ${category})`);
                return true;
            }

            // Remove game object from scene
            removeGameObject(id) {
                const object = this.gameObjects.get(id);
                if (!object) {
                    console.warn(`Game object with id '${id}' not found`);
                    return false;
                }

                this.scene.remove(object);
                this.gameObjects.delete(id);

                // Clean up geometry and materials
                this.disposeObject(object);

                console.log(`Removed game object '${id}'`);
                return true;
            }

            // Get game object by id
            getGameObject(id) {
                return this.gameObjects.get(id);
            }

            // Get all game objects by category
            getGameObjectsByCategory(category) {
                const objects = [];
                for (const [id, object] of this.gameObjects) {
                    if (object.userData.category === category) {
                        objects.push({ id, object });
                    }
                }
                return objects;
            }

            // Clear all game objects
            clearGameObjects() {
                console.log('Clearing all game objects...');

                for (const [id, object] of this.gameObjects) {
                    this.scene.remove(object);
                    this.disposeObject(object);
                }

                this.gameObjects.clear();
                console.log('All game objects cleared');
            }

            // Dispose of Three.js object resources
            disposeObject(object) {
                if (object.geometry) {
                    object.geometry.dispose();
                }

                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }

                // Recursively dispose children
                if (object.children) {
                    object.children.forEach(child => this.disposeObject(child));
                }
            }

            // Clear lighting setup
            clearLighting() {
                if (this.lightingSetup) {
                    this.scene.remove(this.lightingSetup);
                    this.disposeObject(this.lightingSetup);
                    this.lightingSetup = null;
                }
            }

            // Get scene statistics
            getSceneStats() {
                return {
                    totalObjects: this.gameObjects.size,
                    sceneChildren: this.scene.children.length,
                    categories: this.getCategoryStats()
                };
            }

            // Get statistics by category
            getCategoryStats() {
                const stats = {};
                for (const [id, object] of this.gameObjects) {
                    const category = object.userData.category;
                    stats[category] = (stats[category] || 0) + 1;
                }
                return stats;
            }
        }

        // Initialize Three.js with enhanced scene management and performance monitoring
        async function initializeThreeJS() {
            console.log('Initializing Three.js rendering engine...');

            // Create scene
            gameState.scene = new THREE.Scene();
            gameState.scene.name = 'whack-a-mole-ar-scene';

            // Create WebXR-compatible camera
            gameState.camera = new THREE.PerspectiveCamera(
                75, // FOV optimized for AR
                window.innerWidth / window.innerHeight,
                0.1, // Near plane - closer for AR objects
                100   // Far plane - sufficient for room-scale AR
            );
            gameState.camera.name = 'ar-camera';

            // Create WebXR-compatible renderer with optimizations
            gameState.renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance', // Request high-performance GPU
                stencil: false, // Disable stencil buffer for performance
                depth: true
            });

            // Configure renderer for AR
            gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            gameState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            gameState.renderer.xr.enabled = true;
            gameState.renderer.xr.cameraAutoUpdate = true;

            // Enable tone mapping for better visual quality
            gameState.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            gameState.renderer.toneMappingExposure = 1.0;

            // Configure output encoding
            gameState.renderer.outputEncoding = THREE.sRGBEncoding;

            // Add renderer to DOM
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.appendChild(gameState.renderer.domElement);

            // Initialize scene manager
            gameState.sceneManager = new SceneManager(gameState.scene);

            // Set up lighting optimized for AR
            gameState.sceneManager.setupLighting();

            // Set up coordinate system for AR space
            gameState.sceneManager.setupCoordinateSystem();

            // Initialize performance monitor
            gameState.performanceMonitor = new PerformanceMonitor();

            // Initialize particle system for visual effects
            gameState.particleSystem = new ParticleSystem(gameState.scene);

            console.log('Three.js rendering engine initialized successfully');
            console.log('Scene setup:', gameState.sceneManager.getSceneStats());
        }

        // Initialize WebXR using ARManager
        async function initializeWebXR() {
            console.log('Initializing WebXR with ARManager...');

            try {
                // Create ARManager instance
                gameState.arManager = new ARManager(gameState.scene, gameState.renderer);

                // Initialize AR system
                await gameState.arManager.initialize();

                // Store session reference for compatibility
                gameState.arSession = gameState.arManager.xrSession;

                // Start render loop
                startRenderLoop();

                console.log('WebXR with ARManager initialized successfully');

            } catch (error) {
                console.error('WebXR initialization failed:', error);

                // Provide more specific error messages
                let errorMessage = 'Could not start AR session';
                if (error.message.includes('not supported')) {
                    errorMessage = 'AR features not supported on this device';
                } else if (error.message.includes('permission')) {
                    errorMessage = 'AR permissions denied. Please allow camera access.';
                } else if (error.message.includes('hit-test')) {
                    errorMessage = 'Surface detection not available on this device';
                }

                throw new Error(errorMessage);
            }
        }

        // Initialize hole system when surface is detected
        async function initializeHoleSystem() {
            if (gameState.holeManager) {
                console.log('Hole system already initialized');
                return;
            }

            console.log('Initializing hole system on detected surface...');

            try {
                const gameSpace = gameState.arManager.getGameSpace();
                if (!gameSpace) {
                    throw new Error('Game space not available for hole system');
                }

                // Create hole manager
                gameState.holeManager = new HoleManager(gameState.scene, gameSpace);

                // Initialize the hole system
                await gameState.holeManager.initializeHoleSystem();

                console.log('Hole system initialized successfully');
                console.log('Hole system stats:', gameState.holeManager.getHoleStats());

                // Initialize creature manager
                gameState.creatureManager = new CreatureManager(gameState.scene, gameState.holeManager);
                console.log('Creature manager initialized successfully');

                // Initialize input manager
                gameState.inputManager = new InputManager(
                    gameState.scene,
                    gameState.renderer,
                    gameState.arManager,
                    gameState.creatureManager
                );
                gameState.inputManager.initialize(gameState.camera);
                console.log('Input manager initialized successfully');

                // Initialize score manager
                gameState.scoreManager = new ScoreManager(gameState.scene);
                gameState.scoreManager.initialize();
                console.log('Score manager initialized successfully');

                // Initialize audio manager
                gameState.audioManager = new AudioManager();
                await gameState.audioManager.initializeAudioContext();
                console.log('Audio manager initialized successfully');

                // Initialize game manager for level progression and difficulty scaling
                gameState.gameManager = new GameManager(
                    gameState.scene,
                    gameState.scoreManager,
                    gameState.creatureManager,
                    gameState.holeManager
                );
                gameState.gameManager.initialize();
                console.log('Game manager initialized successfully');

                // Set up particle system event listeners for creature hits
                setupParticleSystemEvents();

            } catch (error) {
                console.error('Failed to initialize hole system:', error);
                showError('Failed to set up game surface: ' + error.message);
            }
        }

        // Set up particle system event listeners for creature hits
        function setupParticleSystemEvents() {
            console.log('Setting up particle system event listeners...');

            // Listen for creature hit events to trigger particle explosions
            document.addEventListener('creatureHit', (event) => {
                const hitData = event.detail;
                console.log('Particle system received creature hit event:', hitData);

                if (gameState.particleSystem && hitData.position) {
                    // Emit explosion particles at hit position
                    gameState.particleSystem.emitExplosion(hitData.position);
                    console.log('Explosion particles emitted at position:', hitData.position);
                }

                // Also trigger score manager for visual feedback
                if (gameState.scoreManager) {
                    gameState.scoreManager.addScore(hitData.creatureType, hitData.position);
                }

                // Play hit sound effect with spatial positioning
                if (gameState.audioManager) {
                    gameState.audioManager.playSound('hit', hitData.position, 1.0);
                }
            });

            // Listen for creature miss events (when creatures retreat without being hit)
            document.addEventListener('creatureMiss', (event) => {
                const missData = event.detail;
                console.log('Particle system received creature miss event:', missData);

                if (gameState.scoreManager && missData.position) {
                    gameState.scoreManager.subtractScore(missData.creatureType, missData.position);
                }

                // Play miss sound effect with spatial positioning
                if (gameState.audioManager) {
                    gameState.audioManager.playSound('miss', missData.position, 0.8);
                }
            });

            console.log('Particle system event listeners set up successfully');
        }

        // Start the render loop for AR with performance monitoring
        function startRenderLoop() {
            console.log('Starting AR render loop with performance monitoring...');

            gameState.renderer.setAnimationLoop((timestamp, frame) => {
                // Update performance monitoring
                if (gameState.performanceMonitor) {
                    gameState.performanceMonitor.update();
                }

                // Handle surface detection and hole system initialization
                if (gameState.arManager && frame) {
                    const surfaceDetected = gameState.arManager.detectPlayingSurface(frame);

                    // Initialize hole system when surface is first detected
                    if (surfaceDetected && gameState.arManager.isReady() && !gameState.holeManager) {
                        initializeHoleSystem();
                    }
                }

                // Update hole system animations
                if (gameState.holeManager && gameState.holeManager.isReady()) {
                    const deltaTime = gameState.performanceMonitor ? gameState.performanceMonitor.frameTime / 1000 : 0.016;
                    gameState.holeManager.update(deltaTime);
                }

                // Update creature manager
                if (gameState.creatureManager) {
                    const deltaTime = gameState.performanceMonitor ? gameState.performanceMonitor.frameTime / 1000 : 0.016;
                    gameState.creatureManager.update(deltaTime);
                }

                // Update input manager
                if (gameState.inputManager) {
                    gameState.inputManager.update();
                }

                // Update particle system
                if (gameState.particleSystem) {
                    const deltaTime = gameState.performanceMonitor ? gameState.performanceMonitor.frameTime / 1000 : 0.016;
                    gameState.particleSystem.update(deltaTime);
                }

                // Update score manager display (timer and scores)
                if (gameState.scoreManager) {
                    gameState.scoreManager.updateScoreDisplay();
                }

                // Update game manager for level progression
                if (gameState.gameManager) {
                    gameState.gameManager.update();
                }

                // Update spatial audio listener position
                if (gameState.audioManager && gameState.audioManager.isAvailable() && gameState.camera) {
                    const cameraPosition = gameState.camera.position;
                    const cameraQuaternion = gameState.camera.quaternion;

                    // Calculate forward and up vectors from camera quaternion
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cameraQuaternion);
                    const up = new THREE.Vector3(0, 1, 0).applyQuaternion(cameraQuaternion);

                    gameState.audioManager.setListenerPosition(cameraPosition, {
                        forward: forward,
                        up: up
                    });
                }

                // Render the scene
                gameState.renderer.render(gameState.scene, gameState.camera);

                // Log performance metrics periodically (every 5 seconds)
                if (gameState.performanceMonitor &&
                    gameState.performanceMonitor.frameCount % (72 * 5) === 0) {
                    const metrics = gameState.performanceMonitor.getMetrics();
                    console.log('Performance metrics:', {
                        fps: metrics.currentFPS.toFixed(1),
                        avgFPS: metrics.averageFPS.toFixed(1),
                        minFPS: metrics.minFPS.toFixed(1),
                        maxFPS: metrics.maxFPS.toFixed(1)
                    });
                }
            });
        }

        // Stop the render loop
        function stopRenderLoop() {
            console.log('Stopping render loop...');
            gameState.renderer.setAnimationLoop(null);

            // Reset performance monitoring
            if (gameState.performanceMonitor) {
                gameState.performanceMonitor.reset();
            }
        }

        // Clean up Three.js resources
        function cleanupThreeJS() {
            console.log('Cleaning up Three.js resources...');

            // Stop render loop
            stopRenderLoop();

            // Clean up hole system
            if (gameState.holeManager) {
                gameState.holeManager.cleanup();
                gameState.holeManager = null;
            }

            // Clean up scene manager
            if (gameState.sceneManager) {
                gameState.sceneManager.clearGameObjects();
                gameState.sceneManager.clearLighting();
            }

            // Clean up renderer
            if (gameState.renderer) {
                gameState.renderer.dispose();

                // Remove canvas from DOM
                const canvas = gameState.renderer.domElement;
                if (canvas && canvas.parentNode) {
                    canvas.parentNode.removeChild(canvas);
                }
            }

            // Clean up scene
            if (gameState.scene) {
                // Dispose of all remaining objects in scene
                while (gameState.scene.children.length > 0) {
                    const child = gameState.scene.children[0];
                    gameState.scene.remove(child);

                    if (gameState.sceneManager) {
                        gameState.sceneManager.disposeObject(child);
                    }
                }
            }

            // Clean up input manager
            if (gameState.inputManager) {
                gameState.inputManager.cleanup();
                gameState.inputManager = null;
            }

            // Clean up creature manager
            if (gameState.creatureManager) {
                gameState.creatureManager.cleanup();
                gameState.creatureManager = null;
            }

            // Clean up particle system
            if (gameState.particleSystem) {
                gameState.particleSystem.cleanup();
                gameState.particleSystem = null;
            }

            // Clean up score manager
            if (gameState.scoreManager) {
                gameState.scoreManager.cleanup();
                gameState.scoreManager = null;
            }

            // Clean up game manager
            if (gameState.gameManager) {
                gameState.gameManager.cleanup();
                gameState.gameManager = null;
            }

            // Clean up audio manager
            if (gameState.audioManager) {
                gameState.audioManager.cleanup();
                gameState.audioManager = null;
            }

            // Reset references
            gameState.scene = null;
            gameState.camera = null;
            gameState.renderer = null;
            gameState.sceneManager = null;
            gameState.performanceMonitor = null;
            gameState.holeManager = null;
            gameState.particleSystem = null;
            gameState.scoreManager = null;

            console.log('Three.js cleanup complete');
        }

        // UI Helper Functions
        function showLoadingScreen() {
            document.getElementById('loading-screen').style.display = 'flex';
        }

        function hideLoadingScreen() {
            document.getElementById('loading-screen').style.display = 'none';
        }

        function hideStartScreen() {
            document.getElementById('start-screen').style.display = 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            const errorText = document.getElementById('error-text');
            errorText.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error-message').style.display = 'none';
        }

        // Enhanced error handling functions for session management
        function showRecoveryMessage(message) {
            // Create recovery overlay if it doesn't exist
            let recoveryDiv = document.getElementById('recovery-message');
            if (!recoveryDiv) {
                recoveryDiv = document.createElement('div');
                recoveryDiv.id = 'recovery-message';
                recoveryDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 165, 0, 0.95);
                    color: white;
                    padding: 30px;
                    border-radius: 15px;
                    text-align: center;
                    max-width: 500px;
                    z-index: 3500;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                `;

                recoveryDiv.innerHTML = `
                    <div style="font-size: 1.5em; margin-bottom: 15px;">ðŸ”„ Session Recovery</div>
                    <p id="recovery-text" style="font-size: 1.1em; line-height: 1.4;"></p>
                    <div id="recovery-spinner" style="
                        width: 30px;
                        height: 30px;
                        border: 3px solid rgba(255, 255, 255, 0.3);
                        border-top: 3px solid white;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                        margin: 20px auto 0;
                    "></div>
                `;

                document.body.appendChild(recoveryDiv);
            }

            const recoveryText = document.getElementById('recovery-text');
            recoveryText.textContent = message;
            recoveryDiv.style.display = 'block';
        }

        function updateRecoveryMessage(message) {
            const recoveryText = document.getElementById('recovery-text');
            if (recoveryText) {
                recoveryText.textContent = message;
            }
        }

        function hideRecoveryMessage() {
            const recoveryDiv = document.getElementById('recovery-message');
            if (recoveryDiv) {
                recoveryDiv.style.display = 'none';
            }
        }

        function showPersistentError(message, actionType = 'retry') {
            // Create persistent error overlay
            let persistentErrorDiv = document.getElementById('persistent-error');
            if (!persistentErrorDiv) {
                persistentErrorDiv = document.createElement('div');
                persistentErrorDiv.id = 'persistent-error';
                persistentErrorDiv.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    z-index: 4000;
                    color: white;
                `;

                document.body.appendChild(persistentErrorDiv);
            }

            const actionButton = actionType === 'restart' ?
                '<button onclick="location.reload()" style="padding: 15px 30px; font-size: 1.2em; background: #FF6B6B; color: white; border: none; border-radius: 25px; cursor: pointer; margin-top: 20px;">Restart Game</button>' :
                '<button onclick="location.reload()" style="padding: 15px 30px; font-size: 1.2em; background: #4CAF50; color: white; border: none; border-radius: 25px; cursor: pointer; margin-top: 20px;">Retry</button>';

            persistentErrorDiv.innerHTML = `
                <div style="max-width: 600px; padding: 40px;">
                    <div style="font-size: 3em; margin-bottom: 20px;">âš ï¸</div>
                    <h2 style="font-size: 2em; margin-bottom: 20px; color: #FF6B6B;">Session Error</h2>
                    <p style="font-size: 1.3em; line-height: 1.5; margin-bottom: 30px;">${message}</p>
                    ${actionButton}
                </div>
            `;

            persistentErrorDiv.style.display = 'flex';
        }

        function showCompatibilityError(deviceType, supportLevel) {
            let compatibilityDiv = document.getElementById('compatibility-error');
            if (!compatibilityDiv) {
                compatibilityDiv = document.createElement('div');
                compatibilityDiv.id = 'compatibility-error';
                compatibilityDiv.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    z-index: 4000;
                    color: white;
                `;

                document.body.appendChild(compatibilityDiv);
            }

            let message = '';
            let icon = 'ðŸ“±';
            let actionButton = '';

            switch (deviceType) {
                case 'desktop':
                    icon = 'ðŸ’»';
                    message = `
                        <h2>Desktop Detected</h2>
                        <p>This AR game is optimized for Meta Quest headsets.</p>
                        <p>Desktop fallback mode is not yet available.</p>
                        <p>Please use a Meta Quest 2 or Quest 3 for the full experience.</p>
                    `;
                    actionButton = '<button onclick="location.reload()" style="padding: 15px 30px; font-size: 1.2em; background: #666; color: white; border: none; border-radius: 25px; cursor: pointer; margin-top: 20px;">Check Again</button>';
                    break;
                case 'mobile':
                    icon = 'ðŸ“±';
                    message = `
                        <h2>Mobile Device Detected</h2>
                        <p>This game requires WebXR AR support.</p>
                        <p>Mobile AR support is limited and not recommended.</p>
                        <p>Please use a Meta Quest headset for the best experience.</p>
                    `;
                    actionButton = '<button onclick="location.reload()" style="padding: 15px 30px; font-size: 1.2em; background: #666; color: white; border: none; border-radius: 25px; cursor: pointer; margin-top: 20px;">Check Again</button>';
                    break;
                default:
                    icon = 'âŒ';
                    message = `
                        <h2>WebXR Not Supported</h2>
                        <p>Your device or browser doesn't support WebXR AR.</p>
                        <p>This game requires a compatible AR device like Meta Quest.</p>
                        <p>Please try using a supported device and browser.</p>
                    `;
                    actionButton = '<button onclick="location.reload()" style="padding: 15px 30px; font-size: 1.2em; background: #666; color: white; border: none; border-radius: 25px; cursor: pointer; margin-top: 20px;">Check Again</button>';
            }

            compatibilityDiv.innerHTML = `
                <div style="max-width: 600px; padding: 40px;">
                    <div style="font-size: 4em; margin-bottom: 20px;">${icon}</div>
                    ${message}
                    ${actionButton}
                </div>
            `;

            compatibilityDiv.style.display = 'flex';
        }

        // Handle page visibility changes
        function handleVisibilityChange() {
            if (document.hidden && gameState.gameStarted && gameState.gameManager) {
                console.log('Page hidden - pausing game');
                gameState.gameManager.pauseGame();

                // Also pause audio if available
                if (gameState.audioManager) {
                    gameState.audioManager.pauseAudio();
                }
            } else if (!document.hidden && gameState.gameStarted && gameState.gameManager) {
                console.log('Page visible - resuming game');
                gameState.gameManager.resumeGame();

                // Resume audio if available
                if (gameState.audioManager) {
                    gameState.audioManager.resumeAudio();
                }
            }
        }

        // Handle window focus events
        function handleWindowFocus() {
            if (gameState.gameStarted && gameState.gameManager && gameState.gameManager.gameState === 'PAUSED') {
                console.log('Window focused - resuming game');
                gameState.gameManager.resumeGame();

                // Resume audio if available
                if (gameState.audioManager) {
                    gameState.audioManager.resumeAudio();
                }
            }
        }

        // Handle window blur events
        function handleWindowBlur() {
            if (gameState.gameStarted && gameState.gameManager && gameState.gameManager.gameState === 'PLAYING') {
                console.log('Window blurred - pausing game');
                gameState.gameManager.pauseGame();

                // Pause audio if available
                if (gameState.audioManager) {
                    gameState.audioManager.pauseAudio();
                }
            }
        }

        // Handle before unload for cleanup
        function handleBeforeUnload(event) {
            if (gameState.gameStarted) {
                console.log('Page unloading - cleaning up resources');

                // Clean up AR session
                if (gameState.arManager) {
                    gameState.arManager.cleanup();
                }

                // Clean up audio
                if (gameState.audioManager) {
                    gameState.audioManager.cleanup();
                }

                // Note: We don't prevent unload, just clean up
            }
        }

        // Handle window resize
        function handleResize() {
            if (gameState.camera && gameState.renderer) {
                gameState.camera.aspect = window.innerWidth / window.innerHeight;
                gameState.camera.updateProjectionMatrix();
                gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Hole management system for game surface setup
        class HoleManager {
            constructor(scene, gameSpace) {
                this.scene = scene;
                this.gameSpace = gameSpace;
                this.holes = [];
                this.holeGroup = null;
                this.gridSize = 3; // 3x3 grid
                this.holeSpacing = 0.4; // Distance between holes in meters
                this.holeRadius = 0.08; // Hole radius
                this.holeDepth = 0.05; // Hole depth for visual effect
                this.isInitialized = false;

                console.log('HoleManager initialized');
            }

            // Generate 9 hole positions in a 3x3 grid on detected surface
            generateHolePositions() {
                console.log('Generating hole positions in 3x3 grid...');

                const positions = [];
                const offset = (this.gridSize - 1) * this.holeSpacing / 2; // Center the grid

                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = col * this.holeSpacing - offset;
                        const z = row * this.holeSpacing - offset;
                        const y = 0; // On the surface

                        positions.push({
                            index: row * this.gridSize + col,
                            position: new THREE.Vector3(x, y, z),
                            row: row,
                            col: col
                        });
                    }
                }

                console.log(`Generated ${positions.length} hole positions`);
                return positions;
            }

            // Create hole geometry and materials with opening/closing animations
            createHoleGeometry() {
                console.log('Creating hole geometry and materials...');

                // Create hole geometry - cylinder for the hole opening
                const holeGeometry = new THREE.CylinderGeometry(
                    this.holeRadius, // Top radius
                    this.holeRadius * 0.8, // Bottom radius (slightly smaller)
                    this.holeDepth, // Height/depth
                    16, // Radial segments (optimized for performance)
                    1, // Height segments
                    false, // Open ended
                    0, // Theta start
                    Math.PI * 2 // Theta length (full circle)
                );

                // Create hole material with dark interior
                const holeMaterial = new THREE.MeshLambertMaterial({
                    color: 0x2c1810, // Dark brown for hole interior
                    transparent: false,
                    side: THREE.DoubleSide
                });

                // Create rim geometry for hole edge
                const rimGeometry = new THREE.RingGeometry(
                    this.holeRadius, // Inner radius
                    this.holeRadius + 0.02, // Outer radius
                    16 // Segments
                );
                rimGeometry.rotateX(-Math.PI / 2); // Rotate to lie flat

                // Create rim material
                const rimMaterial = new THREE.MeshLambertMaterial({
                    color: 0x8B4513, // Saddle brown for rim
                    transparent: false
                });

                return {
                    holeGeometry,
                    holeMaterial,
                    rimGeometry,
                    rimMaterial
                };
            }

            // Create visual indicators for hole positions on the AR surface
            createHoleVisualIndicators() {
                console.log('Creating visual indicators for hole positions...');

                // Create indicator geometry - subtle ring to show hole positions
                const indicatorGeometry = new THREE.RingGeometry(
                    this.holeRadius + 0.03, // Inner radius
                    this.holeRadius + 0.05, // Outer radius
                    16 // Segments
                );
                indicatorGeometry.rotateX(-Math.PI / 2); // Rotate to lie flat

                // Create indicator material with subtle glow
                const indicatorMaterial = new THREE.MeshLambertMaterial({
                    color: 0x00ff00, // Green color
                    transparent: true,
                    opacity: 0.3,
                    emissive: 0x004400, // Subtle green glow
                    emissiveIntensity: 0.2
                });

                return {
                    indicatorGeometry,
                    indicatorMaterial
                };
            }

            // Initialize the complete hole system
            async initializeHoleSystem() {
                if (!this.gameSpace) {
                    throw new Error('Game space not available for hole system initialization');
                }

                console.log('Initializing hole system on detected surface...');

                try {
                    // Create hole group to contain all hole-related objects
                    this.holeGroup = new THREE.Group();
                    this.holeGroup.name = 'hole-system';

                    // Generate hole positions
                    const holePositions = this.generateHolePositions();

                    // Create geometries and materials
                    const holeAssets = this.createHoleGeometry();
                    const indicatorAssets = this.createHoleVisualIndicators();

                    // Create individual holes
                    for (const holeData of holePositions) {
                        const hole = this.createHole(holeData, holeAssets, indicatorAssets);
                        this.holes.push(hole);
                        this.holeGroup.add(hole.group);
                    }

                    // Add hole group to game space
                    this.gameSpace.add(this.holeGroup);

                    this.isInitialized = true;
                    console.log(`Hole system initialized with ${this.holes.length} holes`);

                    // Animate holes opening
                    await this.animateHolesOpening();

                } catch (error) {
                    console.error('Failed to initialize hole system:', error);
                    throw error;
                }
            }

            // Create individual hole with all components
            createHole(holeData, holeAssets, indicatorAssets) {
                const holeGroup = new THREE.Group();
                holeGroup.name = `hole-${holeData.index}`;
                holeGroup.position.copy(holeData.position);

                // Create hole mesh (the actual hole)
                const holeMesh = new THREE.Mesh(holeAssets.holeGeometry, holeAssets.holeMaterial);
                holeMesh.name = 'hole-mesh';
                holeMesh.position.y = -this.holeDepth / 2; // Position below surface
                holeMesh.castShadow = false;
                holeMesh.receiveShadow = true;

                // Create rim mesh (hole edge)
                const rimMesh = new THREE.Mesh(holeAssets.rimGeometry, holeAssets.rimMaterial);
                rimMesh.name = 'rim-mesh';
                rimMesh.position.y = 0.001; // Slightly above surface to prevent z-fighting
                rimMesh.castShadow = false;
                rimMesh.receiveShadow = true;

                // Create visual indicator
                const indicatorMesh = new THREE.Mesh(indicatorAssets.indicatorGeometry, indicatorAssets.indicatorMaterial);
                indicatorMesh.name = 'indicator-mesh';
                indicatorMesh.position.y = 0.002; // Above rim
                indicatorMesh.visible = true; // Start visible, will animate

                // Add meshes to hole group
                holeGroup.add(holeMesh);
                holeGroup.add(rimMesh);
                holeGroup.add(indicatorMesh);

                // Create hole state object
                const hole = {
                    index: holeData.index,
                    position: holeData.position.clone(),
                    row: holeData.row,
                    col: holeData.col,
                    group: holeGroup,
                    holeMesh: holeMesh,
                    rimMesh: rimMesh,
                    indicatorMesh: indicatorMesh,
                    state: 'CLOSED', // CLOSED, OPENING, OPEN, CLOSING
                    occupied: false,
                    lastSpawnTime: 0,
                    cooldownPeriod: 1000, // 1 second cooldown between spawns
                    animationMixer: null,
                    openScale: 1.0,
                    closedScale: 0.1
                };

                // Set initial scale (closed state)
                hole.group.scale.set(hole.closedScale, hole.closedScale, hole.closedScale);

                return hole;
            }

            // Animate holes opening with staggered timing
            async animateHolesOpening() {
                console.log('Animating holes opening...');

                const animationPromises = [];
                const staggerDelay = 100; // 100ms between each hole opening

                for (let i = 0; i < this.holes.length; i++) {
                    const hole = this.holes[i];
                    const delay = i * staggerDelay;

                    const animationPromise = new Promise((resolve) => {
                        setTimeout(() => {
                            this.animateHoleOpening(hole).then(resolve);
                        }, delay);
                    });

                    animationPromises.push(animationPromise);
                }

                // Wait for all holes to finish opening
                await Promise.all(animationPromises);
                console.log('All holes opened successfully');
            }

            // Animate individual hole opening
            async animateHoleOpening(hole) {
                return new Promise((resolve) => {
                    hole.state = 'OPENING';

                    const startScale = hole.closedScale;
                    const endScale = hole.openScale;
                    const duration = 500; // 500ms animation
                    const startTime = performance.now();

                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Use easeOutBack for bouncy opening effect
                        const easeProgress = this.easeOutBack(progress);
                        const currentScale = startScale + (endScale - startScale) * easeProgress;

                        hole.group.scale.set(currentScale, currentScale, currentScale);

                        // Fade in indicator
                        hole.indicatorMesh.material.opacity = 0.3 * progress;

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            hole.state = 'OPEN';
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

            // Animate individual hole closing
            async animateHoleClosing(hole) {
                return new Promise((resolve) => {
                    hole.state = 'CLOSING';

                    const startScale = hole.openScale;
                    const endScale = hole.closedScale;
                    const duration = 300; // 300ms animation
                    const startTime = performance.now();

                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Use easeInBack for quick closing effect
                        const easeProgress = this.easeInBack(progress);
                        const currentScale = startScale + (endScale - startScale) * easeProgress;

                        hole.group.scale.set(currentScale, currentScale, currentScale);

                        // Fade out indicator
                        hole.indicatorMesh.material.opacity = 0.3 * (1 - progress);

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            hole.state = 'CLOSED';
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

            // Easing functions for smooth animations
            easeOutBack(t) {
                const c1 = 1.7158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }

            easeInBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return c3 * t * t * t - c1 * t * t;
            }

            // Implement hole state management (occupied/available)
            setHoleOccupied(holeIndex, occupied) {
                if (holeIndex < 0 || holeIndex >= this.holes.length) {
                    console.warn(`Invalid hole index: ${holeIndex}`);
                    return false;
                }

                const hole = this.holes[holeIndex];
                const wasOccupied = hole.occupied;
                hole.occupied = occupied;

                // Update visual state
                if (occupied && !wasOccupied) {
                    // Hole became occupied - dim the indicator
                    hole.indicatorMesh.material.opacity = 0.1;
                    hole.indicatorMesh.material.color.setHex(0xff4444); // Red tint
                } else if (!occupied && wasOccupied) {
                    // Hole became available - restore indicator
                    hole.indicatorMesh.material.opacity = 0.3;
                    hole.indicatorMesh.material.color.setHex(0x00ff00); // Green color
                    hole.lastSpawnTime = performance.now();
                }

                console.log(`Hole ${holeIndex} ${occupied ? 'occupied' : 'available'}`);
                return true;
            }

            // Check if hole is available for spawning
            isHoleAvailable(holeIndex) {
                if (holeIndex < 0 || holeIndex >= this.holes.length) {
                    return false;
                }

                const hole = this.holes[holeIndex];
                const currentTime = performance.now();
                const cooldownElapsed = currentTime - hole.lastSpawnTime >= hole.cooldownPeriod;

                return hole.state === 'OPEN' && !hole.occupied && cooldownElapsed;
            }

            // Get available holes for creature spawning
            getAvailableHoles() {
                return this.holes.filter((hole, index) => this.isHoleAvailable(index));
            }

            // Get random available hole
            getRandomAvailableHole() {
                const availableHoles = this.getAvailableHoles();
                if (availableHoles.length === 0) {
                    return null;
                }

                const randomIndex = Math.floor(Math.random() * availableHoles.length);
                return availableHoles[randomIndex];
            }

            // Get hole by index
            getHole(index) {
                if (index < 0 || index >= this.holes.length) {
                    return null;
                }
                return this.holes[index];
            }

            // Get all holes
            getAllHoles() {
                return [...this.holes]; // Return copy to prevent external modification
            }

            // Get hole system statistics
            getHoleStats() {
                const stats = {
                    totalHoles: this.holes.length,
                    openHoles: 0,
                    occupiedHoles: 0,
                    availableHoles: 0,
                    closedHoles: 0
                };

                this.holes.forEach(hole => {
                    if (hole.state === 'OPEN') {
                        stats.openHoles++;
                        if (hole.occupied) {
                            stats.occupiedHoles++;
                        } else {
                            stats.availableHoles++;
                        }
                    } else {
                        stats.closedHoles++;
                    }
                });

                return stats;
            }

            // Update hole system (called each frame)
            update(deltaTime) {
                // Update any ongoing animations or effects
                // This method will be expanded in future tasks for creature interactions

                // Update indicator pulsing effect for available holes
                const time = performance.now() * 0.001; // Convert to seconds

                this.holes.forEach(hole => {
                    if (hole.state === 'OPEN' && !hole.occupied) {
                        // Subtle pulsing effect for available holes
                        const pulse = 0.3 + 0.1 * Math.sin(time * 2 + hole.index * 0.5);
                        hole.indicatorMesh.material.opacity = pulse;
                    }
                });
            }

            // Clean up hole system
            cleanup() {
                console.log('Cleaning up hole system...');

                if (this.holeGroup) {
                    // Remove from game space
                    if (this.gameSpace) {
                        this.gameSpace.remove(this.holeGroup);
                    }

                    // Dispose of geometries and materials
                    this.holeGroup.traverse((child) => {
                        if (child.geometry) {
                            child.geometry.dispose();
                        }
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(material => material.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });

                    this.holeGroup = null;
                }

                this.holes = [];
                this.isInitialized = false;
                console.log('Hole system cleanup complete');
            }

            // Mark hole as occupied by a creature
            occupyHole(holeIndex, creatureId) {
                if (holeIndex < 0 || holeIndex >= this.holes.length) {
                    console.error(`Invalid hole index: ${holeIndex}`);
                    return false;
                }

                const hole = this.holes[holeIndex];
                if (hole.occupied) {
                    console.warn(`Hole ${holeIndex} is already occupied`);
                    return false;
                }

                hole.occupied = true;
                hole.occupiedBy = creatureId;
                hole.occupiedAt = performance.now();

                // Update visual indicator
                if (hole.indicatorMesh) {
                    hole.indicatorMesh.material.opacity = 0.8;
                    hole.indicatorMesh.material.color.setHex(0xff6600); // Orange for occupied
                }

                console.log(`Hole ${holeIndex} occupied by creature ${creatureId}`);
                return true;
            }

            // Free hole from creature occupation
            freeHole(holeIndex) {
                if (holeIndex < 0 || holeIndex >= this.holes.length) {
                    console.error(`Invalid hole index: ${holeIndex}`);
                    return false;
                }

                const hole = this.holes[holeIndex];
                if (!hole.occupied) {
                    console.warn(`Hole ${holeIndex} is not occupied`);
                    return false;
                }

                const creatureId = hole.occupiedBy;
                hole.occupied = false;
                hole.occupiedBy = null;
                hole.occupiedAt = null;

                // Reset visual indicator
                if (hole.indicatorMesh) {
                    hole.indicatorMesh.material.opacity = 0.3;
                    hole.indicatorMesh.material.color.setHex(0x00ff00); // Green for available
                }

                console.log(`Hole ${holeIndex} freed from creature ${creatureId}`);
                return true;
            }

            // Check if hole system is ready
            isReady() {
                return this.isInitialized && this.holes.length === 9;
            }
        }

        // Creature model creation system
        class CreatureModelFactory {
            constructor() {
                this.creatureTypes = {
                    'mole': { points: 1, speed: 1.0, color: 0xA06630 },
                    'gopher': { points: 2, speed: 1.2, color: 0xCC0000 },
                    'rabbit': { points: 3, speed: 1.3, color: 0x0066CC },
                    'golden': { points: 5, speed: 1.4, color: 0xFFD700 }
                };

                console.log('CreatureModelFactory initialized');
            }

            // Create Brown Mole (Level 1) 3D model
            createBrownMole() {
                console.log('Creating Brown Mole 3D model...');

                // Create main creature group
                const moleGroup = new THREE.Group();
                moleGroup.name = 'brown-mole';

                // Build multi-layered creature anatomy
                const anatomy = this.createMoleAnatomy();

                // Add all body parts to the main group
                moleGroup.add(anatomy.body);
                moleGroup.add(anatomy.chest);
                moleGroup.add(anatomy.neck);
                moleGroup.add(anatomy.head);
                moleGroup.add(anatomy.leftPaw);
                moleGroup.add(anatomy.rightPaw);
                moleGroup.add(anatomy.tail);

                // Add creature-specific features
                const features = this.createMoleFeatures();
                moleGroup.add(features.nose);
                moleGroup.add(features.leftEye);
                moleGroup.add(features.rightEye);
                moleGroup.add(features.furPatch1);
                moleGroup.add(features.furPatch2);

                // Set creature metadata
                moleGroup.userData = {
                    type: 'mole',
                    points: this.creatureTypes.mole.points,
                    speed: this.creatureTypes.mole.speed,
                    baseColor: this.creatureTypes.mole.color,
                    createdAt: Date.now()
                };

                console.log('Brown Mole 3D model created successfully');
                return moleGroup;
            }

            // Create mole anatomy with proper scaling and positioning
            createMoleAnatomy() {
                // Brown coloring (#A06630) with MeshLambertMaterial and flat shading
                const brownMaterial = new THREE.MeshLambertMaterial({
                    color: 0xA06630,
                    flatShading: true
                });

                // Body (main torso) - ellipsoid shape
                const bodyGeometry = new THREE.SphereGeometry(0.08, 16, 12);
                bodyGeometry.scale(1, 0.8, 1.2); // Make it more oval
                const body = new THREE.Mesh(bodyGeometry, brownMaterial);
                body.name = 'mole-body';
                body.position.set(0, 0, 0);

                // Chest (upper torso) - smaller sphere
                const chestGeometry = new THREE.SphereGeometry(0.06, 16, 12);
                chestGeometry.scale(1, 0.9, 1.1);
                const chest = new THREE.Mesh(chestGeometry, brownMaterial);
                chest.name = 'mole-chest';
                chest.position.set(0, 0.08, 0.02);

                // Neck - small cylinder connecting chest to head
                const neckGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.04, 16);
                const neck = new THREE.Mesh(neckGeometry, brownMaterial);
                neck.name = 'mole-neck';
                neck.position.set(0, 0.12, 0.03);

                // Head - larger sphere
                const headGeometry = new THREE.SphereGeometry(0.07, 16, 12);
                headGeometry.scale(1, 1.1, 1);
                const head = new THREE.Mesh(headGeometry, brownMaterial);
                head.name = 'mole-head';
                head.position.set(0, 0.18, 0.04);

                // Left paw - small ellipsoid
                const pawGeometry = new THREE.SphereGeometry(0.025, 16, 12);
                pawGeometry.scale(1.5, 0.8, 1);
                const leftPaw = new THREE.Mesh(pawGeometry, brownMaterial);
                leftPaw.name = 'mole-left-paw';
                leftPaw.position.set(-0.07, -0.02, 0.08);

                // Right paw - small ellipsoid
                const rightPaw = new THREE.Mesh(pawGeometry.clone(), brownMaterial);
                rightPaw.name = 'mole-right-paw';
                rightPaw.position.set(0.07, -0.02, 0.08);

                // Tail - small tapered cylinder
                const tailGeometry = new THREE.CylinderGeometry(0.01, 0.02, 0.06, 16);
                tailGeometry.rotateX(Math.PI / 4); // Angle the tail
                const tail = new THREE.Mesh(tailGeometry, brownMaterial);
                tail.name = 'mole-tail';
                tail.position.set(0, -0.01, -0.12);

                return {
                    body,
                    chest,
                    neck,
                    head,
                    leftPaw,
                    rightPaw,
                    tail
                };
            }

            // Create creature-specific features (pink nose, black eyes, fur patches)
            createMoleFeatures() {
                // Pink nose material
                const pinkNoseMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFB6C1, // Light pink
                    flatShading: true
                });

                // Black eye material
                const blackEyeMaterial = new THREE.MeshLambertMaterial({
                    color: 0x000000, // Black
                    flatShading: true
                });

                // Darker brown for fur patches
                const darkBrownMaterial = new THREE.MeshLambertMaterial({
                    color: 0x8B4513, // Saddle brown
                    flatShading: true
                });

                // Pink nose - small sphere
                const noseGeometry = new THREE.SphereGeometry(0.015, 16, 12);
                const nose = new THREE.Mesh(noseGeometry, pinkNoseMaterial);
                nose.name = 'mole-nose';
                nose.position.set(0, 0.18, 0.11); // On front of head

                // Left eye - small black sphere
                const eyeGeometry = new THREE.SphereGeometry(0.008, 16, 12);
                const leftEye = new THREE.Mesh(eyeGeometry, blackEyeMaterial);
                leftEye.name = 'mole-left-eye';
                leftEye.position.set(-0.025, 0.19, 0.09);

                // Right eye - small black sphere
                const rightEye = new THREE.Mesh(eyeGeometry.clone(), blackEyeMaterial);
                rightEye.name = 'mole-right-eye';
                rightEye.position.set(0.025, 0.19, 0.09);

                // Fur patch 1 - on back
                const furPatchGeometry = new THREE.SphereGeometry(0.03, 16, 12);
                furPatchGeometry.scale(1.2, 0.5, 1);
                const furPatch1 = new THREE.Mesh(furPatchGeometry, darkBrownMaterial);
                furPatch1.name = 'mole-fur-patch-1';
                furPatch1.position.set(0, 0.05, -0.08);

                // Fur patch 2 - on side
                const furPatch2 = new THREE.Mesh(furPatchGeometry.clone(), darkBrownMaterial);
                furPatch2.name = 'mole-fur-patch-2';
                furPatch2.position.set(0.05, 0.02, 0.05);
                furPatch2.rotation.y = Math.PI / 4;

                return {
                    nose,
                    leftEye,
                    rightEye,
                    furPatch1,
                    furPatch2
                };
            }

            // Get creature type configuration
            getCreatureConfig(type) {
                return this.creatureTypes[type] || null;
            }

            // Validate creature geometry and materials (for testing)
            validateBrownMole(moleGroup) {
                const validationResults = {
                    isValid: true,
                    errors: [],
                    warnings: [],
                    components: {}
                };

                try {
                    // Check if main group exists
                    if (!moleGroup || !moleGroup.isGroup) {
                        validationResults.errors.push('Invalid mole group structure');
                        validationResults.isValid = false;
                        return validationResults;
                    }

                    // Expected components
                    const expectedComponents = [
                        'mole-body', 'mole-chest', 'mole-neck', 'mole-head',
                        'mole-left-paw', 'mole-right-paw', 'mole-tail',
                        'mole-nose', 'mole-left-eye', 'mole-right-eye',
                        'mole-fur-patch-1', 'mole-fur-patch-2'
                    ];

                    // Check each component
                    expectedComponents.forEach(componentName => {
                        const component = moleGroup.getObjectByName(componentName);
                        if (component) {
                            validationResults.components[componentName] = {
                                exists: true,
                                isMesh: component.isMesh,
                                hasGeometry: !!component.geometry,
                                hasMaterial: !!component.material,
                                materialType: component.material ? component.material.type : null,
                                position: component.position.toArray(),
                                scale: component.scale.toArray()
                            };

                            // Validate material properties
                            if (component.material) {
                                if (component.material.type !== 'MeshLambertMaterial') {
                                    validationResults.warnings.push(`${componentName} uses ${component.material.type} instead of MeshLambertMaterial`);
                                }

                                if (!component.material.flatShading) {
                                    validationResults.warnings.push(`${componentName} material does not use flat shading`);
                                }
                            }
                        } else {
                            validationResults.errors.push(`Missing component: ${componentName}`);
                            validationResults.isValid = false;
                            validationResults.components[componentName] = { exists: false };
                        }
                    });

                    // Check metadata
                    if (!moleGroup.userData || moleGroup.userData.type !== 'mole') {
                        validationResults.errors.push('Invalid or missing creature metadata');
                        validationResults.isValid = false;
                    }

                    // Check color consistency
                    const brownComponents = ['mole-body', 'mole-chest', 'mole-neck', 'mole-head', 'mole-left-paw', 'mole-right-paw', 'mole-tail'];
                    brownComponents.forEach(componentName => {
                        const component = moleGroup.getObjectByName(componentName);
                        if (component && component.material) {
                            const expectedColor = 0xA06630;
                            if (component.material.color.getHex() !== expectedColor) {
                                validationResults.warnings.push(`${componentName} has incorrect color: expected #A06630, got #${component.material.color.getHexString()}`);
                            }
                        }
                    });

                    // Check nose color
                    const nose = moleGroup.getObjectByName('mole-nose');
                    if (nose && nose.material) {
                        const expectedPinkColor = 0xFFB6C1;
                        if (nose.material.color.getHex() !== expectedPinkColor) {
                            validationResults.warnings.push(`Nose has incorrect color: expected #FFB6C1, got #${nose.material.color.getHexString()}`);
                        }
                    }

                    // Check eye colors
                    const leftEye = moleGroup.getObjectByName('mole-left-eye');
                    const rightEye = moleGroup.getObjectByName('mole-right-eye');
                    [leftEye, rightEye].forEach((eye, index) => {
                        if (eye && eye.material) {
                            const expectedBlackColor = 0x000000;
                            if (eye.material.color.getHex() !== expectedBlackColor) {
                                validationResults.warnings.push(`${index === 0 ? 'Left' : 'Right'} eye has incorrect color: expected #000000, got #${eye.material.color.getHexString()}`);
                            }
                        }
                    });

                } catch (error) {
                    validationResults.errors.push(`Validation error: ${error.message}`);
                    validationResults.isValid = false;
                }

                return validationResults;
            }

            // Create Red Gopher (Level 2) 3D model
            createRedGopher() {
                console.log('Creating Red Gopher 3D model...');

                // Create main creature group
                const gopherGroup = new THREE.Group();
                gopherGroup.name = 'red-gopher';

                // Build gopher anatomy with pronounced snout and pointed ears
                const anatomy = this.createGopherAnatomy();

                // Add all body parts to the main group
                gopherGroup.add(anatomy.body);
                gopherGroup.add(anatomy.chest);
                gopherGroup.add(anatomy.neck);
                gopherGroup.add(anatomy.head);
                gopherGroup.add(anatomy.snout);
                gopherGroup.add(anatomy.leftEar);
                gopherGroup.add(anatomy.rightEar);
                gopherGroup.add(anatomy.leftPaw);
                gopherGroup.add(anatomy.rightPaw);
                gopherGroup.add(anatomy.tail);

                // Add gopher-specific features
                const features = this.createGopherFeatures();
                gopherGroup.add(features.nose);
                gopherGroup.add(features.leftEye);
                gopherGroup.add(features.rightEye);
                gopherGroup.add(features.leftTooth);
                gopherGroup.add(features.rightTooth);

                // Set creature metadata
                gopherGroup.userData = {
                    type: 'gopher',
                    points: this.creatureTypes.gopher.points,
                    speed: this.creatureTypes.gopher.speed,
                    baseColor: this.creatureTypes.gopher.color,
                    createdAt: Date.now()
                };

                console.log('Red Gopher 3D model created successfully');
                return gopherGroup;
            }

            // Create gopher anatomy with pronounced snout and pointed ears
            createGopherAnatomy() {
                // Red coloring (#CC0000) with MeshLambertMaterial and flat shading
                const redMaterial = new THREE.MeshLambertMaterial({
                    color: 0xCC0000,
                    flatShading: true
                });

                // Body (main torso) - slightly more elongated than mole
                const bodyGeometry = new THREE.SphereGeometry(0.08, 16, 12);
                bodyGeometry.scale(1, 0.75, 1.3); // More elongated
                const body = new THREE.Mesh(bodyGeometry, redMaterial);
                body.name = 'gopher-body';
                body.position.set(0, 0, 0);

                // Chest (upper torso) - smaller and more angular
                const chestGeometry = new THREE.SphereGeometry(0.055, 16, 12);
                chestGeometry.scale(1, 0.85, 1.15);
                const chest = new THREE.Mesh(chestGeometry, redMaterial);
                chest.name = 'gopher-chest';
                chest.position.set(0, 0.08, 0.02);

                // Neck - slightly thicker for aggressive look
                const neckGeometry = new THREE.CylinderGeometry(0.035, 0.045, 0.04, 16);
                const neck = new THREE.Mesh(neckGeometry, redMaterial);
                neck.name = 'gopher-neck';
                neck.position.set(0, 0.12, 0.03);

                // Head - more angular and aggressive
                const headGeometry = new THREE.SphereGeometry(0.065, 16, 12);
                headGeometry.scale(1, 1.05, 1.1);
                const head = new THREE.Mesh(headGeometry, redMaterial);
                head.name = 'gopher-head';
                head.position.set(0, 0.18, 0.04);

                // Pronounced snout - elongated cylinder
                const snoutGeometry = new THREE.CylinderGeometry(0.02, 0.025, 0.05, 16);
                snoutGeometry.rotateX(Math.PI / 2); // Point forward
                const snout = new THREE.Mesh(snoutGeometry, redMaterial);
                snout.name = 'gopher-snout';
                snout.position.set(0, 0.17, 0.09);

                // Pointed ears - cone shapes
                const earGeometry = new THREE.ConeGeometry(0.02, 0.04, 16);
                const leftEar = new THREE.Mesh(earGeometry, redMaterial);
                leftEar.name = 'gopher-left-ear';
                leftEar.position.set(-0.04, 0.22, 0.02);
                leftEar.rotation.z = -Math.PI / 6; // Angle outward

                const rightEar = new THREE.Mesh(earGeometry.clone(), redMaterial);
                rightEar.name = 'gopher-right-ear';
                rightEar.position.set(0.04, 0.22, 0.02);
                rightEar.rotation.z = Math.PI / 6; // Angle outward

                // Left paw - slightly larger and more aggressive
                const pawGeometry = new THREE.SphereGeometry(0.028, 16, 12);
                pawGeometry.scale(1.4, 0.8, 1.1);
                const leftPaw = new THREE.Mesh(pawGeometry, redMaterial);
                leftPaw.name = 'gopher-left-paw';
                leftPaw.position.set(-0.075, -0.02, 0.08);

                // Right paw
                const rightPaw = new THREE.Mesh(pawGeometry.clone(), redMaterial);
                rightPaw.name = 'gopher-right-paw';
                rightPaw.position.set(0.075, -0.02, 0.08);

                // Tail - thicker and more prominent
                const tailGeometry = new THREE.CylinderGeometry(0.015, 0.025, 0.07, 16);
                tailGeometry.rotateX(Math.PI / 3); // More angled
                const tail = new THREE.Mesh(tailGeometry, redMaterial);
                tail.name = 'gopher-tail';
                tail.position.set(0, 0.01, -0.13);

                return {
                    body,
                    chest,
                    neck,
                    head,
                    snout,
                    leftEar,
                    rightEar,
                    leftPaw,
                    rightPaw,
                    tail
                };
            }

            // Create gopher-specific features (black nose, black eyes, white buck teeth)
            createGopherFeatures() {
                // Black octahedral nose material
                const blackNoseMaterial = new THREE.MeshLambertMaterial({
                    color: 0x000000, // Black
                    flatShading: true
                });

                // Black eye material
                const blackEyeMaterial = new THREE.MeshLambertMaterial({
                    color: 0x000000, // Black
                    flatShading: true
                });

                // White tooth material
                const whiteToothMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFFFF, // White
                    flatShading: true
                });

                // Black octahedral nose
                const noseGeometry = new THREE.OctahedronGeometry(0.012, 0);
                const nose = new THREE.Mesh(noseGeometry, blackNoseMaterial);
                nose.name = 'gopher-nose';
                nose.position.set(0, 0.17, 0.115); // On tip of snout

                // Left eye - slightly larger and more aggressive
                const eyeGeometry = new THREE.SphereGeometry(0.01, 16, 12);
                const leftEye = new THREE.Mesh(eyeGeometry, blackEyeMaterial);
                leftEye.name = 'gopher-left-eye';
                leftEye.position.set(-0.03, 0.19, 0.09);

                // Right eye
                const rightEye = new THREE.Mesh(eyeGeometry.clone(), blackEyeMaterial);
                rightEye.name = 'gopher-right-eye';
                rightEye.position.set(0.03, 0.19, 0.09);

                // Prominent white buck teeth
                const toothGeometry = new THREE.BoxGeometry(0.008, 0.025, 0.006);
                const leftTooth = new THREE.Mesh(toothGeometry, whiteToothMaterial);
                leftTooth.name = 'gopher-left-tooth';
                leftTooth.position.set(-0.008, 0.155, 0.11);

                const rightTooth = new THREE.Mesh(toothGeometry.clone(), whiteToothMaterial);
                rightTooth.name = 'gopher-right-tooth';
                rightTooth.position.set(0.008, 0.155, 0.11);

                return {
                    nose,
                    leftEye,
                    rightEye,
                    leftTooth,
                    rightTooth
                };
            }

            // Validate Red Gopher geometry and materials (for testing)
            validateRedGopher(gopherGroup) {
                const validationResults = {
                    isValid: true,
                    errors: [],
                    warnings: [],
                    components: {}
                };

                try {
                    // Check if main group exists
                    if (!gopherGroup || !gopherGroup.isGroup) {
                        validationResults.errors.push('Invalid gopher group structure');
                        validationResults.isValid = false;
                        return validationResults;
                    }

                    // Expected components
                    const expectedComponents = [
                        'gopher-body', 'gopher-chest', 'gopher-neck', 'gopher-head',
                        'gopher-snout', 'gopher-left-ear', 'gopher-right-ear',
                        'gopher-left-paw', 'gopher-right-paw', 'gopher-tail',
                        'gopher-nose', 'gopher-left-eye', 'gopher-right-eye',
                        'gopher-left-tooth', 'gopher-right-tooth'
                    ];

                    // Check each component
                    expectedComponents.forEach(componentName => {
                        const component = gopherGroup.getObjectByName(componentName);
                        if (component) {
                            validationResults.components[componentName] = {
                                exists: true,
                                isMesh: component.isMesh,
                                hasGeometry: !!component.geometry,
                                hasMaterial: !!component.material,
                                materialType: component.material ? component.material.type : null,
                                position: component.position.toArray(),
                                scale: component.scale.toArray()
                            };

                            // Validate material properties
                            if (component.material) {
                                if (component.material.type !== 'MeshLambertMaterial') {
                                    validationResults.warnings.push(`${componentName} uses ${component.material.type} instead of MeshLambertMaterial`);
                                }

                                if (!component.material.flatShading) {
                                    validationResults.warnings.push(`${componentName} material does not use flat shading`);
                                }
                            }
                        } else {
                            validationResults.errors.push(`Missing component: ${componentName}`);
                            validationResults.isValid = false;
                            validationResults.components[componentName] = { exists: false };
                        }
                    });

                    // Check metadata
                    if (!gopherGroup.userData || gopherGroup.userData.type !== 'gopher') {
                        validationResults.errors.push('Invalid or missing creature metadata');
                        validationResults.isValid = false;
                    }

                    // Check red color consistency
                    const redComponents = [
                        'gopher-body', 'gopher-chest', 'gopher-neck', 'gopher-head',
                        'gopher-snout', 'gopher-left-ear', 'gopher-right-ear',
                        'gopher-left-paw', 'gopher-right-paw', 'gopher-tail'
                    ];
                    redComponents.forEach(componentName => {
                        const component = gopherGroup.getObjectByName(componentName);
                        if (component && component.material) {
                            const expectedColor = 0xCC0000;
                            if (component.material.color.getHex() !== expectedColor) {
                                validationResults.warnings.push(`${componentName} has incorrect color: expected #CC0000, got #${component.material.color.getHexString()}`);
                            }
                        }
                    });

                    // Check nose color (should be black)
                    const nose = gopherGroup.getObjectByName('gopher-nose');
                    if (nose && nose.material) {
                        const expectedBlackColor = 0x000000;
                        if (nose.material.color.getHex() !== expectedBlackColor) {
                            validationResults.warnings.push(`Nose has incorrect color: expected #000000, got #${nose.material.color.getHexString()}`);
                        }
                    }

                    // Check eye colors (should be black)
                    const leftEye = gopherGroup.getObjectByName('gopher-left-eye');
                    const rightEye = gopherGroup.getObjectByName('gopher-right-eye');
                    [leftEye, rightEye].forEach((eye, index) => {
                        if (eye && eye.material) {
                            const expectedBlackColor = 0x000000;
                            if (eye.material.color.getHex() !== expectedBlackColor) {
                                validationResults.warnings.push(`${index === 0 ? 'Left' : 'Right'} eye has incorrect color: expected #000000, got #${eye.material.color.getHexString()}`);
                            }
                        }
                    });

                    // Check tooth colors (should be white)
                    const leftTooth = gopherGroup.getObjectByName('gopher-left-tooth');
                    const rightTooth = gopherGroup.getObjectByName('gopher-right-tooth');
                    [leftTooth, rightTooth].forEach((tooth, index) => {
                        if (tooth && tooth.material) {
                            const expectedWhiteColor = 0xFFFFFF;
                            if (tooth.material.color.getHex() !== expectedWhiteColor) {
                                validationResults.warnings.push(`${index === 0 ? 'Left' : 'Right'} tooth has incorrect color: expected #FFFFFF, got #${tooth.material.color.getHexString()}`);
                            }
                        }
                    });

                    // Validate gopher-specific features
                    // Check snout geometry (should be cylindrical)
                    const snout = gopherGroup.getObjectByName('gopher-snout');
                    if (snout && snout.geometry) {
                        if (snout.geometry.type !== 'CylinderGeometry') {
                            validationResults.warnings.push('Snout should use CylinderGeometry for pronounced shape');
                        }
                    }

                    // Check ear geometry (should be conical for pointed ears)
                    const leftEar = gopherGroup.getObjectByName('gopher-left-ear');
                    const rightEar = gopherGroup.getObjectByName('gopher-right-ear');
                    [leftEar, rightEar].forEach((ear, index) => {
                        if (ear && ear.geometry) {
                            if (ear.geometry.type !== 'ConeGeometry') {
                                validationResults.warnings.push(`${index === 0 ? 'Left' : 'Right'} ear should use ConeGeometry for pointed shape`);
                            }
                        }
                    });

                    // Check nose geometry (should be octahedral)
                    if (nose && nose.geometry) {
                        if (nose.geometry.type !== 'OctahedronGeometry') {
                            validationResults.warnings.push('Nose should use OctahedronGeometry for octahedral shape');
                        }
                    }

                } catch (error) {
                    validationResults.errors.push(`Validation error: ${error.message}`);
                    validationResults.isValid = false;
                }

                return validationResults;
            }

            // Create Blue Rabbit (Level 3) 3D model
            createBlueRabbit() {
                console.log('Creating Blue Rabbit 3D model...');

                // Create main creature group
                const rabbitGroup = new THREE.Group();
                rabbitGroup.name = 'blue-rabbit';

                // Build rabbit anatomy with long cylindrical ears and rabbit-specific proportions
                const anatomy = this.createRabbitAnatomy();

                // Add all body parts to the main group
                rabbitGroup.add(anatomy.body);
                rabbitGroup.add(anatomy.chest);
                rabbitGroup.add(anatomy.neck);
                rabbitGroup.add(anatomy.head);
                rabbitGroup.add(anatomy.leftEar);
                rabbitGroup.add(anatomy.rightEar);
                rabbitGroup.add(anatomy.leftPaw);
                rabbitGroup.add(anatomy.rightPaw);
                rabbitGroup.add(anatomy.tail);

                // Add rabbit-specific features
                const features = this.createRabbitFeatures();
                rabbitGroup.add(features.nose);
                rabbitGroup.add(features.leftEye);
                rabbitGroup.add(features.rightEye);
                rabbitGroup.add(features.leftWhisker1);
                rabbitGroup.add(features.leftWhisker2);
                rabbitGroup.add(features.leftWhisker3);
                rabbitGroup.add(features.rightWhisker1);
                rabbitGroup.add(features.rightWhisker2);
                rabbitGroup.add(features.rightWhisker3);

                // Set creature metadata
                rabbitGroup.userData = {
                    type: 'rabbit',
                    points: this.creatureTypes.rabbit.points,
                    speed: this.creatureTypes.rabbit.speed,
                    baseColor: this.creatureTypes.rabbit.color,
                    createdAt: Date.now()
                };

                console.log('Blue Rabbit 3D model created successfully');
                return rabbitGroup;
            }

            // Create rabbit anatomy with long cylindrical ears and rabbit-specific proportions
            createRabbitAnatomy() {
                // Blue coloring (#0066CC) with MeshLambertMaterial and flat shading
                const blueMaterial = new THREE.MeshLambertMaterial({
                    color: 0x0066CC,
                    flatShading: true
                });

                // Pink material for ear interiors
                const pinkMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFB6C1,
                    flatShading: true
                });

                // Body (main torso) - more compact and rounded for rabbit
                const bodyGeometry = new THREE.SphereGeometry(0.075, 16, 12);
                bodyGeometry.scale(1, 0.85, 1.1); // Slightly more compact
                const body = new THREE.Mesh(bodyGeometry, blueMaterial);
                body.name = 'rabbit-body';
                body.position.set(0, 0, 0);

                // Chest (upper torso) - smaller and more rounded
                const chestGeometry = new THREE.SphereGeometry(0.055, 16, 12);
                chestGeometry.scale(1, 0.9, 1.05);
                const chest = new THREE.Mesh(chestGeometry, blueMaterial);
                chest.name = 'rabbit-chest';
                chest.position.set(0, 0.075, 0.015);

                // Neck - shorter and thicker for rabbit proportions
                const neckGeometry = new THREE.CylinderGeometry(0.032, 0.038, 0.035, 16);
                const neck = new THREE.Mesh(neckGeometry, blueMaterial);
                neck.name = 'rabbit-neck';
                neck.position.set(0, 0.11, 0.025);

                // Head - more rounded and compact
                const headGeometry = new THREE.SphereGeometry(0.06, 16, 12);
                headGeometry.scale(1, 1.05, 0.95);
                const head = new THREE.Mesh(headGeometry, blueMaterial);
                head.name = 'rabbit-head';
                head.position.set(0, 0.16, 0.035);

                // Long cylindrical ears - distinctive rabbit feature
                const earGeometry = new THREE.CylinderGeometry(0.015, 0.018, 0.08, 16);
                const leftEar = new THREE.Mesh(earGeometry, blueMaterial);
                leftEar.name = 'rabbit-left-ear';
                leftEar.position.set(-0.025, 0.22, 0.02);
                leftEar.rotation.z = -Math.PI / 8; // Slight outward angle

                const rightEar = new THREE.Mesh(earGeometry.clone(), blueMaterial);
                rightEar.name = 'rabbit-right-ear';
                rightEar.position.set(0.025, 0.22, 0.02);
                rightEar.rotation.z = Math.PI / 8; // Slight outward angle

                // Add pink ear interiors
                const earInteriorGeometry = new THREE.CylinderGeometry(0.008, 0.01, 0.075, 16);
                const leftEarInterior = new THREE.Mesh(earInteriorGeometry, pinkMaterial);
                leftEarInterior.name = 'rabbit-left-ear-interior';
                leftEarInterior.position.set(0, 0, 0);
                leftEar.add(leftEarInterior);

                const rightEarInterior = new THREE.Mesh(earInteriorGeometry.clone(), pinkMaterial);
                rightEarInterior.name = 'rabbit-right-ear-interior';
                rightEarInterior.position.set(0, 0, 0);
                rightEar.add(rightEarInterior);

                // Left paw - smaller and more delicate
                const pawGeometry = new THREE.SphereGeometry(0.022, 16, 12);
                pawGeometry.scale(1.3, 0.75, 1);
                const leftPaw = new THREE.Mesh(pawGeometry, blueMaterial);
                leftPaw.name = 'rabbit-left-paw';
                leftPaw.position.set(-0.065, -0.025, 0.075);

                // Right paw
                const rightPaw = new THREE.Mesh(pawGeometry.clone(), blueMaterial);
                rightPaw.name = 'rabbit-right-paw';
                rightPaw.position.set(0.065, -0.025, 0.075);

                // Tail - small and fluffy (sphere)
                const tailGeometry = new THREE.SphereGeometry(0.02, 16, 12);
                const tail = new THREE.Mesh(tailGeometry, blueMaterial);
                tail.name = 'rabbit-tail';
                tail.position.set(0, 0.02, -0.095);

                return {
                    body,
                    chest,
                    neck,
                    head,
                    leftEar,
                    rightEar,
                    leftPaw,
                    rightPaw,
                    tail
                };
            }

            // Create rabbit-specific features (white tetrahedron nose, black eyes, six whiskers)
            createRabbitFeatures() {
                // White nose material
                const whiteNoseMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFFFF, // White
                    flatShading: true
                });

                // Black eye material
                const blackEyeMaterial = new THREE.MeshLambertMaterial({
                    color: 0x000000, // Black
                    flatShading: true
                });

                // Dark gray whisker material
                const whiskerMaterial = new THREE.MeshLambertMaterial({
                    color: 0x333333, // Dark gray
                    flatShading: true
                });

                // White tetrahedron nose
                const noseGeometry = new THREE.TetrahedronGeometry(0.012);
                const nose = new THREE.Mesh(noseGeometry, whiteNoseMaterial);
                nose.name = 'rabbit-nose';
                nose.position.set(0, 0.16, 0.095); // On front of head

                // Left eye - slightly larger than mole eyes
                const eyeGeometry = new THREE.SphereGeometry(0.009, 16, 12);
                const leftEye = new THREE.Mesh(eyeGeometry, blackEyeMaterial);
                leftEye.name = 'rabbit-left-eye';
                leftEye.position.set(-0.025, 0.17, 0.08);

                // Right eye
                const rightEye = new THREE.Mesh(eyeGeometry.clone(), blackEyeMaterial);
                rightEye.name = 'rabbit-right-eye';
                rightEye.position.set(0.025, 0.17, 0.08);

                // Six whiskers (3 per side) - thin cylinders
                const whiskerGeometry = new THREE.CylinderGeometry(0.001, 0.001, 0.04, 8);
                whiskerGeometry.rotateZ(Math.PI / 2); // Make horizontal

                // Left side whiskers
                const leftWhisker1 = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
                leftWhisker1.name = 'rabbit-left-whisker-1';
                leftWhisker1.position.set(-0.045, 0.17, 0.08);
                leftWhisker1.rotation.y = -Math.PI / 6; // Angle outward

                const leftWhisker2 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial);
                leftWhisker2.name = 'rabbit-left-whisker-2';
                leftWhisker2.position.set(-0.045, 0.16, 0.08);
                leftWhisker2.rotation.y = -Math.PI / 8;

                const leftWhisker3 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial);
                leftWhisker3.name = 'rabbit-left-whisker-3';
                leftWhisker3.position.set(-0.045, 0.15, 0.08);
                leftWhisker3.rotation.y = -Math.PI / 10;

                // Right side whiskers
                const rightWhisker1 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial);
                rightWhisker1.name = 'rabbit-right-whisker-1';
                rightWhisker1.position.set(0.045, 0.17, 0.08);
                rightWhisker1.rotation.y = Math.PI / 6; // Angle outward

                const rightWhisker2 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial);
                rightWhisker2.name = 'rabbit-right-whisker-2';
                rightWhisker2.position.set(0.045, 0.16, 0.08);
                rightWhisker2.rotation.y = Math.PI / 8;

                const rightWhisker3 = new THREE.Mesh(whiskerGeometry.clone(), whiskerMaterial);
                rightWhisker3.name = 'rabbit-right-whisker-3';
                rightWhisker3.position.set(0.045, 0.15, 0.08);
                rightWhisker3.rotation.y = Math.PI / 10;

                return {
                    nose,
                    leftEye,
                    rightEye,
                    leftWhisker1,
                    leftWhisker2,
                    leftWhisker3,
                    rightWhisker1,
                    rightWhisker2,
                    rightWhisker3
                };
            }

            // Validate Blue Rabbit geometry and materials (for testing)
            validateBlueRabbit(rabbitGroup) {
                const validationResults = {
                    isValid: true,
                    errors: [],
                    warnings: [],
                    components: {}
                };

                try {
                    // Check if main group exists
                    if (!rabbitGroup || !rabbitGroup.isGroup) {
                        validationResults.errors.push('Invalid rabbit group structure');
                        validationResults.isValid = false;
                        return validationResults;
                    }

                    // Expected components
                    const expectedComponents = [
                        'rabbit-body', 'rabbit-chest', 'rabbit-neck', 'rabbit-head',
                        'rabbit-left-ear', 'rabbit-right-ear',
                        'rabbit-left-paw', 'rabbit-right-paw', 'rabbit-tail',
                        'rabbit-nose', 'rabbit-left-eye', 'rabbit-right-eye',
                        'rabbit-left-whisker-1', 'rabbit-left-whisker-2', 'rabbit-left-whisker-3',
                        'rabbit-right-whisker-1', 'rabbit-right-whisker-2', 'rabbit-right-whisker-3'
                    ];

                    // Check each component
                    expectedComponents.forEach(componentName => {
                        const component = rabbitGroup.getObjectByName(componentName);
                        if (component) {
                            validationResults.components[componentName] = {
                                exists: true,
                                isMesh: component.isMesh,
                                hasGeometry: !!component.geometry,
                                hasMaterial: !!component.material,
                                materialType: component.material ? component.material.type : null,
                                position: component.position.toArray(),
                                scale: component.scale.toArray()
                            };

                            // Validate material properties
                            if (component.material) {
                                if (component.material.type !== 'MeshLambertMaterial') {
                                    validationResults.warnings.push(`${componentName} uses ${component.material.type} instead of MeshLambertMaterial`);
                                }

                                if (!component.material.flatShading) {
                                    validationResults.warnings.push(`${componentName} material does not use flat shading`);
                                }
                            }
                        } else {
                            validationResults.errors.push(`Missing component: ${componentName}`);
                            validationResults.isValid = false;
                            validationResults.components[componentName] = { exists: false };
                        }
                    });

                    // Check metadata
                    if (!rabbitGroup.userData || rabbitGroup.userData.type !== 'rabbit') {
                        validationResults.errors.push('Invalid or missing creature metadata');
                        validationResults.isValid = false;
                    }

                    // Check blue color consistency
                    const blueComponents = [
                        'rabbit-body', 'rabbit-chest', 'rabbit-neck', 'rabbit-head',
                        'rabbit-left-ear', 'rabbit-right-ear',
                        'rabbit-left-paw', 'rabbit-right-paw', 'rabbit-tail'
                    ];
                    blueComponents.forEach(componentName => {
                        const component = rabbitGroup.getObjectByName(componentName);
                        if (component && component.material) {
                            const expectedColor = 0x0066CC;
                            if (component.material.color.getHex() !== expectedColor) {
                                validationResults.warnings.push(`${componentName} has incorrect color: expected #0066CC, got #${component.material.color.getHexString()}`);
                            }
                        }
                    });

                    // Check nose color (should be white)
                    const nose = rabbitGroup.getObjectByName('rabbit-nose');
                    if (nose && nose.material) {
                        const expectedWhiteColor = 0xFFFFFF;
                        if (nose.material.color.getHex() !== expectedWhiteColor) {
                            validationResults.warnings.push(`Nose has incorrect color: expected #FFFFFF, got #${nose.material.color.getHexString()}`);
                        }
                    }

                    // Check eye colors (should be black)
                    const leftEye = rabbitGroup.getObjectByName('rabbit-left-eye');
                    const rightEye = rabbitGroup.getObjectByName('rabbit-right-eye');
                    [leftEye, rightEye].forEach((eye, index) => {
                        if (eye && eye.material) {
                            const expectedBlackColor = 0x000000;
                            if (eye.material.color.getHex() !== expectedBlackColor) {
                                validationResults.warnings.push(`${index === 0 ? 'Left' : 'Right'} eye has incorrect color: expected #000000, got #${eye.material.color.getHexString()}`);
                            }
                        }
                    });

                    // Validate rabbit-specific features
                    // Check ear geometry (should be cylindrical for long ears)
                    const leftEar = rabbitGroup.getObjectByName('rabbit-left-ear');
                    const rightEar = rabbitGroup.getObjectByName('rabbit-right-ear');
                    [leftEar, rightEar].forEach((ear, index) => {
                        if (ear && ear.geometry) {
                            if (ear.geometry.type !== 'CylinderGeometry') {
                                validationResults.warnings.push(`${index === 0 ? 'Left' : 'Right'} ear should use CylinderGeometry for cylindrical shape`);
                            }
                        }
                    });

                    // Check nose geometry (should be tetrahedral)
                    if (nose && nose.geometry) {
                        if (nose.geometry.type !== 'TetrahedronGeometry') {
                            validationResults.warnings.push('Nose should use TetrahedronGeometry for tetrahedron shape');
                        }
                    }

                    // Check whisker geometry (should be cylindrical)
                    const whiskerNames = [
                        'rabbit-left-whisker-1', 'rabbit-left-whisker-2', 'rabbit-left-whisker-3',
                        'rabbit-right-whisker-1', 'rabbit-right-whisker-2', 'rabbit-right-whisker-3'
                    ];
                    whiskerNames.forEach(whiskerName => {
                        const whisker = rabbitGroup.getObjectByName(whiskerName);
                        if (whisker && whisker.geometry) {
                            if (whisker.geometry.type !== 'CylinderGeometry') {
                                validationResults.warnings.push(`${whiskerName} should use CylinderGeometry for whisker shape`);
                            }
                        }
                    });

                    // Validate whisker count (should be exactly 6)
                    const whiskerCount = whiskerNames.filter(name => rabbitGroup.getObjectByName(name)).length;
                    if (whiskerCount !== 6) {
                        validationResults.warnings.push(`Expected 6 whiskers, found ${whiskerCount}`);
                    }

                } catch (error) {
                    validationResults.errors.push(`Validation error: ${error.message}`);
                    validationResults.isValid = false;
                }

                return validationResults;
            }

            // Create Golden Mole (Level 4) 3D model
            createGoldenMole() {
                console.log('Creating Golden Mole 3D model...');

                // Create main creature group
                const goldenMoleGroup = new THREE.Group();
                goldenMoleGroup.name = 'golden-mole';

                // Build golden mole anatomy with enlarged, regal proportions
                const anatomy = this.createGoldenMoleAnatomy();

                // Add all body parts to the main group
                goldenMoleGroup.add(anatomy.body);
                goldenMoleGroup.add(anatomy.chest);
                goldenMoleGroup.add(anatomy.neck);
                goldenMoleGroup.add(anatomy.head);
                goldenMoleGroup.add(anatomy.leftPaw);
                goldenMoleGroup.add(anatomy.rightPaw);
                goldenMoleGroup.add(anatomy.tail);

                // Add golden mole-specific premium features
                const features = this.createGoldenMoleFeatures();
                goldenMoleGroup.add(features.nose);
                goldenMoleGroup.add(features.leftEye);
                goldenMoleGroup.add(features.rightEye);
                goldenMoleGroup.add(features.crown);
                goldenMoleGroup.add(features.collar);

                // Add rotating sparkle effects
                const sparkles = this.createSparkleEffects();
                goldenMoleGroup.add(sparkles.sparkleGroup);

                // Set creature metadata
                goldenMoleGroup.userData = {
                    type: 'golden',
                    points: this.creatureTypes.golden.points,
                    speed: this.creatureTypes.golden.speed,
                    baseColor: this.creatureTypes.golden.color,
                    hasSparkles: true,
                    isPremium: true,
                    createdAt: Date.now()
                };

                console.log('Golden Mole 3D model created successfully');
                return goldenMoleGroup;
            }

            // Create golden mole anatomy with enlarged, regal proportions
            createGoldenMoleAnatomy() {
                // Gold coloring (#FFD700) with MeshLambertMaterial and flat shading
                const goldMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFD700,
                    flatShading: true
                });

                // Body (main torso) - enlarged and more regal (20% larger than regular mole)
                const bodyGeometry = new THREE.SphereGeometry(0.096, 16, 12); // 0.08 * 1.2
                bodyGeometry.scale(1, 0.8, 1.2);
                const body = new THREE.Mesh(bodyGeometry, goldMaterial);
                body.name = 'golden-mole-body';
                body.position.set(0, 0, 0);

                // Chest (upper torso) - enlarged and more prominent
                const chestGeometry = new THREE.SphereGeometry(0.072, 16, 12); // 0.06 * 1.2
                chestGeometry.scale(1, 0.9, 1.1);
                const chest = new THREE.Mesh(chestGeometry, goldMaterial);
                chest.name = 'golden-mole-chest';
                chest.position.set(0, 0.096, 0.024); // Scaled positions

                // Neck - thicker and more regal
                const neckGeometry = new THREE.CylinderGeometry(0.036, 0.048, 0.048, 16); // Scaled up
                const neck = new THREE.Mesh(neckGeometry, goldMaterial);
                neck.name = 'golden-mole-neck';
                neck.position.set(0, 0.144, 0.036);

                // Head - larger and more majestic
                const headGeometry = new THREE.SphereGeometry(0.084, 16, 12); // 0.07 * 1.2
                headGeometry.scale(1, 1.1, 1);
                const head = new THREE.Mesh(headGeometry, goldMaterial);
                head.name = 'golden-mole-head';
                head.position.set(0, 0.216, 0.048);

                // Left paw - larger and more prominent
                const pawGeometry = new THREE.SphereGeometry(0.03, 16, 12); // 0.025 * 1.2
                pawGeometry.scale(1.5, 0.8, 1);
                const leftPaw = new THREE.Mesh(pawGeometry, goldMaterial);
                leftPaw.name = 'golden-mole-left-paw';
                leftPaw.position.set(-0.084, -0.024, 0.096);

                // Right paw
                const rightPaw = new THREE.Mesh(pawGeometry.clone(), goldMaterial);
                rightPaw.name = 'golden-mole-right-paw';
                rightPaw.position.set(0.084, -0.024, 0.096);

                // Tail - larger and more majestic
                const tailGeometry = new THREE.CylinderGeometry(0.012, 0.024, 0.072, 16); // Scaled up
                tailGeometry.rotateX(Math.PI / 4);
                const tail = new THREE.Mesh(tailGeometry, goldMaterial);
                tail.name = 'golden-mole-tail';
                tail.position.set(0, -0.012, -0.144);

                return {
                    body,
                    chest,
                    neck,
                    head,
                    leftPaw,
                    rightPaw,
                    tail
                };
            }

            // Create golden mole premium features (crown, collar, enhanced features)
            createGoldenMoleFeatures() {
                // Pink nose material (same as regular mole but slightly larger)
                const pinkNoseMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFB6C1,
                    flatShading: true
                });

                // Black eye material (larger for regal appearance)
                const blackEyeMaterial = new THREE.MeshLambertMaterial({
                    color: 0x000000,
                    flatShading: true
                });

                // Gold material for crown
                const goldMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFD700,
                    flatShading: true
                });

                // Red jewel material
                const redJewelMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFF0000,
                    flatShading: true
                });

                // Purple collar material
                const purpleMaterial = new THREE.MeshLambertMaterial({
                    color: 0x800080,
                    flatShading: true
                });

                // Nose - slightly larger than regular mole
                const noseGeometry = new THREE.SphereGeometry(0.018, 16, 12); // 0.015 * 1.2
                const nose = new THREE.Mesh(noseGeometry, pinkNoseMaterial);
                nose.name = 'golden-mole-nose';
                nose.position.set(0, 0.216, 0.132); // Adjusted for larger head

                // Eyes - larger and more prominent
                const eyeGeometry = new THREE.SphereGeometry(0.0096, 16, 12); // 0.008 * 1.2
                const leftEye = new THREE.Mesh(eyeGeometry, blackEyeMaterial);
                leftEye.name = 'golden-mole-left-eye';
                leftEye.position.set(-0.03, 0.228, 0.108);

                const rightEye = new THREE.Mesh(eyeGeometry.clone(), blackEyeMaterial);
                rightEye.name = 'golden-mole-right-eye';
                rightEye.position.set(0.03, 0.228, 0.108);

                // Five-pointed crown
                const crown = this.createFivePointedCrown(goldMaterial, redJewelMaterial);
                crown.name = 'golden-mole-crown';
                crown.position.set(0, 0.27, 0.048); // On top of head

                // Purple collar (torus geometry)
                const collarGeometry = new THREE.TorusGeometry(0.045, 0.008, 8, 16);
                const collar = new THREE.Mesh(collarGeometry, purpleMaterial);
                collar.name = 'golden-mole-collar';
                collar.position.set(0, 0.18, 0.048); // Around neck area
                collar.rotation.x = Math.PI / 2; // Rotate to be horizontal

                return {
                    nose,
                    leftEye,
                    rightEye,
                    crown,
                    collar
                };
            }

            // Create five-pointed crown with red jewel
            createFivePointedCrown(goldMaterial, redJewelMaterial) {
                const crownGroup = new THREE.Group();
                crownGroup.name = 'crown-group';

                // Crown base (circular band)
                const baseGeometry = new THREE.CylinderGeometry(0.04, 0.042, 0.012, 16);
                const base = new THREE.Mesh(baseGeometry, goldMaterial);
                base.name = 'crown-base';
                base.position.set(0, 0, 0);
                crownGroup.add(base);

                // Five crown points (small cones arranged in a circle)
                const pointGeometry = new THREE.ConeGeometry(0.008, 0.024, 8);
                const angleStep = (Math.PI * 2) / 5; // 72 degrees between points

                for (let i = 0; i < 5; i++) {
                    const point = new THREE.Mesh(pointGeometry.clone(), goldMaterial);
                    point.name = `crown-point-${i + 1}`;

                    const angle = i * angleStep;
                    const radius = 0.041; // Slightly outside the base
                    point.position.set(
                        Math.cos(angle) * radius,
                        0.018, // Above the base
                        Math.sin(angle) * radius
                    );

                    crownGroup.add(point);
                }

                // Central red jewel (octahedron for premium look)
                const jewelGeometry = new THREE.OctahedronGeometry(0.006, 0);
                const jewel = new THREE.Mesh(jewelGeometry, redJewelMaterial);
                jewel.name = 'crown-jewel';
                jewel.position.set(0, 0.015, 0.042); // Front of crown
                crownGroup.add(jewel);

                return crownGroup;
            }

            // Create rotating sparkle effects with randomized positioning
            createSparkleEffects() {
                const sparkleGroup = new THREE.Group();
                sparkleGroup.name = 'sparkle-effects';

                // Sparkle material (bright white/yellow)
                const sparkleMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFFAA,
                    flatShading: true
                });

                // Create 8 sparkles around the golden mole
                const sparkleCount = 8;
                const sparkleGeometry = new THREE.OctahedronGeometry(0.004, 0);

                for (let i = 0; i < sparkleCount; i++) {
                    const sparkle = new THREE.Mesh(sparkleGeometry.clone(), sparkleMaterial);
                    sparkle.name = `sparkle-${i + 1}`;

                    // Randomized positioning around the creature
                    const angle = (i / sparkleCount) * Math.PI * 2;
                    const radius = 0.12 + (Math.random() * 0.04); // 0.12 to 0.16
                    const height = -0.02 + (Math.random() * 0.24); // -0.02 to 0.22

                    sparkle.position.set(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );

                    // Random initial rotation
                    sparkle.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );

                    // Store animation data
                    sparkle.userData = {
                        originalPosition: sparkle.position.clone(),
                        rotationSpeed: 0.02 + (Math.random() * 0.03), // 0.02 to 0.05
                        bobSpeed: 0.01 + (Math.random() * 0.02), // 0.01 to 0.03
                        bobAmount: 0.01 + (Math.random() * 0.02) // 0.01 to 0.03
                    };

                    sparkleGroup.add(sparkle);
                }

                return {
                    sparkleGroup
                };
            }

            // Animate sparkle effects (called in render loop)
            animateSparkles(goldenMoleGroup, deltaTime) {
                const sparkleGroup = goldenMoleGroup.getObjectByName('sparkle-effects');
                if (!sparkleGroup) return;

                sparkleGroup.children.forEach((sparkle, index) => {
                    if (sparkle.name.startsWith('sparkle-')) {
                        const userData = sparkle.userData;

                        // Rotate sparkle
                        sparkle.rotation.x += userData.rotationSpeed;
                        sparkle.rotation.y += userData.rotationSpeed * 0.7;
                        sparkle.rotation.z += userData.rotationSpeed * 0.5;

                        // Bob up and down
                        const time = Date.now() * 0.001;
                        const bobOffset = Math.sin(time * userData.bobSpeed + index) * userData.bobAmount;
                        sparkle.position.y = userData.originalPosition.y + bobOffset;
                    }
                });
            }

            // Validate Golden Mole geometry and materials (for testing)
            validateGoldenMole(goldenMoleGroup) {
                const validationResults = {
                    isValid: true,
                    errors: [],
                    warnings: [],
                    components: {}
                };

                try {
                    // Check if main group exists
                    if (!goldenMoleGroup || !goldenMoleGroup.isGroup) {
                        validationResults.errors.push('Invalid golden mole group structure');
                        validationResults.isValid = false;
                        return validationResults;
                    }

                    // Expected components
                    const expectedComponents = [
                        'golden-mole-body', 'golden-mole-chest', 'golden-mole-neck', 'golden-mole-head',
                        'golden-mole-left-paw', 'golden-mole-right-paw', 'golden-mole-tail',
                        'golden-mole-nose', 'golden-mole-left-eye', 'golden-mole-right-eye',
                        'golden-mole-crown', 'golden-mole-collar', 'sparkle-effects'
                    ];

                    // Check each component
                    expectedComponents.forEach(componentName => {
                        const component = goldenMoleGroup.getObjectByName(componentName);
                        if (component) {
                            validationResults.components[componentName] = {
                                exists: true,
                                isMesh: component.isMesh,
                                isGroup: component.isGroup,
                                hasGeometry: !!component.geometry,
                                hasMaterial: !!component.material,
                                materialType: component.material ? component.material.type : null
                            };

                            // Validate material properties for meshes
                            if (component.isMesh && component.material) {
                                if (component.material.type !== 'MeshLambertMaterial') {
                                    validationResults.warnings.push(`${componentName} uses ${component.material.type} instead of MeshLambertMaterial`);
                                }

                                if (!component.material.flatShading) {
                                    validationResults.warnings.push(`${componentName} material does not use flat shading`);
                                }
                            }
                        } else {
                            validationResults.errors.push(`Missing component: ${componentName}`);
                            validationResults.isValid = false;
                            validationResults.components[componentName] = { exists: false };
                        }
                    });

                    // Check metadata
                    if (!goldenMoleGroup.userData || goldenMoleGroup.userData.type !== 'golden') {
                        validationResults.errors.push('Invalid or missing creature metadata');
                        validationResults.isValid = false;
                    }

                } catch (error) {
                    validationResults.errors.push(`Validation error: ${error.message}`);
                    validationResults.isValid = false;
                }

                return validationResults;
            }
        }

        // Object pool for creature reuse to optimize performance
        class CreaturePool {
            constructor(scene, maxPoolSize = 10) {
                this.scene = scene;
                this.maxPoolSize = maxPoolSize;
                this.pools = {
                    'mole': [],
                    'gopher': [],
                    'rabbit': [],
                    'golden': []
                };
                this.creatureFactory = new CreatureModelFactory();

                // Pre-populate pools with creatures
                this.initializePools();

                console.log('CreaturePool initialized with max size:', maxPoolSize);
            }

            // Initialize pools with pre-created creatures
            initializePools() {
                const typesToPreload = ['mole', 'gopher', 'rabbit', 'golden'];
                const preloadCount = Math.floor(this.maxPoolSize / typesToPreload.length);

                typesToPreload.forEach(type => {
                    for (let i = 0; i < preloadCount; i++) {
                        const mesh = this.createCreatureMesh(type);
                        if (mesh) {
                            mesh.visible = false;
                            mesh.position.set(0, -10, 0); // Hide underground
                            this.scene.add(mesh);
                            this.pools[type].push({
                                mesh: mesh,
                                inUse: false,
                                type: type
                            });
                        }
                    }
                });

                console.log('Creature pools initialized:', {
                    mole: this.pools.mole.length,
                    gopher: this.pools.gopher.length,
                    rabbit: this.pools.rabbit.length,
                    golden: this.pools.golden.length
                });
            }

            // Create creature mesh using factory
            createCreatureMesh(type) {
                switch (type) {
                    case 'mole':
                        return this.creatureFactory.createBrownMole();
                    case 'gopher':
                        return this.creatureFactory.createRedGopher();
                    case 'rabbit':
                        return this.creatureFactory.createBlueRabbit();
                    case 'golden':
                        return this.creatureFactory.createGoldenMole();
                    default:
                        console.error(`Unknown creature type for pooling: ${type}`);
                        return null;
                }
            }

            // Get creature from pool or create new one
            getCreature(type) {
                const pool = this.pools[type];
                if (!pool) {
                    console.error(`No pool exists for creature type: ${type}`);
                    return null;
                }

                // Find available creature in pool
                for (let pooledCreature of pool) {
                    if (!pooledCreature.inUse) {
                        pooledCreature.inUse = true;
                        pooledCreature.mesh.visible = true;
                        console.log(`Retrieved ${type} from pool`);
                        return pooledCreature;
                    }
                }

                // Pool is full, create new creature if under max size
                if (pool.length < this.maxPoolSize) {
                    const mesh = this.createCreatureMesh(type);
                    if (mesh) {
                        this.scene.add(mesh);
                        const pooledCreature = {
                            mesh: mesh,
                            inUse: true,
                            type: type
                        };
                        pool.push(pooledCreature);
                        console.log(`Created new ${type} for pool (pool size: ${pool.length})`);
                        return pooledCreature;
                    }
                }

                console.warn(`No available ${type} creatures in pool and pool is at max capacity`);
                return null;
            }

            // Return creature to pool
            returnCreature(pooledCreature) {
                if (!pooledCreature || !pooledCreature.mesh) {
                    console.warn('Invalid creature returned to pool');
                    return;
                }

                // Reset creature state
                pooledCreature.inUse = false;
                pooledCreature.mesh.visible = false;
                pooledCreature.mesh.position.set(0, -10, 0); // Hide underground
                pooledCreature.mesh.rotation.set(0, 0, 0);
                pooledCreature.mesh.scale.set(1, 1, 1);

                // Clear user data
                pooledCreature.mesh.userData = {};

                console.log(`Returned ${pooledCreature.type} to pool`);
            }

            // Get pool statistics
            getPoolStats() {
                const stats = {};
                for (const [type, pool] of Object.entries(this.pools)) {
                    const inUse = pool.filter(c => c.inUse).length;
                    const available = pool.length - inUse;
                    stats[type] = { total: pool.length, inUse, available };
                }
                return stats;
            }

            // Clean up all pooled creatures
            cleanup() {
                console.log('Cleaning up creature pools...');

                for (const [type, pool] of Object.entries(this.pools)) {
                    pool.forEach(pooledCreature => {
                        if (pooledCreature.mesh.parent) {
                            this.scene.remove(pooledCreature.mesh);
                        }

                        // Dispose geometry and materials
                        pooledCreature.mesh.traverse((child) => {
                            if (child.geometry) {
                                child.geometry.dispose();
                            }
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(material => material.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    });
                    pool.length = 0;
                }

                console.log('Creature pool cleanup complete');
            }
        }

        // CreatureManager class for creature lifecycle management with object pooling
        class CreatureManager {
            constructor(scene, holeManager) {
                this.scene = scene;
                this.holeManager = holeManager;
                this.activeCreatures = new Map();
                this.creaturePool = new CreaturePool(scene, 15); // Pool of 15 creatures
                this.nextCreatureId = 1;

                // Creature type definitions with speed variations and timing behaviors
                this.creatureTypes = {
                    'mole': {
                        points: 1,
                        baseSpeed: 1.0,
                        speedVariation: 0.2, // Â±20%
                        baseActiveTime: 3000, // 3 seconds base
                        timeVariation: 0.3 // Â±30%
                    },
                    'gopher': {
                        points: 2,
                        baseSpeed: 1.2,
                        speedVariation: 0.4, // Â±40%
                        baseActiveTime: 2500, // 2.5 seconds base
                        timeVariation: 0.4 // Â±40%
                    },
                    'rabbit': {
                        points: 3,
                        baseSpeed: 1.3,
                        speedVariation: 0.5, // Â±50%
                        baseActiveTime: 2000, // 2 seconds base
                        timeVariation: 0.5 // Â±50%
                    },
                    'golden': {
                        points: 5,
                        baseSpeed: 1.4,
                        speedVariation: 0.6, // Â±60%
                        baseActiveTime: 1500, // 1.5 seconds base
                        timeVariation: 0.6 // Â±60%
                    }
                };

                // Animation timing constants
                this.animationTiming = {
                    emergenceTime: 500, // 0.5 seconds to emerge (as per task requirements)
                    retreatTime: 300,   // 0.3 seconds to retreat (as per task requirements)
                    hitAnimationTime: 400 // 0.4 seconds for hit animation
                };

                console.log('CreatureManager initialized');
            }

            // Create creature at specified hole with type and behavior using object pooling
            createCreature(type, holeIndex) {
                if (!this.creatureTypes[type]) {
                    console.error(`Unknown creature type: ${type}`);
                    return null;
                }

                if (!this.holeManager || !this.holeManager.isHoleAvailable(holeIndex)) {
                    console.warn(`Hole ${holeIndex} not available for creature spawn`);
                    return null;
                }

                const creatureId = `creature_${this.nextCreatureId++}`;
                const hole = this.holeManager.getHole(holeIndex);

                if (!hole) {
                    console.error(`Hole ${holeIndex} not found`);
                    return null;
                }

                console.log(`Creating ${type} creature at hole ${holeIndex}`);

                // Get creature from pool instead of creating new one
                const pooledCreature = this.creaturePool.getCreature(type);
                if (!pooledCreature) {
                    console.error(`Failed to get ${type} from creature pool`);
                    return null;
                }

                const creatureMesh = pooledCreature.mesh;

                // Calculate creature-specific speed and timing
                const typeConfig = this.creatureTypes[type];
                const speedMultiplier = typeConfig.baseSpeed +
                    (Math.random() - 0.5) * 2 * typeConfig.speedVariation * typeConfig.baseSpeed;
                const activeTime = typeConfig.baseActiveTime +
                    (Math.random() - 0.5) * 2 * typeConfig.timeVariation * typeConfig.baseActiveTime;

                // Position creature at hole (initially underground)
                creatureMesh.position.copy(hole.position);
                creatureMesh.position.y = -0.3; // Start underground

                // Add creature ID for hit detection
                creatureMesh.userData.creatureId = creatureId;
                creatureMesh.userData.holeIndex = holeIndex;

                // Create creature data object
                const creature = {
                    id: creatureId,
                    type: type,
                    mesh: creatureMesh,
                    pooledCreature: pooledCreature, // Store reference to pooled creature for cleanup
                    holeIndex: holeIndex,
                    position: hole.position.clone(),
                    state: 'EMERGING',
                    points: typeConfig.points,
                    speedMultiplier: speedMultiplier,
                    activeTime: activeTime,
                    timeRemaining: activeTime,

                    // Animation properties
                    emergenceProgress: 0,
                    retreatProgress: 0,
                    targetY: 0, // Surface level
                    startY: -0.3, // Underground level

                    // Timing
                    createdAt: performance.now(),
                    stateStartTime: performance.now()
                };

                // Add to scene and tracking
                this.scene.add(creatureMesh);
                this.activeCreatures.set(creatureId, creature);

                // Mark hole as occupied
                this.holeManager.occupyHole(holeIndex, creatureId);

                // Start emergence animation
                this.startEmergenceAnimation(creature);

                console.log(`Created creature ${creatureId} (${type}) at hole ${holeIndex} with speed ${speedMultiplier.toFixed(2)}x`);
                return creature;
            }

            // Start creature emergence animation
            startEmergenceAnimation(creature) {
                creature.state = 'EMERGING';
                creature.stateStartTime = performance.now();
                creature.emergenceProgress = 0;

                console.log(`Starting emergence animation for creature ${creature.id}`);
            }

            // Start creature retreat animation
            startRetreatAnimation(creature) {
                creature.state = 'RETREATING';
                creature.stateStartTime = performance.now();
                creature.retreatProgress = 0;

                console.log(`Starting retreat animation for creature ${creature.id}`);
            }

            // Handle creature hit
            hitCreature(creatureId) {
                const creature = this.activeCreatures.get(creatureId);
                if (!creature) {
                    console.warn(`Creature ${creatureId} not found for hit`);
                    return null;
                }

                if (creature.state === 'HIT' || creature.state === 'RETREATING') {
                    console.warn(`Creature ${creatureId} already hit or retreating`);
                    return null;
                }

                console.log(`Creature ${creatureId} hit! Awarding ${creature.points} points`);

                creature.state = 'HIT';
                creature.stateStartTime = performance.now();

                // Start retreat animation immediately
                this.startRetreatAnimation(creature);

                return {
                    creatureId: creatureId,
                    points: creature.points,
                    position: creature.position.clone(),
                    type: creature.type
                };
            }

            // Handle creature miss (timeout)
            missCreature(creatureId) {
                const creature = this.activeCreatures.get(creatureId);
                if (!creature) {
                    console.warn(`Creature ${creatureId} not found for miss`);
                    return null;
                }

                console.log(`Creature ${creatureId} missed! Penalty: -${creature.points} points`);

                // Create miss event data
                const missData = {
                    creatureId: creatureId,
                    creatureType: creature.type,
                    points: creature.points,
                    position: creature.position.clone(),
                    timestamp: performance.now()
                };

                // Dispatch miss event for particle system and score manager
                this.dispatchMissEvent(missData);

                // Start retreat animation
                this.startRetreatAnimation(creature);

                return missData;
            }

            // Update creature behavior and animations
            updateCreatureBehavior(creature, deltaTime) {
                const currentTime = performance.now();
                const stateElapsed = currentTime - creature.stateStartTime;

                switch (creature.state) {
                    case 'EMERGING':
                        this.updateEmergenceAnimation(creature, stateElapsed, deltaTime);
                        break;

                    case 'ACTIVE':
                        this.updateActiveState(creature, deltaTime);
                        break;

                    case 'RETREATING':
                    case 'HIT':
                        this.updateRetreatAnimation(creature, stateElapsed, deltaTime);
                        break;
                }

                // Update special effects for Golden Moles
                if (creature.type === 'golden') {
                    this.updateGoldenMoleEffects(creature, deltaTime);
                }
            }

            // Update emergence animation
            updateEmergenceAnimation(creature, stateElapsed, deltaTime) {
                const emergenceTime = this.animationTiming.emergenceTime / creature.speedMultiplier;
                creature.emergenceProgress = Math.min(stateElapsed / emergenceTime, 1.0);

                // Smooth easing function for emergence
                const easeProgress = this.easeOutBack(creature.emergenceProgress);

                // Update Y position
                creature.mesh.position.y = creature.startY +
                    (creature.targetY - creature.startY) * easeProgress;

                // Add slight rotation during emergence
                creature.mesh.rotation.y = Math.sin(creature.emergenceProgress * Math.PI) * 0.1;

                // Transition to active state when emergence complete
                if (creature.emergenceProgress >= 1.0) {
                    creature.state = 'ACTIVE';
                    creature.stateStartTime = performance.now();
                    creature.mesh.position.y = creature.targetY;
                    creature.mesh.rotation.y = 0;

                    console.log(`Creature ${creature.id} fully emerged, now active`);
                }
            }

            // Update active state (waiting for hit or timeout)
            updateActiveState(creature, deltaTime) {
                creature.timeRemaining -= deltaTime * 1000; // Convert to milliseconds

                // Add subtle idle animation
                const time = performance.now() * 0.001;
                creature.mesh.position.y = creature.targetY + Math.sin(time * 3) * 0.01;
                creature.mesh.rotation.y = Math.sin(time * 2) * 0.05;

                // Check for timeout
                if (creature.timeRemaining <= 0) {
                    console.log(`Creature ${creature.id} timed out`);
                    this.missCreature(creature.id);
                }
            }

            // Update retreat animation
            updateRetreatAnimation(creature, stateElapsed, deltaTime) {
                const retreatTime = this.animationTiming.retreatTime / creature.speedMultiplier;
                creature.retreatProgress = Math.min(stateElapsed / retreatTime, 1.0);

                // Smooth easing function for retreat
                const easeProgress = this.easeInBack(creature.retreatProgress);

                // Update Y position (going back underground)
                creature.mesh.position.y = creature.targetY +
                    (creature.startY - creature.targetY) * easeProgress;

                // Add rotation during retreat
                creature.mesh.rotation.y = creature.retreatProgress * Math.PI * 0.5;

                // Scale down slightly during retreat
                const scale = 1.0 - (easeProgress * 0.2);
                creature.mesh.scale.setScalar(scale);

                // Remove creature when retreat complete
                if (creature.retreatProgress >= 1.0) {
                    this.destroyCreature(creature.id);
                }
            }

            // Update Golden Mole special effects
            updateGoldenMoleEffects(creature, deltaTime) {
                if (!creature.mesh.userData.sparkles) return;

                const time = performance.now() * 0.001;

                // Rotate sparkles
                creature.mesh.userData.sparkles.forEach((sparkle, index) => {
                    sparkle.rotation.y = time * (1 + index * 0.3);
                    sparkle.rotation.x = Math.sin(time * (2 + index * 0.2)) * 0.2;

                    // Update sparkle positions
                    const radius = 0.15 + Math.sin(time * 2 + index) * 0.05;
                    const angle = time * (1 + index * 0.5) + index * (Math.PI * 2 / creature.mesh.userData.sparkles.length);
                    sparkle.position.x = Math.cos(angle) * radius;
                    sparkle.position.z = Math.sin(angle) * radius;
                    sparkle.position.y = 0.1 + Math.sin(time * 3 + index) * 0.03;
                });
            }

            // Destroy creature and return to pool for reuse
            destroyCreature(creatureId) {
                const creature = this.activeCreatures.get(creatureId);
                if (!creature) {
                    console.warn(`Creature ${creatureId} not found for destruction`);
                    return;
                }

                console.log(`Destroying creature ${creatureId}`);

                // Return pooled creature to pool instead of disposing
                if (creature.pooledCreature) {
                    this.creaturePool.returnCreature(creature.pooledCreature);
                } else {
                    // Fallback for non-pooled creatures (shouldn't happen with new system)
                    console.warn(`Creature ${creatureId} was not from pool, disposing normally`);
                    this.scene.remove(creature.mesh);

                    creature.mesh.traverse((child) => {
                        if (child.geometry) {
                            child.geometry.dispose();
                        }
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(material => material.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }

                // Free hole
                this.holeManager.freeHole(creature.holeIndex);

                // Remove from tracking
                this.activeCreatures.delete(creatureId);

                console.log(`Creature ${creatureId} returned to pool`);
            }

            // Update all active creatures
            update(deltaTime) {
                for (const creature of this.activeCreatures.values()) {
                    this.updateCreatureBehavior(creature, deltaTime);
                }
            }

            // Get creature by ID
            getCreature(creatureId) {
                return this.activeCreatures.get(creatureId);
            }

            // Get all active creatures
            getActiveCreatures() {
                return Array.from(this.activeCreatures.values());
            }

            // Get creature count by type
            getCreatureCountByType(type) {
                return Array.from(this.activeCreatures.values())
                    .filter(creature => creature.type === type).length;
            }

            // Get total active creature count
            getActiveCreatureCount() {
                return this.activeCreatures.size;
            }

            // Check if creature exists and is hittable
            isCreatureHittable(creatureId) {
                const creature = this.activeCreatures.get(creatureId);
                return creature && (creature.state === 'ACTIVE' || creature.state === 'EMERGING');
            }

            // Clean up all creatures
            cleanup() {
                console.log('Cleaning up all creatures...');

                const creatureIds = Array.from(this.activeCreatures.keys());
                creatureIds.forEach(id => this.destroyCreature(id));

                this.activeCreatures.clear();
                this.nextCreatureId = 1;

                console.log('All creatures cleaned up');
            }

            // Easing functions for smooth animations
            easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }

            easeInBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return c3 * t * t * t - c1 * t * t;
            }

            // Get creature manager statistics
            getStats() {
                const stats = {
                    totalActive: this.activeCreatures.size,
                    byType: {},
                    byState: {}
                };

                for (const creature of this.activeCreatures.values()) {
                    // Count by type
                    stats.byType[creature.type] = (stats.byType[creature.type] || 0) + 1;

                    // Count by state
                    stats.byState[creature.state] = (stats.byState[creature.state] || 0) + 1;
                }

                return stats;
            }
        }

        // InputManager class for controller input and hit detection system
        class InputManager {
            constructor(scene, renderer, arManager, creatureManager) {
                this.scene = scene;
                this.renderer = renderer;
                this.arManager = arManager;
                this.creatureManager = creatureManager;

                // Input state
                this.isVRMode = false;
                this.lastTriggerTime = 0;
                this.debounceDelay = 50; // 50ms debouncing as required
                this.raycaster = new THREE.Raycaster();

                // Desktop fallback
                this.mouse = new THREE.Vector2();
                this.camera = null;

                // Performance tracking
                this.hitDetectionStartTime = 0;
                this.maxLatency = 20; // 20ms max latency requirement

                // Event handlers
                this.onTriggerPress = this.onTriggerPress.bind(this);
                this.onMouseClick = this.onMouseClick.bind(this);
                this.onMouseMove = this.onMouseMove.bind(this);

                console.log('InputManager initialized');
            }

            // Initialize input system
            initialize(camera) {
                this.camera = camera;
                this.isVRMode = this.renderer.xr.isPresenting;

                if (this.isVRMode) {
                    this.setupVRInput();
                } else {
                    this.setupDesktopInput();
                }

                console.log(`Input system initialized for ${this.isVRMode ? 'VR' : 'Desktop'} mode`);
            }

            // Set up VR controller input
            setupVRInput() {
                console.log('Setting up VR controller input...');

                // Get controller from ARManager
                const controller = this.arManager.controller;
                if (!controller) {
                    console.error('No controller available from ARManager');
                    return;
                }

                // Add select event listener for trigger press
                controller.addEventListener('select', this.onTriggerPress);

                console.log('VR input setup complete');
            }

            // Set up desktop fallback input
            setupDesktopInput() {
                console.log('Setting up desktop fallback input...');

                // Add mouse event listeners
                const canvas = this.renderer.domElement;
                canvas.addEventListener('click', this.onMouseClick);
                canvas.addEventListener('mousemove', this.onMouseMove);

                // Set cursor style
                canvas.style.cursor = 'crosshair';

                console.log('Desktop input setup complete');
            }

            // Handle VR trigger press
            onTriggerPress(event) {
                const currentTime = performance.now();

                // Debounce input to prevent spam clicking
                if (currentTime - this.lastTriggerTime < this.debounceDelay) {
                    console.log('Input debounced - too fast');
                    return;
                }

                this.lastTriggerTime = currentTime;
                this.hitDetectionStartTime = currentTime;

                console.log('VR trigger pressed');

                // Perform hit detection from controller
                const controller = event.target;
                this.performHitDetection(controller, 'vr');
            }

            // Handle desktop mouse click
            onMouseClick(event) {
                const currentTime = performance.now();

                // Debounce input
                if (currentTime - this.lastTriggerTime < this.debounceDelay) {
                    console.log('Input debounced - too fast');
                    return;
                }

                this.lastTriggerTime = currentTime;
                this.hitDetectionStartTime = currentTime;

                console.log('Desktop mouse clicked');

                // Update mouse coordinates
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Perform hit detection from camera
                this.performHitDetection(this.camera, 'desktop');
            }

            // Handle mouse movement for desktop mode
            onMouseMove(event) {
                if (!this.isVRMode) {
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                }
            }

            // Perform hit detection with creatures
            performHitDetection(source, inputType) {
                console.log(`Performing hit detection from ${inputType} input`);

                try {
                    // Set up raycaster based on input type
                    if (inputType === 'vr') {
                        this.setupVRRaycaster(source);
                    } else {
                        this.setupDesktopRaycaster(source);
                    }

                    // Get all hittable creatures
                    const hittableObjects = this.getHittableCreatures();

                    if (hittableObjects.length === 0) {
                        console.log('No hittable creatures available');
                        this.checkLatency();
                        return;
                    }

                    // Perform intersection test
                    const intersects = this.raycaster.intersectObjects(hittableObjects, true);

                    if (intersects.length > 0) {
                        this.handleHit(intersects[0]);
                    } else {
                        console.log('No creatures hit');
                    }

                    this.checkLatency();

                } catch (error) {
                    console.error('Hit detection error:', error);
                }
            }

            // Set up raycaster for VR controller
            setupVRRaycaster(controller) {
                if (!controller) {
                    throw new Error('No controller provided for VR raycaster');
                }

                // Extract controller position and direction
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld);

                this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                console.log('VR raycaster configured');
            }

            // Set up raycaster for desktop camera
            setupDesktopRaycaster(camera) {
                if (!camera) {
                    throw new Error('No camera provided for desktop raycaster');
                }

                this.raycaster.setFromCamera(this.mouse, camera);
                console.log('Desktop raycaster configured');
            }

            // Get all hittable creature meshes
            getHittableCreatures() {
                const hittableObjects = [];
                const activeCreatures = this.creatureManager.getActiveCreatures();

                for (const creature of activeCreatures) {
                    // Only include creatures that are in hittable states
                    if (this.creatureManager.isCreatureHittable(creature.id)) {
                        // Add the creature mesh and all its children for hit detection
                        hittableObjects.push(creature.mesh);
                        creature.mesh.traverse((child) => {
                            if (child.isMesh) {
                                hittableObjects.push(child);
                            }
                        });
                    }
                }

                console.log(`Found ${hittableObjects.length} hittable objects from ${activeCreatures.length} creatures`);
                return hittableObjects;
            }

            // Handle successful hit
            handleHit(intersection) {
                const hitObject = intersection.object;
                let creatureId = null;

                // Find creature ID from the hit object or its parent
                let currentObject = hitObject;
                while (currentObject && !creatureId) {
                    if (currentObject.userData && currentObject.userData.creatureId) {
                        creatureId = currentObject.userData.creatureId;
                        break;
                    }
                    currentObject = currentObject.parent;
                }

                if (!creatureId) {
                    console.warn('Hit object has no creature ID');
                    return;
                }

                const creature = this.creatureManager.getCreature(creatureId);
                if (!creature) {
                    console.warn(`Creature ${creatureId} not found`);
                    return;
                }

                console.log(`Hit creature ${creatureId} (${creature.type}) at position:`, intersection.point);

                // Validate hit is still valid (creature might have retreated)
                if (!this.creatureManager.isCreatureHittable(creatureId)) {
                    console.log(`Creature ${creatureId} is no longer hittable`);
                    return;
                }

                // Process the hit
                this.processCreatureHit(creature, intersection);
            }

            // Process creature hit
            processCreatureHit(creature, intersection) {
                console.log(`Processing hit on ${creature.type} creature ${creature.id}`);

                // Update creature state to HIT
                creature.state = 'HIT';

                // Create hit event data
                const hitData = {
                    creatureId: creature.id,
                    creatureType: creature.type,
                    points: creature.points,
                    position: intersection.point.clone(),
                    timestamp: performance.now()
                };

                // Dispatch hit event for other systems to handle
                this.dispatchHitEvent(hitData);

                // Trigger creature destruction
                this.creatureManager.destroyCreature(creature.id);
            }

            // Dispatch hit event
            dispatchHitEvent(hitData) {
                const event = new CustomEvent('creatureHit', {
                    detail: hitData
                });

                document.dispatchEvent(event);
                console.log('Creature hit event dispatched:', hitData);
            }

            // Dispatch miss event
            dispatchMissEvent(missData) {
                const event = new CustomEvent('creatureMiss', {
                    detail: missData
                });

                document.dispatchEvent(event);
                console.log('Creature miss event dispatched:', missData);
            }

            // Check hit detection latency
            checkLatency() {
                if (this.hitDetectionStartTime > 0) {
                    const latency = performance.now() - this.hitDetectionStartTime;

                    if (latency > this.maxLatency) {
                        console.warn(`Hit detection latency ${latency.toFixed(2)}ms exceeds target ${this.maxLatency}ms`);
                    } else {
                        console.log(`Hit detection completed in ${latency.toFixed(2)}ms`);
                    }

                    this.hitDetectionStartTime = 0;
                }
            }

            // Update input system (called each frame)
            update() {
                // Check if VR mode changed
                const currentVRMode = this.renderer.xr.isPresenting;
                if (currentVRMode !== this.isVRMode) {
                    console.log(`Input mode changed: ${this.isVRMode ? 'VR' : 'Desktop'} -> ${currentVRMode ? 'VR' : 'Desktop'}`);
                    this.cleanup();
                    this.isVRMode = currentVRMode;
                    this.initialize(this.camera);
                }
            }

            // Validate input system
            validateInput() {
                const validation = {
                    isValid: true,
                    errors: [],
                    warnings: []
                };

                // Check required components
                if (!this.scene) {
                    validation.errors.push('Scene not available');
                    validation.isValid = false;
                }

                if (!this.renderer) {
                    validation.errors.push('Renderer not available');
                    validation.isValid = false;
                }

                if (!this.creatureManager) {
                    validation.errors.push('CreatureManager not available');
                    validation.isValid = false;
                }

                // Check VR-specific components
                if (this.isVRMode) {
                    if (!this.arManager || !this.arManager.controller) {
                        validation.errors.push('VR controller not available');
                        validation.isValid = false;
                    }
                } else {
                    if (!this.camera) {
                        validation.errors.push('Camera not available for desktop mode');
                        validation.isValid = false;
                    }
                }

                // Check debounce settings
                if (this.debounceDelay < 10 || this.debounceDelay > 100) {
                    validation.warnings.push(`Debounce delay ${this.debounceDelay}ms may not be optimal`);
                }

                return validation;
            }

            // Get input statistics
            getStats() {
                return {
                    mode: this.isVRMode ? 'VR' : 'Desktop',
                    debounceDelay: this.debounceDelay,
                    maxLatency: this.maxLatency,
                    lastTriggerTime: this.lastTriggerTime,
                    hasController: !!(this.arManager && this.arManager.controller),
                    hasCamera: !!this.camera
                };
            }

            // Clean up input system
            cleanup() {
                console.log('Cleaning up input system...');

                // Remove VR event listeners
                if (this.arManager && this.arManager.controller) {
                    this.arManager.controller.removeEventListener('select', this.onTriggerPress);
                }

                // Remove desktop event listeners
                if (this.renderer && this.renderer.domElement) {
                    const canvas = this.renderer.domElement;
                    canvas.removeEventListener('click', this.onMouseClick);
                    canvas.removeEventListener('mousemove', this.onMouseMove);
                    canvas.style.cursor = 'default';
                }

                // Reset state
                this.lastTriggerTime = 0;
                this.hitDetectionStartTime = 0;

                console.log('Input system cleanup complete');
            }
        }

        // ScoreManager class for scoring system and penalty mechanics
        class ScoreManager {
            constructor(scene) {
                this.scene = scene;
                this.totalScore = 0;
                this.levelScore = 0;
                this.startTime = null;
                this.elapsedTime = 0;

                // Creature point values based on requirements
                this.creaturePoints = {
                    'mole': 1,
                    'gopher': 2,
                    'rabbit': 3,
                    'golden': 5
                };

                // Level progression thresholds
                this.levelTargets = [10, 20, 30, 50]; // Points needed for levels 1-4

                // UI elements
                this.totalScoreElement = document.getElementById('total-score');
                this.timerElement = document.getElementById('timer');
                this.levelProgressElement = document.getElementById('level-progress');
                this.currentLevelElement = document.getElementById('current-level');

                // Feedback indicators pool for reuse
                this.feedbackPool = [];
                this.maxPoolSize = 10;

                console.log('ScoreManager initialized with creature points:', this.creaturePoints);
            }

            // Initialize scoring system and start timer
            initialize() {
                this.startTime = Date.now();
                this.totalScore = 0;
                this.levelScore = 0;
                this.elapsedTime = 0;

                this.updateScoreDisplay();
                this.updateLevelDisplay(1);

                console.log('ScoreManager initialized - game timer started');
            }

            // Add points for successful creature hit
            addScore(creatureType, position = null) {
                const points = this.creaturePoints[creatureType] || 1;

                this.totalScore += points;
                this.levelScore += points;

                // Create visual feedback for score gain
                if (position) {
                    this.createScoreIndicator(`+${points}`, position, 0x00ff00, true); // Green for positive
                }

                this.updateScoreDisplay();

                console.log(`Score added: +${points} (${creatureType}) - Total: ${this.totalScore}, Level: ${this.levelScore}`);

                return points;
            }

            // Subtract points for missed creature (penalty system)
            subtractScore(creatureType, position = null) {
                const points = this.creaturePoints[creatureType] || 1;

                // Apply penalty but prevent negative total score (clamp to 0)
                const previousTotal = this.totalScore;
                this.totalScore = Math.max(0, this.totalScore - points);

                // Level score can go negative to track performance
                this.levelScore -= points;

                // Create visual feedback for score loss
                if (position) {
                    this.createScoreIndicator(`-${points}`, position, 0xff0000, false); // Red for negative
                }

                this.updateScoreDisplay();

                const actualDeduction = previousTotal - this.totalScore;
                console.log(`Score penalty: -${points} (${creatureType}) - Actual deduction: ${actualDeduction} - Total: ${this.totalScore}, Level: ${this.levelScore}`);

                return actualDeduction;
            }

            // Create floating score indicator with animation
            createScoreIndicator(text, position, color, isPositive) {
                let indicator = this.getPooledIndicator();

                if (!indicator) {
                    // Create new indicator if pool is empty
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 64;
                    const context = canvas.getContext('2d');

                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        alphaTest: 0.1
                    });

                    indicator = {
                        sprite: new THREE.Sprite(material),
                        canvas: canvas,
                        context: context,
                        texture: texture,
                        inUse: false
                    };
                }

                // Update indicator text and color
                this.updateIndicatorText(indicator, text, color);

                // Position the indicator
                if (position) {
                    indicator.sprite.position.copy(position);
                    indicator.sprite.position.y += 0.3; // Slightly above the creature
                } else {
                    // Default position if no position provided
                    indicator.sprite.position.set(0, 1, 0);
                }

                indicator.sprite.scale.set(0.5, 0.25, 1);
                indicator.inUse = true;

                this.scene.add(indicator.sprite);

                // Animate the indicator
                this.animateScoreIndicator(indicator, isPositive);
            }

            // Update indicator text and appearance
            updateIndicatorText(indicator, text, color) {
                const ctx = indicator.context;
                const canvas = indicator.canvas;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Set text properties
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add text shadow for better visibility
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // Set text color
                ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;

                // Draw text
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);

                // Update texture
                indicator.texture.needsUpdate = true;
            }

            // Animate score indicator movement
            animateScoreIndicator(indicator, isPositive) {
                const startY = indicator.sprite.position.y;
                const targetY = isPositive ? startY + 0.8 : startY - 0.8; // Rise for positive, sink for negative
                const duration = 1000; // 1 second animation
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Ease-out animation
                    const easeProgress = 1 - Math.pow(1 - progress, 3);

                    // Update position
                    indicator.sprite.position.y = startY + (targetY - startY) * easeProgress;

                    // Fade out over time
                    indicator.sprite.material.opacity = 1 - progress;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Animation complete - return to pool
                        this.scene.remove(indicator.sprite);
                        this.returnIndicatorToPool(indicator);
                    }
                };

                animate();
            }

            // Get pooled indicator or create new one
            getPooledIndicator() {
                for (let indicator of this.feedbackPool) {
                    if (!indicator.inUse) {
                        return indicator;
                    }
                }

                // Create new indicator if pool not full
                if (this.feedbackPool.length < this.maxPoolSize) {
                    const indicator = this.createNewIndicator();
                    this.feedbackPool.push(indicator);
                    return indicator;
                }

                return null; // Pool is full
            }

            // Create new indicator object
            createNewIndicator() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 64;
                const context = canvas.getContext('2d');

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });

                return {
                    sprite: new THREE.Sprite(material),
                    canvas: canvas,
                    context: context,
                    texture: texture,
                    inUse: false
                };
            }

            // Return indicator to pool for reuse
            returnIndicatorToPool(indicator) {
                indicator.inUse = false;
                indicator.sprite.material.opacity = 1; // Reset opacity
                indicator.sprite.position.set(0, 0, 0); // Reset position
            }

            // Update score display in UI
            updateScoreDisplay() {
                if (this.totalScoreElement) {
                    this.totalScoreElement.textContent = this.totalScore.toString();
                }

                // Update timer
                if (this.startTime && this.timerElement) {
                    this.elapsedTime = Date.now() - this.startTime;
                    const minutes = Math.floor(this.elapsedTime / 60000);
                    const seconds = Math.floor((this.elapsedTime % 60000) / 1000);
                    this.timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }

            // Update level display and progress
            updateLevelDisplay(currentLevel) {
                if (this.currentLevelElement) {
                    this.currentLevelElement.textContent = `Level ${currentLevel}`;
                }

                if (this.levelProgressElement && currentLevel <= this.levelTargets.length) {
                    const target = this.levelTargets[currentLevel - 1];
                    const progress = Math.max(0, this.levelScore);
                    this.levelProgressElement.textContent = `${progress} / ${target}`;
                }
            }

            // Check if current level is completed
            checkLevelCompletion(currentLevel) {
                if (currentLevel > this.levelTargets.length) {
                    return false; // No more levels
                }

                const target = this.levelTargets[currentLevel - 1];
                const completed = this.levelScore >= target;

                if (completed) {
                    console.log(`Level ${currentLevel} completed! Score: ${this.levelScore}/${target}`);
                }

                return completed;
            }

            // Reset level score for next level
            resetLevelScore() {
                this.levelScore = 0;
                console.log('Level score reset for next level');
            }

            // Get current scores
            getScores() {
                return {
                    totalScore: this.totalScore,
                    levelScore: this.levelScore,
                    elapsedTime: this.elapsedTime
                };
            }

            // Get level target for specific level
            getLevelTarget(level) {
                if (level > 0 && level <= this.levelTargets.length) {
                    return this.levelTargets[level - 1];
                }
                return 0;
            }

            // Get creature point value
            getCreaturePoints(creatureType) {
                return this.creaturePoints[creatureType] || 1;
            }

            // Create level completion screen data
            createLevelCompletionData(level) {
                const target = this.getLevelTarget(level);
                const minutes = Math.floor(this.elapsedTime / 60000);
                const seconds = Math.floor((this.elapsedTime % 60000) / 1000);

                return {
                    level: level,
                    levelScore: Math.max(0, this.levelScore),
                    totalScore: this.totalScore,
                    target: target,
                    timeElapsed: `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`,
                    timeMs: this.elapsedTime
                };
            }

            // Reset all scores (for game restart)
            reset() {
                this.totalScore = 0;
                this.levelScore = 0;
                this.startTime = null;
                this.elapsedTime = 0;

                // Clear any active indicators
                this.feedbackPool.forEach(indicator => {
                    if (indicator.inUse) {
                        this.scene.remove(indicator.sprite);
                        indicator.inUse = false;
                    }
                });

                this.updateScoreDisplay();

                console.log('ScoreManager reset');
            }

            // Cleanup resources
            cleanup() {
                // Remove all indicators from scene
                this.feedbackPool.forEach(indicator => {
                    if (indicator.sprite.parent) {
                        this.scene.remove(indicator.sprite);
                    }

                    // Dispose of materials and textures
                    if (indicator.sprite.material) {
                        if (indicator.sprite.material.map) {
                            indicator.sprite.material.map.dispose();
                        }
                        indicator.sprite.material.dispose();
                    }
                });

                this.feedbackPool = [];

                console.log('ScoreManager cleanup complete');
            }
        }

        // Unit tests for Brown Mole creature geometry and material properties
        class CreatureModelTests {
            constructor() {
                this.factory = new CreatureModelFactory();
                this.testResults = [];
                console.log('CreatureModelTests initialized');
            }

            // Run all Brown Mole tests
            runBrownMoleTests() {
                console.log('Running Brown Mole unit tests...');

                this.testResults = [];

                // Test 1: Basic creation
                this.testBrownMoleCreation();

                // Test 2: Anatomy structure
                this.testBrownMoleAnatomy();

                // Test 3: Material properties
                this.testBrownMoleMaterials();

                // Test 4: Feature positioning
                this.testBrownMoleFeatures();

                // Test 5: Metadata validation
                this.testBrownMoleMetadata();

                // Report results
                this.reportTestResults();

                return this.testResults;
            }

            // Test basic Brown Mole creation
            testBrownMoleCreation() {
                const testName = 'Brown Mole Creation';
                try {
                    const mole = this.factory.createBrownMole();

                    if (!mole) {
                        throw new Error('Failed to create mole object');
                    }

                    if (!mole.isGroup) {
                        throw new Error('Mole is not a THREE.Group');
                    }

                    if (mole.name !== 'brown-mole') {
                        throw new Error(`Incorrect name: expected 'brown-mole', got '${mole.name}'`);
                    }

                    this.addTestResult(testName, true, 'Brown Mole created successfully');
                } catch (error) {
                    this.addTestResult(testName, false, error.message);
                }
            }

            // Test Brown Mole anatomy structure
            testBrownMoleAnatomy() {
                const testName = 'Brown Mole Anatomy';
                try {
                    const mole = this.factory.createBrownMole();
                    const requiredParts = [
                        'mole-body', 'mole-chest', 'mole-neck', 'mole-head',
                        'mole-left-paw', 'mole-right-paw', 'mole-tail'
                    ];

                    const missingParts = [];
                    requiredParts.forEach(partName => {
                        const part = mole.getObjectByName(partName);
                        if (!part) {
                            missingParts.push(partName);
                        } else if (!part.isMesh) {
                            throw new Error(`${partName} is not a mesh`);
                        }
                    });

                    if (missingParts.length > 0) {
                        throw new Error(`Missing anatomy parts: ${missingParts.join(', ')}`);
                    }

                    this.addTestResult(testName, true, 'All anatomy parts present and valid');
                } catch (error) {
                    this.addTestResult(testName, false, error.message);
                }
            }

            // Test Brown Mole material properties
            testBrownMoleMaterials() {
                const testName = 'Brown Mole Materials';
                try {
                    const mole = this.factory.createBrownMole();
                    const brownParts = [
                        'mole-body', 'mole-chest', 'mole-neck', 'mole-head',
                        'mole-left-paw', 'mole-right-paw', 'mole-tail'
                    ];

                    // Test brown material properties
                    brownParts.forEach(partName => {
                        const part = mole.getObjectByName(partName);
                        if (!part || !part.material) {
                            throw new Error(`${partName} missing material`);
                        }

                        if (part.material.type !== 'MeshLambertMaterial') {
                            throw new Error(`${partName} uses ${part.material.type} instead of MeshLambertMaterial`);
                        }

                        if (!part.material.flatShading) {
                            throw new Error(`${partName} material does not use flat shading`);
                        }

                        const expectedColor = 0xA06630;
                        if (part.material.color.getHex() !== expectedColor) {
                            throw new Error(`${partName} has wrong color: expected #A06630, got #${part.material.color.getHexString()}`);
                        }
                    });

                    this.addTestResult(testName, true, 'All materials have correct properties');
                } catch (error) {
                    this.addTestResult(testName, false, error.message);
                }
            }

            // Test Brown Mole features (nose, eyes, fur patches)
            testBrownMoleFeatures() {
                const testName = 'Brown Mole Features';
                try {
                    const mole = this.factory.createBrownMole();

                    // Test nose
                    const nose = mole.getObjectByName('mole-nose');
                    if (!nose) throw new Error('Missing nose');
                    if (nose.material.color.getHex() !== 0xFFB6C1) {
                        throw new Error('Nose has wrong color');
                    }

                    // Test eyes
                    const leftEye = mole.getObjectByName('mole-left-eye');
                    const rightEye = mole.getObjectByName('mole-right-eye');
                    if (!leftEye || !rightEye) throw new Error('Missing eyes');

                    if (leftEye.material.color.getHex() !== 0x000000 ||
                        rightEye.material.color.getHex() !== 0x000000) {
                        throw new Error('Eyes have wrong color');
                    }

                    // Test fur patches
                    const furPatch1 = mole.getObjectByName('mole-fur-patch-1');
                    const furPatch2 = mole.getObjectByName('mole-fur-patch-2');
                    if (!furPatch1 || !furPatch2) throw new Error('Missing fur patches');

                    this.addTestResult(testName, true, 'All features present with correct properties');
                } catch (error) {
                    this.addTestResult(testName, false, error.message);
                }
            }

            // Test Brown Mole metadata
            testBrownMoleMetadata() {
                const testName = 'Brown Mole Metadata';
                try {
                    const mole = this.factory.createBrownMole();

                    if (!mole.userData) {
                        throw new Error('Missing userData');
                    }

                    const expectedMetadata = {
                        type: 'mole',
                        points: 1,
                        speed: 1.0,
                        baseColor: 0xA06630
                    };

                    Object.keys(expectedMetadata).forEach(key => {
                        if (mole.userData[key] !== expectedMetadata[key]) {
                            throw new Error(`Incorrect ${key}: expected ${expectedMetadata[key]}, got ${mole.userData[key]}`);
                        }
                    });

                    if (!mole.userData.createdAt || typeof mole.userData.createdAt !== 'number') {
                        throw new Error('Missing or invalid createdAt timestamp');
                    }

                    this.addTestResult(testName, true, 'Metadata is correct and complete');
                } catch (error) {
                    this.addTestResult(testName, false, error.message);
                }
            }

            // Add test result
            addTestResult(testName, passed, message) {
                const result = {
                    test: testName,
                    passed: passed,
                    message: message,
                    timestamp: Date.now()
                };

                this.testResults.push(result);

                const status = passed ? 'âœ… PASS' : 'âŒ FAIL';
                console.log(`${status}: ${testName} - ${message}`);
            }

            // Report all test results
            reportTestResults() {
                const totalTests = this.testResults.length;
                const passedTests = this.testResults.filter(result => result.passed).length;
                const failedTests = totalTests - passedTests;

                console.log('\n=== Brown Mole Test Results ===');
                console.log(`Total Tests: ${totalTests}`);
                console.log(`Passed: ${passedTests}`);
                console.log(`Failed: ${failedTests}`);
                console.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

                if (failedTests > 0) {
                    console.log('\nFailed Tests:');
                    this.testResults.filter(result => !result.passed).forEach(result => {
                        console.log(`- ${result.test}: ${result.message}`);
                    });
                }

                console.log('================================\n');
            }

            // Run all Red Gopher tests
            runRedGopherTests() {
                console.log('Running Red Gopher unit tests...');

                this.testResults = [];

                // Test 1: Basic creation
                this.testRedGopherCreation();

                // Test 2: Anatomy structure
                this.testRedGopherAnatomy();

                // Test 3: Material properties
                this.testRedGopherMaterials();

                // Test4: Feature positioning
                this.testRedGopherFeatures();

                // Test 5: Metadata validation
                this.testRedGopherMetadata();

                // Report results
                this.reportRedGopherTestResults();

                return this.testResults;
            }

            // Test basic Red Gopher creation
            testRedGopherCreation() {
                const testName = 'Red Gopher Creation';
                try {
                    const gopher = this.factory.createRedGopher();

                    if (!gopher) {
                        throw new Error('Failed to create gopher object');
                    }

                    if (!gopher.isGroup) {
                        throw new Error('Gopher is not a THREE.Group');
                    }

                    if (gopher.name !== 'red-gopher') {
                        throw new Error(`Expected name 'red-gopher', got '${gopher.name}'`);
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'Red Gopher created successfully'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Red Gopher anatomy structure
            testRedGopherAnatomy() {
                const testName = 'Red Gopher Anatomy';
                try {
                    const gopher = this.factory.createRedGopher();

                    const requiredParts = [
                        'gopher-body', 'gopher-chest', 'gopher-neck', 'gopher-head',
                        'gopher-snout', 'gopher-left-ear', 'gopher-right-ear',
                        'gopher-left-paw', 'gopher-right-paw', 'gopher-tail'
                    ];

                    const missingParts = [];
                    requiredParts.forEach(partName => {
                        const part = gopher.getObjectByName(partName);
                        if (!part) {
                            missingParts.push(partName);
                        } else if (!part.isMesh) {
                            missingParts.push(`${partName} (not a mesh)`);
                        }
                    });

                    if (missingParts.length > 0) {
                        throw new Error(`Missing anatomy parts: ${missingParts.join(', ')}`);
                    }

                    // Check gopher-specific anatomy features
                    const snout = gopher.getObjectByName('gopher-snout');
                    if (!snout || snout.geometry.type !== 'CylinderGeometry') {
                        throw new Error('Snout should use CylinderGeometry for pronounced shape');
                    }

                    const leftEar = gopher.getObjectByName('gopher-left-ear');
                    const rightEar = gopher.getObjectByName('gopher-right-ear');
                    if (!leftEar || leftEar.geometry.type !== 'ConeGeometry') {
                        throw new Error('Left ear should use ConeGeometry for pointed shape');
                    }
                    if (!rightEar || rightEar.geometry.type !== 'ConeGeometry') {
                        throw new Error('Right ear should use ConeGeometry for pointed shape');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All anatomy parts present and correctly shaped'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Red Gopher material properties
            testRedGopherMaterials() {
                const testName = 'Red Gopher Materials';
                try {
                    const gopher = this.factory.createRedGopher();

                    const redParts = [
                        'gopher-body', 'gopher-chest', 'gopher-neck', 'gopher-head',
                        'gopher-snout', 'gopher-left-ear', 'gopher-right-ear',
                        'gopher-left-paw', 'gopher-right-paw', 'gopher-tail'
                    ];

                    const materialErrors = [];
                    redParts.forEach(partName => {
                        const part = gopher.getObjectByName(partName);
                        if (part && part.material) {
                            // Check material type
                            if (part.material.type !== 'MeshLambertMaterial') {
                                materialErrors.push(`${partName} uses ${part.material.type} instead of MeshLambertMaterial`);
                            }

                            // Check flat shading
                            if (!part.material.flatShading) {
                                materialErrors.push(`${partName} material does not use flat shading`);
                            }

                            // Check red color (#CC0000)
                            const expectedColor = 0xCC0000;
                            if (part.material.color.getHex() !== expectedColor) {
                                materialErrors.push(`${partName} has incorrect color: expected #CC0000, got #${part.material.color.getHexString()}`);
                            }
                        }
                    });

                    if (materialErrors.length > 0) {
                        throw new Error(`Material errors: ${materialErrors.join(', ')}`);
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All materials use correct type, shading, and red coloring'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Red Gopher feature positioning and characteristics
            testRedGopherFeatures() {
                const testName = 'Red Gopher Features';
                try {
                    const gopher = this.factory.createRedGopher();

                    // Test nose (should be black octahedral)
                    const nose = gopher.getObjectByName('gopher-nose');
                    if (!nose) {
                        throw new Error('Missing nose');
                    }
                    if (nose.geometry.type !== 'OctahedronGeometry') {
                        throw new Error('Nose should use OctahedronGeometry for octahedral shape');
                    }
                    if (nose.material.color.getHex() !== 0x000000) {
                        throw new Error(`Nose should be black (#000000), got #${nose.material.color.getHexString()}`);
                    }

                    // Test eyes (should be black)
                    const leftEye = gopher.getObjectByName('gopher-left-eye');
                    const rightEye = gopher.getObjectByName('gopher-right-eye');
                    if (!leftEye || !rightEye) {
                        throw new Error('Missing eyes');
                    }
                    if (leftEye.material.color.getHex() !== 0x000000) {
                        throw new Error(`Left eye should be black (#000000), got #${leftEye.material.color.getHexString()}`);
                    }
                    if (rightEye.material.color.getHex() !== 0x000000) {
                        throw new Error(`Right eye should be black (#000000), got #${rightEye.material.color.getHexString()}`);
                    }

                    // Test prominent white buck teeth
                    const leftTooth = gopher.getObjectByName('gopher-left-tooth');
                    const rightTooth = gopher.getObjectByName('gopher-right-tooth');
                    if (!leftTooth || !rightTooth) {
                        throw new Error('Missing buck teeth');
                    }
                    if (leftTooth.material.color.getHex() !== 0xFFFFFF) {
                        throw new Error(`Left tooth should be white (#FFFFFF), got #${leftTooth.material.color.getHexString()}`);
                    }
                    if (rightTooth.material.color.getHex() !== 0xFFFFFF) {
                        throw new Error(`Right tooth should be white (#FFFFFF), got #${rightTooth.material.color.getHexString()}`);
                    }

                    // Check tooth geometry (should be box for buck teeth)
                    if (leftTooth.geometry.type !== 'BoxGeometry') {
                        throw new Error('Left tooth should use BoxGeometry for buck tooth shape');
                    }
                    if (rightTooth.geometry.type !== 'BoxGeometry') {
                        throw new Error('Right tooth should use BoxGeometry for buck tooth shape');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All gopher-specific features present with correct colors and shapes'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Red Gopher metadata
            testRedGopherMetadata() {
                const testName = 'Red Gopher Metadata';
                try {
                    const gopher = this.factory.createRedGopher();

                    if (!gopher.userData) {
                        throw new Error('Missing userData');
                    }

                    const expectedMetadata = {
                        type: 'gopher',
                        points: 2,
                        speed: 1.2,
                        baseColor: 0xCC0000
                    };

                    Object.keys(expectedMetadata).forEach(key => {
                        if (gopher.userData[key] !== expectedMetadata[key]) {
                            throw new Error(`Incorrect ${key}: expected ${expectedMetadata[key]}, got ${gopher.userData[key]}`);
                        }
                    });

                    if (!gopher.userData.createdAt || typeof gopher.userData.createdAt !== 'number') {
                        throw new Error('Missing or invalid createdAt timestamp');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All metadata properties correct'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Report Red Gopher test results
            reportRedGopherTestResults() {
                const totalTests = this.testResults.length;
                const passedTests = this.testResults.filter(result => result.passed).length;
                const failedTests = totalTests - passedTests;

                console.log('\n=== Red Gopher Test Results ===');
                console.log(`Total Tests: ${totalTests}`);
                console.log(`Passed: ${passedTests}`);
                console.log(`Failed: ${failedTests}`);
                console.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

                if (failedTests > 0) {
                    console.log('\nFailed Tests:');
                    this.testResults.filter(result => !result.passed).forEach(result => {
                        console.log(`- ${result.test}: ${result.message}`);
                    });
                }

                console.log('=================================\n');
            }

            // Run all Blue Rabbit tests
            runBlueRabbitTests() {
                console.log('Running Blue Rabbit unit tests...');

                this.testResults = [];

                // Test 1: Basic creation
                this.testBlueRabbitCreation();

                // Test 2: Anatomy structure
                this.testBlueRabbitAnatomy();

                // Test 3: Material properties
                this.testBlueRabbitMaterials();

                // Test 4: Feature positioning
                this.testBlueRabbitFeatures();

                // Test 5: Metadata validation
                this.testBlueRabbitMetadata();

                // Report results
                this.reportBlueRabbitTestResults();
            }

            // Test Blue Rabbit creation
            testBlueRabbitCreation() {
                const testName = 'Blue Rabbit Creation';
                try {
                    const rabbit = this.factory.createBlueRabbit();

                    if (!rabbit) {
                        throw new Error('Failed to create Blue Rabbit');
                    }

                    if (!rabbit.isGroup) {
                        throw new Error('Blue Rabbit is not a THREE.Group');
                    }

                    if (rabbit.name !== 'blue-rabbit') {
                        throw new Error(`Incorrect name: expected 'blue-rabbit', got '${rabbit.name}'`);
                    }

                    if (rabbit.children.length === 0) {
                        throw new Error('Blue Rabbit has no child components');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: `Blue Rabbit created successfully with ${rabbit.children.length} components`
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Blue Rabbit anatomy structure
            testBlueRabbitAnatomy() {
                const testName = 'Blue Rabbit Anatomy';
                try {
                    const rabbit = this.factory.createBlueRabbit();

                    const requiredParts = [
                        'rabbit-body', 'rabbit-chest', 'rabbit-neck', 'rabbit-head',
                        'rabbit-left-ear', 'rabbit-right-ear',
                        'rabbit-left-paw', 'rabbit-right-paw', 'rabbit-tail'
                    ];

                    const missingParts = [];
                    requiredParts.forEach(partName => {
                        const part = rabbit.getObjectByName(partName);
                        if (!part || !part.isMesh) {
                            missingParts.push(partName);
                        }
                    });

                    if (missingParts.length > 0) {
                        throw new Error(`Missing anatomy parts: ${missingParts.join(', ')}`);
                    }

                    // Test ear geometry (should be cylindrical)
                    const leftEar = rabbit.getObjectByName('rabbit-left-ear');
                    const rightEar = rabbit.getObjectByName('rabbit-right-ear');

                    if (leftEar.geometry.type !== 'CylinderGeometry') {
                        throw new Error('Left ear should use CylinderGeometry for long cylindrical shape');
                    }

                    if (rightEar.geometry.type !== 'CylinderGeometry') {
                        throw new Error('Right ear should use CylinderGeometry for long cylindrical shape');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All anatomy parts present with correct geometry'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Blue Rabbit material properties
            testBlueRabbitMaterials() {
                const testName = 'Blue Rabbit Materials';
                try {
                    const rabbit = this.factory.createBlueRabbit();

                    const blueParts = [
                        'rabbit-body', 'rabbit-chest', 'rabbit-neck', 'rabbit-head',
                        'rabbit-left-ear', 'rabbit-right-ear',
                        'rabbit-left-paw', 'rabbit-right-paw', 'rabbit-tail'
                    ];

                    const expectedBlueColor = 0x0066CC;
                    const materialErrors = [];

                    blueParts.forEach(partName => {
                        const part = rabbit.getObjectByName(partName);
                        if (part && part.material) {
                            if (part.material.type !== 'MeshLambertMaterial') {
                                materialErrors.push(`${partName} uses ${part.material.type} instead of MeshLambertMaterial`);
                            }

                            if (!part.material.flatShading) {
                                materialErrors.push(`${partName} material does not use flat shading`);
                            }

                            if (part.material.color.getHex() !== expectedBlueColor) {
                                materialErrors.push(`${partName} has incorrect color: expected #0066CC, got #${part.material.color.getHexString()}`);
                            }
                        }
                    });

                    if (materialErrors.length > 0) {
                        throw new Error(materialErrors.join('; '));
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All materials use correct type, shading, and blue coloring'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Blue Rabbit features
            testBlueRabbitFeatures() {
                const testName = 'Blue Rabbit Features';
                try {
                    const rabbit = this.factory.createBlueRabbit();

                    // Test nose (should be white tetrahedron)
                    const nose = rabbit.getObjectByName('rabbit-nose');
                    if (!nose || !nose.isMesh) {
                        throw new Error('Missing rabbit nose');
                    }

                    if (nose.geometry.type !== 'TetrahedronGeometry') {
                        throw new Error('Nose should use TetrahedronGeometry for tetrahedron shape');
                    }

                    if (nose.material.color.getHex() !== 0xFFFFFF) {
                        throw new Error(`Nose should be white (#FFFFFF), got #${nose.material.color.getHexString()}`);
                    }

                    // Test eyes (should be black)
                    const leftEye = rabbit.getObjectByName('rabbit-left-eye');
                    const rightEye = rabbit.getObjectByName('rabbit-right-eye');

                    if (!leftEye || !rightEye) {
                        throw new Error('Missing rabbit eyes');
                    }

                    if (leftEye.material.color.getHex() !== 0x000000) {
                        throw new Error(`Left eye should be black (#000000), got #${leftEye.material.color.getHexString()}`);
                    }

                    if (rightEye.material.color.getHex() !== 0x000000) {
                        throw new Error(`Right eye should be black (#000000), got #${rightEye.material.color.getHexString()}`);
                    }

                    // Test whiskers (should be 6 total)
                    const whiskerNames = [
                        'rabbit-left-whisker-1', 'rabbit-left-whisker-2', 'rabbit-left-whisker-3',
                        'rabbit-right-whisker-1', 'rabbit-right-whisker-2', 'rabbit-right-whisker-3'
                    ];

                    const missingWhiskers = [];
                    whiskerNames.forEach(whiskerName => {
                        const whisker = rabbit.getObjectByName(whiskerName);
                        if (!whisker || !whisker.isMesh) {
                            missingWhiskers.push(whiskerName);
                        } else if (whisker.geometry.type !== 'CylinderGeometry') {
                            throw new Error(`${whiskerName} should use CylinderGeometry for whisker shape`);
                        }
                    });

                    if (missingWhiskers.length > 0) {
                        throw new Error(`Missing whiskers: ${missingWhiskers.join(', ')}`);
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All features present with correct geometry and colors'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test Blue Rabbit metadata
            testBlueRabbitMetadata() {
                const testName = 'Blue Rabbit Metadata';
                try {
                    const rabbit = this.factory.createBlueRabbit();

                    if (!rabbit.userData) {
                        throw new Error('Missing userData');
                    }

                    const expectedMetadata = {
                        type: 'rabbit',
                        points: 3,
                        speed: 1.3,
                        baseColor: 0x0066CC
                    };

                    Object.keys(expectedMetadata).forEach(key => {
                        if (rabbit.userData[key] !== expectedMetadata[key]) {
                            throw new Error(`Incorrect ${key}: expected ${expectedMetadata[key]}, got ${rabbit.userData[key]}`);
                        }
                    });

                    if (!rabbit.userData.createdAt || typeof rabbit.userData.createdAt !== 'number') {
                        throw new Error('Missing or invalid createdAt timestamp');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'All metadata properties correct'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Report Blue Rabbit test results
            reportBlueRabbitTestResults() {
                const totalTests = this.testResults.length;
                const passedTests = this.testResults.filter(result => result.passed).length;
                const failedTests = totalTests - passedTests;

                console.log('\n=== Blue Rabbit Test Results ===');
                console.log(`Total Tests: ${totalTests}`);
                console.log(`Passed: ${passedTests}`);
                console.log(`Failed: ${failedTests}`);
                console.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

                if (failedTests > 0) {
                    console.log('\nFailed Tests:');
                    this.testResults.filter(result => !result.passed).forEach(result => {
                        console.log(`- ${result.test}: ${result.message}`);
                    });
                }

                console.log('=================================\n');
            }

            // Get test summary
            getTestSummary() {
                const totalTests = this.testResults.length;
                const passedTests = this.testResults.filter(result => result.passed).length;

                return {
                    total: totalTests,
                    passed: passedTests,
                    failed: totalTests - passedTests,
                    successRate: totalTests > 0 ? (passedTests / totalTests) * 100 : 0,
                    results: [...this.testResults]
                };
            }
        }

        // Initialize the app when the page loads
        window.addEventListener('load', initializeApp);

        // Run Brown Mole tests after page load for validation
        window.addEventListener('load', () => {
            // Wait a moment for Three.js to load, then run tests
            setTimeout(() => {
                console.log('Running Brown Mole validation tests...');
                const tester = new CreatureModelTests();
                const results = tester.runBrownMoleTests();

                // Store test results globally for inspection
                window.brownMoleTestResults = results;

                // Also test the factory validation method
                console.log('\nRunning factory validation test...');
                const factory = new CreatureModelFactory();
                const mole = factory.createBrownMole();
                const validation = factory.validateBrownMole(mole);

                console.log('Factory validation results:', validation);
                window.brownMoleValidation = validation;

            }, 1000);
        });

        // Unit tests for creature behavior and animation timing
        class CreatureBehaviorTests {
            constructor() {
                this.testResults = [];
                this.mockScene = new THREE.Scene();
                this.mockHoleManager = this.createMockHoleManager();
                this.creatureManager = new CreatureManager(this.mockScene, this.mockHoleManager);
            }

            // Create mock hole manager for testing
            createMockHoleManager() {
                return {
                    holes: Array.from({ length: 9 }, (_, i) => ({
                        index: i,
                        position: new THREE.Vector3(
                            (i % 3 - 1) * 0.3,
                            0,
                            (Math.floor(i / 3) - 1) * 0.3
                        ),
                        occupied: false,
                        occupiedBy: null
                    })),
                    isHoleAvailable: function (index) {
                        return index >= 0 && index < this.holes.length && !this.holes[index].occupied;
                    },
                    getHole: function (index) {
                        return index >= 0 && index < this.holes.length ? this.holes[index] : null;
                    },
                    occupyHole: function (index, creatureId) {
                        if (this.isHoleAvailable(index)) {
                            this.holes[index].occupied = true;
                            this.holes[index].occupiedBy = creatureId;
                            return true;
                        }
                        return false;
                    },
                    freeHole: function (index) {
                        if (index >= 0 && index < this.holes.length) {
                            this.holes[index].occupied = false;
                            this.holes[index].occupiedBy = null;
                            return true;
                        }
                        return false;
                    }
                };
            }

            // Test creature creation
            testCreatureCreation() {
                const testName = 'Creature Creation';
                try {
                    const creature = this.creatureManager.createCreature('mole', 0);

                    if (!creature) {
                        throw new Error('Failed to create creature');
                    }

                    if (creature.type !== 'mole') {
                        throw new Error(`Expected type 'mole', got '${creature.type}'`);
                    }

                    if (creature.state !== 'EMERGING') {
                        throw new Error(`Expected state 'EMERGING', got '${creature.state}'`);
                    }

                    if (creature.holeIndex !== 0) {
                        throw new Error(`Expected holeIndex 0, got ${creature.holeIndex}`);
                    }

                    if (!creature.mesh) {
                        throw new Error('Creature mesh not created');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'Creature created successfully with correct properties'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test creature speed variations
            testCreatureSpeedVariations() {
                const testName = 'Creature Speed Variations';
                try {
                    const creatures = [];
                    const types = ['mole', 'gopher', 'rabbit', 'golden'];

                    // Create multiple creatures of each type
                    types.forEach((type, typeIndex) => {
                        for (let i = 0; i < 3; i++) {
                            const holeIndex = typeIndex * 3 + i;
                            if (holeIndex < 9) {
                                const creature = this.creatureManager.createCreature(type, holeIndex);
                                if (creature) {
                                    creatures.push(creature);
                                }
                            }
                        }
                    });

                    if (creatures.length === 0) {
                        throw new Error('No creatures created for speed testing');
                    }

                    // Check speed variations
                    const speedsByType = {};
                    creatures.forEach(creature => {
                        if (!speedsByType[creature.type]) {
                            speedsByType[creature.type] = [];
                        }
                        speedsByType[creature.type].push(creature.speedMultiplier);
                    });

                    // Verify speed ranges for each type
                    const expectedRanges = {
                        'mole': { base: 1.0, variation: 0.2 },
                        'gopher': { base: 1.2, variation: 0.4 },
                        'rabbit': { base: 1.3, variation: 0.5 },
                        'golden': { base: 1.4, variation: 0.6 }
                    };

                    Object.keys(speedsByType).forEach(type => {
                        const speeds = speedsByType[type];
                        const expected = expectedRanges[type];
                        const minExpected = expected.base * (1 - expected.variation);
                        const maxExpected = expected.base * (1 + expected.variation);

                        speeds.forEach(speed => {
                            if (speed < minExpected || speed > maxExpected) {
                                throw new Error(`${type} speed ${speed} outside expected range [${minExpected}, ${maxExpected}]`);
                            }
                        });
                    });

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: `Speed variations correct for all creature types`
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test creature state management
            testCreatureStateManagement() {
                const testName = 'Creature State Management';
                try {
                    const creature = this.creatureManager.createCreature('mole', 1);

                    if (!creature) {
                        throw new Error('Failed to create creature for state testing');
                    }

                    // Test initial state
                    if (creature.state !== 'EMERGING') {
                        throw new Error(`Expected initial state 'EMERGING', got '${creature.state}'`);
                    }

                    // Simulate emergence completion
                    creature.state = 'ACTIVE';
                    creature.timeRemaining = 1000;

                    // Test hit
                    const hitResult = this.creatureManager.hitCreature(creature.id);
                    if (!hitResult) {
                        throw new Error('Hit result not returned');
                    }

                    if (hitResult.points !== 1) {
                        throw new Error(`Expected 1 point, got ${hitResult.points}`);
                    }

                    if (creature.state !== 'HIT') {
                        throw new Error(`Expected state 'HIT' after hit, got '${creature.state}'`);
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'Creature state transitions work correctly'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test animation timing
            testAnimationTiming() {
                const testName = 'Animation Timing';
                try {
                    const creature = this.creatureManager.createCreature('rabbit', 2);

                    if (!creature) {
                        throw new Error('Failed to create creature for timing test');
                    }

                    // Test emergence timing
                    const emergenceTime = this.creatureManager.animationTiming.emergenceTime;
                    if (typeof emergenceTime !== 'number' || emergenceTime <= 0) {
                        throw new Error(`Invalid emergence time: ${emergenceTime}`);
                    }

                    // Test retreat timing
                    const retreatTime = this.creatureManager.animationTiming.retreatTime;
                    if (typeof retreatTime !== 'number' || retreatTime <= 0) {
                        throw new Error(`Invalid retreat time: ${retreatTime}`);
                    }

                    // Test speed multiplier affects timing
                    const adjustedEmergenceTime = emergenceTime / creature.speedMultiplier;
                    if (adjustedEmergenceTime === emergenceTime && creature.speedMultiplier !== 1.0) {
                        throw new Error('Speed multiplier not affecting animation timing');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'Animation timing constants are valid and speed-adjusted'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Test creature lifecycle
            testCreatureLifecycle() {
                const testName = 'Creature Lifecycle';
                try {
                    const initialCount = this.creatureManager.getActiveCreatureCount();

                    // Create creature
                    const creature = this.creatureManager.createCreature('gopher', 3);
                    if (!creature) {
                        throw new Error('Failed to create creature');
                    }

                    // Check count increased
                    if (this.creatureManager.getActiveCreatureCount() !== initialCount + 1) {
                        throw new Error('Active creature count not updated after creation');
                    }

                    // Check hole occupation
                    if (!this.mockHoleManager.holes[3].occupied) {
                        throw new Error('Hole not marked as occupied');
                    }

                    // Destroy creature
                    this.creatureManager.destroyCreature(creature.id);

                    // Check count decreased
                    if (this.creatureManager.getActiveCreatureCount() !== initialCount) {
                        throw new Error('Active creature count not updated after destruction');
                    }

                    // Check hole freed
                    if (this.mockHoleManager.holes[3].occupied) {
                        throw new Error('Hole not freed after creature destruction');
                    }

                    this.testResults.push({
                        test: testName,
                        passed: true,
                        message: 'Creature lifecycle managed correctly'
                    });

                } catch (error) {
                    this.testResults.push({
                        test: testName,
                        passed: false,
                        message: error.message
                    });
                }
            }

            // Run all creature behavior tests
            runAllTests() {
                console.log('\n=== Running Creature Behavior Tests ===');

                this.testResults = [];

                this.testCreatureCreation();
                this.testCreatureSpeedVariations();
                this.testCreatureStateManagement();
                this.testAnimationTiming();
                this.testCreatureLifecycle();

                this.reportTestResults();
                return this.getTestSummary();
            }

            // Report test results
            reportTestResults() {
                const totalTests = this.testResults.length;
                const passedTests = this.testResults.filter(result => result.passed).length;
                const failedTests = totalTests - passedTests;

                console.log(`\nTotal Tests: ${totalTests}`);
                console.log(`Passed: ${passedTests}`);
                console.log(`Failed: ${failedTests}`);
                console.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

                if (failedTests > 0) {
                    console.log('\nFailed Tests:');
                    this.testResults.filter(result => !result.passed).forEach(result => {
                        console.log(`- ${result.test}: ${result.message}`);
                    });
                }

                console.log('=====================================\n');
            }

            // Get test summary
            getTestSummary() {
                const totalTests = this.testResults.length;
                const passedTests = this.testResults.filter(result => result.passed).length;

                return {
                    total: totalTests,
                    passed: passedTests,
                    failed: totalTests - passedTests,
                    successRate: totalTests > 0 ? (passedTests / totalTests) * 100 : 0,
                    results: [...this.testResults]
                };
            }

            // Clean up test resources
            cleanup() {
                this.creatureManager.cleanup();
                this.mockScene.clear();
            }
        }

        // Run creature behavior tests after page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('Running Creature Behavior Tests...');
                const behaviorTester = new CreatureBehaviorTests();
                const results = behaviorTester.runAllTests();

                // Store test results globally for inspection
                window.creatureBehaviorTestResults = results;

                // Clean up test resources
                behaviorTester.cleanup();

            }, 1500); // Run after creature model tests
        });

        console.log('Whack-a-Mole AR script loaded');
    </script>
</body>

</html>